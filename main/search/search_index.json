{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Overview","text":"<p>Datamol is a python library to work with molecules. It's a layer built on top of RDKit and aims to be as light as possible.</p> <ul> <li>\ud83d\udc0d Simple pythonic API</li> <li>\u2697\ufe0f RDKit first: all you manipulate are <code>rdkit.Chem.Mol</code> objects.</li> <li>\u2705 Manipulating molecules often rely on many options; Datamol provides good defaults by design.</li> <li>\ud83e\udde0 Performance matters: built-in efficient parallelization when possible with optional progress bar.</li> <li>\ud83d\udd79\ufe0f Modern IO: out-of-the-box support for remote paths using <code>fsspec</code> to read and write multiple formats (sdf, xlsx, csv, etc).</li> </ul> <p>Visit our website at https://datamol.io.</p>"},{"location":"index.html#installation","title":"Installation","text":"<p>Use conda:</p> <pre><code>mamba install -c conda-forge datamol\n</code></pre> <p>Tips: You can replace <code>mamba</code> by <code>conda</code>.</p> <p>Note: We highly recommend using a Conda Python distribution to install Datamol. The package is also pip installable if you need it: <code>pip install datamol</code>.</p>"},{"location":"index.html#quick-api-tour","title":"Quick API Tour","text":"<pre><code>import datamol as dm\n\n# Common functions\nmol = dm.to_mol(\"O=C(C)Oc1ccccc1C(=O)O\", sanitize=True)\nfp = dm.to_fp(mol)\nselfies = dm.to_selfies(mol)\ninchi = dm.to_inchi(mol)\n\n# Standardize and sanitize\nmol = dm.to_mol(\"O=C(C)Oc1ccccc1C(=O)O\")\nmol = dm.fix_mol(mol)\nmol = dm.sanitize_mol(mol)\nmol = dm.standardize_mol(mol)\n\n# Dataframe manipulation\ndf = dm.data.freesolv()\nmols = dm.from_df(df)\n\n# 2D viz\nlegends = [dm.to_smiles(mol) for mol in mols[:10]]\ndm.viz.to_image(mols[:10], legends=legends)\n\n# Generate conformers\nsmiles = \"O=C(C)Oc1ccccc1C(=O)O\"\nmol = dm.to_mol(smiles)\nmol_with_conformers = dm.conformers.generate(mol)\n\n# 3D viz (using nglview)\ndm.viz.conformers(mol, n_confs=10)\n\n# Compute SASA from conformers\nsasa = dm.conformers.sasa(mol_with_conformers)\n\n# Easy IO\nmols = dm.read_sdf(\"s3://my-awesome-data-lake/smiles.sdf\", as_df=False)\ndm.to_sdf(mols, \"gs://data-bucket/smiles.sdf\")\n</code></pre>"},{"location":"index.html#how-to-cite","title":"How to cite","text":"<p>Please cite Datamol if you use it in your research: .</p>"},{"location":"index.html#compatibilities","title":"Compatibilities","text":"<p>Version compatibilities are an essential topic for production-software stacks. We are cautious about documenting compatibility between <code>datamol</code>, <code>python</code> and <code>rdkit</code>.</p> <p>See below the associated versions of Python and RDKit, for which a minor version of Datamol has been tested during its whole lifecycle. It does not mean other combinations does not work but that those are not tested.</p> <code>datamol</code> <code>python</code> <code>rdkit</code> <code>0.9</code> <code>[3.9, 3.10]</code> <code>[2022.03, 2022.09]</code> <code>0.8</code> <code>[3.8, 3.9, 3.10]</code> <code>[2021.09, 2022.03, 2022.09]</code> <code>0.7</code> <code>[3.8, 3.9]</code> <code>[2021.09, 2022.03]</code> <code>0.6</code> <code>[3.8, 3.9]</code> <code>[2021.09]</code> <code>0.5</code> <code>[3.8, 3.9]</code> <code>[2021.03, 2021.09]</code> <code>0.4</code> <code>[3.8, 3.9]</code> <code>[2020.09, 2021.03]</code> <code>0.3</code> <code>[3.8, 3.9]</code> <code>[2020.09, 2021.03]</code>"},{"location":"contribute.html","title":"Contribute","text":"<p>The below documents the development lifecycle of Datamol.</p>"},{"location":"contribute.html#setup-a-dev-environment","title":"Setup a dev environment","text":"<pre><code>mamba env create -n datamol -f env.yml\nconda activate datamol\npip install -e .\n</code></pre>"},{"location":"contribute.html#setup-a-dev-environment-with-dev-container","title":"Setup a dev environment with dev container","text":"<p>This repository is setup to use dev container. You can use it locally with VSCode or any editor supporting dev containers as well as on GitHub Codespaces.</p> <p>The env is based on the Micromamba Docker image.</p>"},{"location":"contribute.html#continuous-integration","title":"Continuous Integration","text":"<p>Datamol uses Github Actions to:</p> <ul> <li>Build and test <code>datamol</code>.<ul> <li>Multiple combinations of OS, Python and RDKit versions are tested.</li> </ul> </li> <li>Check the code:<ul> <li>Formatting with <code>black</code>.</li> <li>Static type check with <code>mypy</code>.</li> </ul> </li> <li>Documentation: build and deploy the documentation on <code>main</code> and for every new git tag.</li> </ul>"},{"location":"contribute.html#run-tests","title":"Run tests","text":"<pre><code>pytest\n</code></pre>"},{"location":"contribute.html#build-the-documentation","title":"Build the documentation","text":"<p>You can build and serve the documentation locally with:</p> <pre><code># Build and serve the doc\nmike serve\n</code></pre>"},{"location":"contribute.html#multi-versionning","title":"Multi-versionning","text":"<p>The doc is built for eash push on <code>main</code> and every git tags using mike. Everything is automated using Github Actions. Please refer to the official mike's documentation for the details.</p>"},{"location":"contribute.html#release-a-new-version","title":"Release a new version","text":"<ul> <li>Run check: <code>rever check</code>.</li> <li>Bump and release new version: <code>rever VERSION_NUMBER</code>.</li> <li>Releasing a new version will do the following things in that order:<ul> <li>Update <code>AUTHORS.rst</code>.</li> <li>Update <code>CHANGELOG.rst</code>.</li> <li>Bump the version number in <code>setup.py</code> and <code>_version.py</code>.</li> <li>Add a git tag.</li> <li>Push the git tag.</li> <li>Then a GH Action will upload a new release on the GH repo associated with the git tag and push the package to PyPi.</li> </ul> </li> </ul>"},{"location":"license.html","title":"License","text":"<pre><code>Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2021 - 2023 datamol.io\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n</code></pre>"},{"location":"usage.html","title":"Usage","text":"<p>Datamol has been designed to be used with a single import:</p> <pre><code>import datamol as dm\n</code></pre> <p>All <code>datamol</code> functions are available under <code>dm</code>.</p>"},{"location":"usage.html#available-modules","title":"Available modules","text":"<ul> <li><code>dm</code>: top-level module that contains common functions.</li> <li><code>dm.actions</code>: functions to edit molecules.</li> <li><code>dm.conformers</code>: generate and perform computation on conformers.</li> <li><code>dm.data</code>: get some common data (mainly for dev purposes).</li> <li><code>dm.fragment</code>: fragment molecules in a list of fragments.</li> <li><code>dm.reactions</code>: functions to work with reactions.</li> <li><code>dm.scaffold</code>: get representative scaffolds from a list of molecules.</li> <li><code>dm.viz</code>: 2D/3D visualization functions.</li> </ul>"},{"location":"api/datamol.align.html","title":"<code>datamol.align</code>","text":""},{"location":"api/datamol.align.html#datamol.align.auto_align_many","title":"<code>auto_align_many(mols, partition_method='anon-scaffold', copy=True, cluster_cutoff=0.7, allow_r_groups=True, **kwargs)</code>","text":"<p>Partition a list of molecules into clusters sharing common scaffold of common core, then align the molecules to that common core. This function will compute the list of smiles/smarts representative of each cluster first.</p> <p>The returned molecules will have two properties associated to them:</p> <ul> <li><code>dm.auto_align_many.cluster_id</code>: the cluster id of the molecule.</li> <li><code>dm.auto_align_many.core</code>: the smiles/smarts of the core of the cluster.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Union[Sequence[Mol], pd.Series]</code> <p>A list of molecules to auto align.</p> required <code>partition_method</code> <code>str</code> <p>Partition method to use:</p> <ul> <li>'scaffold': Cluster molecules by Murcko scaffold.</li> <li>'strip-scaffold': Cluster molecules by Murcko scaffold, but remove all atoms not     in the core.</li> <li>'anon-scaffold': Cluster molecules by Murcko scaffold, but making it     generic including the bonds.</li> <li>'anongraph-scaffold': Cluster molecules by Murcko scaffold, but making it     generic but keeping the bond order informations.</li> <li>'cluster': Cluster the molecules using Butina frm RDKit with <code>dm.cluster_mols</code>. Cautious as the method 'cluster' is very sensitive to the cutoff.</li> </ul> <code>'anon-scaffold'</code> <code>copy</code> <code>bool</code> <p>Whether to copy the molecules before aligning them.</p> <code>True</code> <code>cluster_cutoff</code> <code>float</code> <p>Optional cluster cutoff.</p> <code>0.7</code> <code>allow_r_groups</code> <code>bool</code> <p>Optional, if True, terminal dummy atoms in the             reference are ignored if they match an implicit hydrogen in the             molecule, and a constrained depiction is still attempted</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to clustering method</p> <code>{}</code> Source code in <code>datamol/align.py</code> <pre><code>def auto_align_many(\n    mols: Union[Sequence[Mol], pd.Series],\n    partition_method: str = \"anon-scaffold\",\n    copy: bool = True,\n    cluster_cutoff: float = 0.7,\n    allow_r_groups: bool = True,\n    **kwargs: Any,\n):\n\"\"\"Partition a list of molecules into clusters sharing common scaffold of common core,\n    then align the molecules to that common core. This function will compute the list of\n    smiles/smarts representative of each cluster first.\n\n    The returned molecules will have two properties associated to them:\n\n    - `dm.auto_align_many.cluster_id`: the cluster id of the molecule.\n    - `dm.auto_align_many.core`: the smiles/smarts of the core of the cluster.\n\n    Args:\n        mols: A list of molecules to auto align.\n        partition_method: Partition method to use:\n\n            - 'scaffold': Cluster molecules by Murcko scaffold.\n            - 'strip-scaffold': Cluster molecules by Murcko scaffold, but remove all atoms not\n                in the core.\n            - 'anon-scaffold': Cluster molecules by Murcko scaffold, but making it\n                generic including the bonds.\n            - 'anongraph-scaffold': Cluster molecules by Murcko scaffold, but making it\n                generic but keeping the bond order informations.\n            - 'cluster': Cluster the molecules using Butina frm RDKit with `dm.cluster_mols`.\n            Cautious as the method 'cluster' is very sensitive to the cutoff.\n\n        copy: Whether to copy the molecules before aligning them.\n        cluster_cutoff: Optional cluster cutoff.\n        allow_r_groups: Optional, if True, terminal dummy atoms in the\n                        reference are ignored if they match an implicit hydrogen in the\n                        molecule, and a constrained depiction is still attempted\n        **kwargs: Additional arguments to pass to clustering method\n    \"\"\"\n\n    if copy:\n        mols = [dm.copy_mol(mol) for mol in mols]\n\n    mol_groups = ddict(list)  # map scaffold index to list of unique molecules\n    scaffold_mols = {}\n\n    if partition_method.endswith(\"scaffold\"):\n        scaffolds = [dm.to_scaffold_murcko(m) for m in mols]\n        scaffolds_ids = [dm.to_smiles(x) for x in scaffolds]\n\n        if partition_method.startswith(\"strip-\"):\n            scaffolds = [dm.strip_mol_to_core(x) for x in scaffolds]\n            scaffolds_ids = [dm.to_smiles(x) for x in scaffolds]\n\n        elif partition_method.startswith(\"anongraph-\"):\n            scaffolds = [dm.make_scaffold_generic(s, include_bonds=True) for s in scaffolds]\n            scaffolds_ids = [dm.to_smiles(x) for x in scaffolds]\n\n        elif partition_method.startswith(\"anon-\"):\n            scaffolds = [dm.make_scaffold_generic(s, include_bonds=False) for s in scaffolds]\n            scaffolds_ids = [dm.to_smiles(x) for x in scaffolds]\n\n        for i, s in enumerate(scaffolds_ids):\n            mol_groups[s].append(i)\n            scaffolds[i] = compute_2d_coords(scaffolds[i])\n            scaffold_mols[s] = scaffolds[i]\n\n    elif partition_method == \"cluster\":\n        # partition is cluster, first compute molecule clusters\n        clusters, mol_clusters = dm.cluster_mols(mols, cutoff=cluster_cutoff, **kwargs)\n\n        # now compute the mcs for each clusters\n        cluster_mcs = [\n            (dm.find_mcs(mol_cluster) if len(mol_cluster) &gt; 1 else dm.to_smiles(mol_cluster[0]))\n            for mol_cluster in mol_clusters\n        ]\n        scaffolds_ids = [cluster_mcs[cluster_id] for cluster_id, _ in enumerate(clusters)]\n\n        for i, s in enumerate(scaffolds_ids):\n            mol_groups[s].extend(clusters[i])\n\n        for x in scaffolds_ids:\n            core = None\n            if x is not None:\n                core = dm.from_smarts(x)\n                core = compute_2d_coords(core)\n            scaffold_mols[x] = core\n\n    else:\n        raise ValueError(f\"Unknown partition method: {partition_method}\")\n\n    # now we match each molecule to the scaffold and align them\n    # note that the molecule object will be modified in place in the list\n    for cluster_id, (core, mols_ids) in enumerate(mol_groups.items()):\n        core_mol = scaffold_mols[core]\n\n        for mol_id in mols_ids:\n            mol = mols[mol_id]\n\n            if core_mol is not None:\n                # Only pass allowRGroups if current\n                # rdkit version is &gt;= 2021_03_1\n                # ref https://github.com/rdkit/rdkit/pull/3811\n                allowRGroups = (\n                    {\"allowRGroups\": allow_r_groups}\n                    if version.parse(rdkit.__version__) &gt;= version.parse(\"2021.03.1\")\n                    else {}\n                )\n                rdDepictor.GenerateDepictionMatching2DStructure(\n                    mol,\n                    reference=core_mol,\n                    acceptFailure=True,\n                    **allowRGroups,\n                )\n\n            # Add some props to the mol so the user can retrieve the groups from\n            # it later.\n            props = {}\n            props[\"dm.auto_align_many.cluster_id\"] = cluster_id\n            props[\"dm.auto_align_many.core\"] = core\n            dm.set_mol_props(mol, props)\n\n    # EN: you can discard the mol_groups (or keep it and match the values\n    # to molecular line notation, so you will not have to reocompute the above)\n    # and convert the mols into cxsmiles if you want\n    # return mols, mol_groups\n\n    return mols\n</code></pre>"},{"location":"api/datamol.align.html#datamol.align.compute_2d_coords","title":"<code>compute_2d_coords(mol, copy=True, verbose=False)</code>","text":"<p>Compute 2D coordinates for a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the molecule.</p> <code>True</code> Source code in <code>datamol/align.py</code> <pre><code>def compute_2d_coords(mol: Mol, copy: bool = True, verbose: bool = False) -&gt; Mol:\n\"\"\"Compute 2D coordinates for a molecule.\n\n    Args:\n        mol: A molecule.\n        copy: Whether to copy the molecule.\n    \"\"\"\n    if copy:\n        mol = dm.copy_mol(mol)\n\n    with dm.without_rdkit_log(enable=not verbose):\n        rdDepictor.Compute2DCoords(mol)\n\n    return mol\n</code></pre>"},{"location":"api/datamol.align.html#datamol.align.template_align","title":"<code>template_align(mol, template=None, copy=True, use_depiction=True, remove_confs=True, auto_select_coord_gen=False)</code>","text":"<p>Align an input molecule to a template. If the template is not provided then the input molecule is returned.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[str, Mol]</code> <p>A molecule.</p> required <code>template</code> <code>Optional[Union[str, Mol]]</code> <p>Template to align to.</p> <code>None</code> <code>copy</code> <code>bool</code> <p>whether to copy the molecule before aligning it.</p> <code>True</code> <code>use_depiction</code> <code>bool</code> <p>Whether to use the depiction API or use MolAlign The main difference is around how 3D information is handled, but also, because the depiction API will emphasize the atoms that do not match, whereas AlignMol will not.</p> <code>True</code> <code>remove_confs</code> <code>bool</code> <p>Whether to remove all conformation in the input molecule first. You can set this to true when not using depiction</p> <code>True</code> <code>auto_select_coord_gen</code> <code>bool</code> <p>Whether to automatically select the coordinate generation method.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>mol</code> <code>Optional[Mol]</code> <p>aligned molecule (dm.Mol). None if initial mol argument is undefined or invalid.</p> Source code in <code>datamol/align.py</code> <pre><code>def template_align(\n    mol: Union[str, Mol],\n    template: Optional[Union[str, Mol]] = None,\n    copy: bool = True,\n    use_depiction: bool = True,\n    remove_confs: bool = True,\n    auto_select_coord_gen: bool = False,\n) -&gt; Optional[Mol]:\n\"\"\"Align an input molecule to a template. If the template is not provided then the input molecule is\n    returned.\n\n    Args:\n        mol: A molecule.\n        template: Template to align to.\n        copy: whether to copy the molecule before aligning it.\n        use_depiction: Whether to use the depiction API or use MolAlign\n            The main difference is around how 3D information is handled, but also, because the depiction API\n            will emphasize the atoms that do not match, whereas AlignMol will not.\n        remove_confs: Whether to remove all conformation in the input molecule first.\n            You can set this to true when not using depiction\n        auto_select_coord_gen: Whether to automatically select the coordinate generation method.\n\n    Returns:\n        mol: aligned molecule (dm.Mol). None if initial mol argument is undefined or invalid.\n    \"\"\"\n\n    if isinstance(mol, str):\n        _mol = dm.to_mol(mol)\n    elif copy:\n        _mol = dm.copy_mol(mol)\n    else:\n        _mol = mol\n\n    if _mol is None:\n        return None\n\n    if isinstance(template, str):\n        _template = dm.to_mol(template)\n    elif copy:\n        _template = dm.copy_mol(template)\n    else:\n        _template = template\n\n    if _template is None:\n        return _mol\n\n    if remove_confs:\n        _mol.RemoveAllConformers()\n\n    # EN: to make this more general and robust, we need to first check whether the template\n    # has 2D coordinates or not. If it does not, we need to compute them.\n    # This is a very rare edge case if requests are comming from the UI, but better to check than not xD\n    if _template.GetNumConformers() == 0:\n        _template = compute_2d_coords(_template)\n\n    # EN: now we can align the molecule to the template\n    # but first, we should avoid MCS as much as possible, because it's expensive\n    # so if the template is a subgraph of the molecule, no need to perform any MCS\n    # Another reason for this, is to avoid inconsistency in alignment between molecules that are\n    # supergraph of the template vs molecules that are subgraph of the template.\n    pattern = _template\n    if not _mol.HasSubstructMatch(_template):\n        pattern = None\n        mcs_smarts = dm.find_mcs([_mol, _template])\n\n        if mcs_smarts is not None:\n            pattern = dm.from_smarts(mcs_smarts)\n\n    if pattern is not None:\n        if auto_select_coord_gen:\n            rdDepictor.SetPreferCoordGen(use_depiction)\n\n        # we would need to compute 2d coordinates for the molecules if it doesn't have any\n        if _mol.GetNumConformers() == 0:\n            _mol = compute_2d_coords(_mol)\n\n        if use_depiction:\n            rdDepictor.GenerateDepictionMatching2DStructure(\n                _mol,\n                reference=_template,\n                refPatt=pattern,\n                acceptFailure=True,\n                allowRGroups=True,\n            )\n        else:\n            query_match = _mol.GetSubstructMatch(pattern)\n            template_match = _template.GetSubstructMatch(pattern)\n            rdMolAlign.AlignMol(_mol, _template, atomMap=list(zip(query_match, template_match)))\n\n    return _mol\n</code></pre>"},{"location":"api/datamol.cluster.html","title":"<code>datamol.cluster</code>","text":""},{"location":"api/datamol.cluster.html#datamol.cluster.assign_to_centroids","title":"<code>assign_to_centroids(mols, centroids, feature_fn=None, dist_fn=None, n_jobs=1)</code>","text":"<p>Assign molecules to centroids. Each molecule will be assigned to the closest centroid.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>List[Mol]</code> <p>a list of molecules to assign to centroids</p> required <code>centroids</code> <code>List[Mol]</code> <p>list of molecules to use as centroid</p> required <code>feature_fn</code> <code>Optional[Callable]</code> <p>A feature function that takes a Mol object and return molecular features. By default, the <code>dm.to_fp()</code> is used. Default to None.</p> <code>None</code> <code>dist_fn</code> <code>Optional[Callable]</code> <p>A function that takes two indexes (i,j) and return the distance between them. You might use partial to set the fingerprints as input. By default, the Tanimoto similarity will be used. Default to None.</p> <code>None</code> <code>n_jobs</code> <code>Optional[int]</code> <p>Number of jobs for parallelization. Let to 1 for no parallelization. Set to -1 to use all available cores.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>clusters_map</code> <code>dict</code> <p>dict of index mapping each centroid index to the molecule index in the cluster</p> <code>clusters_list</code> <code>list</code> <p>list of all molecules in each cluster. The cluster index follows the index of the centroid. Note that the centroid molecule is not added to the cluster.</p> Source code in <code>datamol/cluster.py</code> <pre><code>def assign_to_centroids(\n    mols: List[Mol],\n    centroids: List[Mol],\n    feature_fn: Optional[Callable] = None,\n    dist_fn: Optional[Callable] = None,\n    n_jobs: Optional[int] = 1,\n) -&gt; Tuple[dict, list]:\nr\"\"\"Assign molecules to centroids. Each molecule will be assigned to the closest centroid.\n\n    Args:\n        mols: a list of molecules to assign to centroids\n        centroids: list of molecules to use as centroid\n        feature_fn: A feature function that takes a Mol object\n            and return molecular features. By default, the `dm.to_fp()` is used.\n            Default to None.\n        dist_fn: A function that takes two indexes (i,j) and return the\n            distance between them. You might use partial to set the fingerprints as input.\n            By default, the Tanimoto similarity will be used. Default to None.\n        n_jobs: Number of jobs for parallelization. Let to 1 for no\n            parallelization. Set to -1 to use all available cores.\n\n    Returns:\n        clusters_map: dict of index mapping each centroid index to the molecule index in the cluster\n        clusters_list: list of all molecules in each cluster. The cluster index follows the index of the centroid.\n            Note that the centroid molecule is not added to the cluster.\n    \"\"\"\n\n    if feature_fn is None:\n        feature_fn = functools.partial(dm.to_fp, as_array=False)\n\n    all_mols = [x for x in mols] + [c for c in centroids]\n    features = dm.parallelized(feature_fn, all_mols, n_jobs=n_jobs)\n\n    def distij(i, j, features=features):\n        return 1.0 - DataStructs.cDataStructs.TanimotoSimilarity(features[int(i)], features[int(j)])\n\n    if dist_fn is None:\n        dist_fn = distij\n\n    clusters_map = ddict(list)\n    clusters_list = [[] for _ in centroids]\n    query_inds = np.expand_dims(np.arange(len(mols), dtype=int), axis=1)\n    centroid_inds = np.expand_dims(np.arange(len(centroids), dtype=int), axis=1) + len(mols)\n    dist_mat = distance.cdist(query_inds, centroid_inds, metric=distij)\n    closest = np.argmin(dist_mat, axis=1)\n    for ind, cluster_ind in enumerate(closest):  # type: ignore\n        clusters_map[cluster_ind].append(ind)\n        clusters_list[cluster_ind].append(mols[ind])\n    return clusters_map, clusters_list\n</code></pre>"},{"location":"api/datamol.cluster.html#datamol.cluster.cluster_mols","title":"<code>cluster_mols(mols, cutoff=0.2, feature_fn=None, n_jobs=1)</code>","text":"<p>Cluster a set of molecules using the butina clustering algorithm and a given threshold.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Union[Sequence[Mol], pd.Series]</code> <p>a list of molecules.</p> required <code>cutoff</code> <code>float</code> <p>Cuttoff for the clustering. Default to 0.2.</p> <code>0.2</code> <code>feature_fn</code> <code>Optional[Callable]</code> <p>A feature function that takes a Mol object and return molecular features. By default, the <code>dm.to_fp()</code> is used. Default to None.</p> <code>None</code> <code>n_jobs</code> <code>Optional[int]</code> <p>Number of jobs for parallelization. Let to 1 for no parallelization. Set to -1 to use all available cores.</p> <code>1</code> Source code in <code>datamol/cluster.py</code> <pre><code>def cluster_mols(\n    mols: Union[Sequence[Mol], pd.Series],\n    cutoff: float = 0.2,\n    feature_fn: Optional[Callable] = None,\n    n_jobs: Optional[int] = 1,\n):\n\"\"\"Cluster a set of molecules using the butina clustering algorithm and a given threshold.\n\n    Args:\n        mols: a list of molecules.\n        cutoff: Cuttoff for the clustering. Default to 0.2.\n        feature_fn: A feature function that takes a Mol object\n            and return molecular features. By default, the `dm.to_fp()` is used.\n            Default to None.\n        n_jobs: Number of jobs for parallelization. Let to 1 for no\n            parallelization. Set to -1 to use all available cores.\n    \"\"\"\n\n    if feature_fn is None:\n        feature_fn = functools.partial(dm.to_fp, as_array=False)\n\n    features = dm.parallelized(feature_fn, mols, n_jobs=n_jobs)\n\n    dists = []\n    n_mols = len(mols)\n\n    for i in range(1, n_mols):\n        dist = DataStructs.cDataStructs.BulkTanimotoSimilarity(\n            features[i], features[:i], returnDistance=True\n        )\n        dists.extend([x for x in dist])\n\n    # now cluster the data\n    cluster_indices = Butina.ClusterData(dists, n_mols, cutoff, isDistData=True)\n    cluster_mols = [operator.itemgetter(*cluster)(mols) for cluster in cluster_indices]\n\n    # Make single mol cluster a list\n    cluster_mols = [[c] if isinstance(c, Mol) else c for c in cluster_mols]\n\n    return cluster_indices, cluster_mols\n</code></pre>"},{"location":"api/datamol.cluster.html#datamol.cluster.pick_centroids","title":"<code>pick_centroids(mols, npick=0, initial_picks=None, threshold=0.5, feature_fn=None, dist_fn=None, seed=42, method='sphere', n_jobs=1)</code>","text":"<p>Pick a set of <code>npick</code> centroids from a list of molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>List[Mol]</code> <p>a list of molecules.</p> required <code>npick</code> <code>int</code> <p>Number of element to pick from mols, including the preselection.</p> <code>0</code> <code>threshold</code> <code>float</code> <p>Minimum distance between centroids for <code>maxmin</code> and sphere exclusion (<code>sphere</code>) methods.</p> <code>0.5</code> <code>initial_picks</code> <code>Optional[List[int]]</code> <p>Starting list of index for molecules that should be in the set of picked molecules. Default to None.</p> <code>None</code> <code>feature_fn</code> <code>callable</code> <p>A feature function that takes a Mol object and return molecular features. By default, the <code>dm.to_fp()</code> is used. Default to None.</p> <code>None</code> <code>dist_fn</code> <code>Optional[Callable]</code> <p>A function that takes two indexes (i,j) and return the distance between them. You might use partial to set the fingerprints as input. By default, the Tanimoto similarity will be used. Default to None.</p> <code>None</code> <code>seed</code> <code>int</code> <p>seed for reproducibility</p> <code>42</code> <code>method</code> <code>str</code> <p>Picking method to use. One of  <code>sphere</code>, <code>maxmin</code> or any supported rdkit hierarchical clustering method such as <code>centroid</code>, <code>clink</code>, <code>upgma</code></p> <code>'sphere'</code> <code>n_jobs</code> <code>Optional[int]</code> <p>Number of jobs for parallelization. Let to 1 for no parallelization. Set to -1 to use all available cores.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>picked_inds</code> <code>int</code> <p>index of the molecule that have been selected as centroids</p> <code>mols</code> <code>list</code> <p>molecules that have been picked</p> Source code in <code>datamol/cluster.py</code> <pre><code>def pick_centroids(\n    mols: List[Mol],\n    npick: int = 0,\n    initial_picks: Optional[List[int]] = None,\n    threshold: float = 0.5,\n    feature_fn: Optional[Callable] = None,\n    dist_fn: Optional[Callable] = None,\n    seed: int = 42,\n    method: str = \"sphere\",\n    n_jobs: Optional[int] = 1,\n) -&gt; Tuple[int, list]:\nr\"\"\"Pick a set of `npick` centroids from a list of molecules.\n\n    Args:\n        mols: a list of molecules.\n        npick: Number of element to pick from mols, including the preselection.\n        threshold: Minimum distance between centroids for `maxmin` and sphere exclusion (`sphere`) methods.\n        initial_picks: Starting list of index for molecules that should be in the\n            set of picked molecules. Default to None.\n        feature_fn (callable, optional): A feature function that takes a Mol object\n            and return molecular features. By default, the `dm.to_fp()` is used.\n            Default to None.\n        dist_fn: A function that takes two indexes (i,j) and return the\n            distance between them. You might use partial to set the fingerprints as input.\n            By default, the Tanimoto similarity will be used. Default to None.\n        seed: seed for reproducibility\n        method: Picking method to use. One of  `sphere`, `maxmin` or any\n            supported rdkit hierarchical clustering method such as `centroid`, `clink`, `upgma`\n        n_jobs: Number of jobs for parallelization. Let to 1 for no\n            parallelization. Set to -1 to use all available cores.\n\n    Returns:\n        picked_inds: index of the molecule that have been selected as centroids\n        mols: molecules that have been picked\n    \"\"\"\n\n    n_mols = len(mols)\n    if feature_fn is None:\n        feature_fn = functools.partial(dm.to_fp, as_array=False)\n\n    features = dm.parallelized(feature_fn, mols, n_jobs=n_jobs)\n\n    def distij(i, j, features=features):\n        return 1.0 - DataStructs.cDataStructs.TanimotoSimilarity(features[i], features[j])\n\n    if dist_fn is None:\n        dist_fn = distij\n\n    initial_picks = [] if initial_picks is None else initial_picks\n\n    if method == \"maxmin\":\n        picker = MaxMinPicker()\n        picked_inds, _ = picker.LazyPickWithThreshold(\n            dist_fn,\n            n_mols,\n            pickSize=npick,\n            threshold=threshold,\n            firstPicks=initial_picks,\n            seed=seed,\n        )\n\n    elif method == \"sphere\":\n        picker = LeaderPicker()\n        picked_inds = picker.LazyPick(\n            dist_fn, n_mols, threshold=threshold, pickSize=npick, firstPicks=initial_picks\n        )\n\n    elif method.upper() in ClusterMethod.names.keys() and npick:\n        if initial_picks:\n            logger.warning(\n                \"Initial picks is not supported by hierarchical clustering. You pick has been discarded.\"\n            )\n\n        dist_mat = dm.parallelized(\n            distij, list(zip(*np.tril_indices(len(mols), k=-1))), arg_type=\"args\"\n        )\n        dist_mat = np.asarray(dist_mat)\n        picker = HierarchicalClusterPicker(ClusterMethod.names[method.upper()])\n        picked_inds = picker.Pick(dist_mat, n_mols, npick)\n    else:\n        raise ValueError(f\"Picking method {method} with {npick} elements to pick is not supported.\")\n    picked_inds = np.array(picked_inds)\n    picked_mols = [mols[x] for x in picked_inds]\n\n    return picked_inds, picked_mols\n</code></pre>"},{"location":"api/datamol.cluster.html#datamol.cluster.pick_diverse","title":"<code>pick_diverse(mols, npick, initial_picks=None, feature_fn=None, dist_fn=None, seed=42, n_jobs=1)</code>","text":"<p>Pick a set of diverse molecules based on they fingerprint.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>List[Mol]</code> <p>a list of molecules.</p> required <code>npick</code> <code>int</code> <p>Number of element to pick from mols, including the preselection.</p> required <code>initial_picks</code> <code>Optional[List[int]]</code> <p>Starting list of index for molecules that should be in the set of picked molecules. Default to None.</p> <code>None</code> <code>feature_fn</code> <code>Optional[Callable]</code> <p>A feature function that takes a Mol object and return molecular features. By default, the <code>dm.to_fp()</code> is used. Default to None.</p> <code>None</code> <code>dist_fn</code> <code>Optional[Callable]</code> <p>A function that takes two indexes (i,j) and return the distance between them. You might use partial to set the fingerprints as input. By default, the Tanimoto similarity will be used. Default to None.</p> <code>None</code> <code>seed</code> <code>int</code> <p>seed for reproducibility</p> <code>42</code> <code>n_jobs</code> <code>Optional[int]</code> <p>Number of jobs for parallelization. Let to 1 for no parallelization. Set to -1 to use all available cores.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>picked_inds</code> <code>int</code> <p>index of the molecule that have been picked</p> <code>mols</code> <code>list</code> <p>molecules that have been picked</p> Source code in <code>datamol/cluster.py</code> <pre><code>def pick_diverse(\n    mols: List[Mol],\n    npick: int,\n    initial_picks: Optional[List[int]] = None,\n    feature_fn: Optional[Callable] = None,\n    dist_fn: Optional[Callable] = None,\n    seed: int = 42,\n    n_jobs: Optional[int] = 1,\n) -&gt; Tuple[int, list]:\nr\"\"\"Pick a set of diverse molecules based on they fingerprint.\n\n    Args:\n        mols: a list of molecules.\n        npick: Number of element to pick from mols, including the preselection.\n        initial_picks: Starting list of index for molecules that should be in the\n            set of picked molecules. Default to None.\n        feature_fn: A feature function that takes a Mol object\n            and return molecular features. By default, the `dm.to_fp()` is used.\n            Default to None.\n        dist_fn: A function that takes two indexes (i,j) and return the\n            distance between them. You might use partial to set the fingerprints as input.\n            By default, the Tanimoto similarity will be used. Default to None.\n        seed: seed for reproducibility\n        n_jobs: Number of jobs for parallelization. Let to 1 for no\n            parallelization. Set to -1 to use all available cores.\n\n    Returns:\n        picked_inds: index of the molecule that have been picked\n        mols: molecules that have been picked\n    \"\"\"\n\n    if feature_fn is None:\n        feature_fn = functools.partial(dm.to_fp, as_array=False)\n\n    features = dm.parallelized(feature_fn, mols, n_jobs=n_jobs)\n\n    def distij(i, j, features=features):\n        return 1.0 - DataStructs.cDataStructs.TanimotoSimilarity(features[i], features[j])\n\n    if dist_fn is None:\n        dist_fn = distij\n\n    picker = MaxMinPicker()\n    initial_picks = [] if initial_picks is None else initial_picks\n    picked_inds = picker.LazyPick(dist_fn, len(mols), npick, firstPicks=initial_picks, seed=seed)\n    picked_inds = np.array(picked_inds)\n    picked_mols = [mols[x] for x in picked_inds]\n\n    return picked_inds, picked_mols\n</code></pre>"},{"location":"api/datamol.conformers.html","title":"<code>datamol.conformers</code>","text":""},{"location":"api/datamol.conformers.html#datamol.conformers._conformers.align_conformers","title":"<code>align_conformers(mols, ref_id=0, copy=True, conformer_id=-1, backend='crippenO3A')</code>","text":"<p>Align a list of molecules to a reference molecule.</p> <p>Note that using the <code>O3A</code> backend, hydrogens will be added at the beginning of the procedure and removed at the end of the procedure.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>List[Mol]</code> <p>List of molecules to align. All the molecules must have a conformer.</p> required <code>ref_id</code> <code>int</code> <p>Index of the reference molecule. By default, the first molecule in the list will be used as reference.</p> <code>0</code> <code>copy</code> <code>bool</code> <p>Whether to copy the molecules before performing the alignement.</p> <code>True</code> <code>conformer_id</code> <code>int</code> <p>Conformer id to use.</p> <code>-1</code> <code>backend</code> <code>str</code> <p>Backend to use to compute the alignment from <code>crippenO3A</code>, <code>O3A</code>.</p> <code>'crippenO3A'</code> <p>Returns:</p> Name Type Description <code>mols</code> <code>list</code> <p>The aligned molecules.</p> <code>scores</code> <code>list</code> <p>The score of the alignement.</p> Source code in <code>datamol/conformers/_conformers.py</code> <pre><code>def align_conformers(\n    mols: List[Mol],\n    ref_id: int = 0,\n    copy: bool = True,\n    conformer_id: int = -1,\n    backend: str = \"crippenO3A\",\n) -&gt; Tuple[list, list]:\n\"\"\"Align a list of molecules to a reference molecule.\n\n    Note that using the `O3A` backend, hydrogens will be added at the beginning of the procedure\n    and removed at the end of the procedure.\n\n    Args:\n        mols: List of molecules to align. All the molecules must have a conformer.\n        ref_id: Index of the reference molecule. By default, the first molecule in the list\n            will be used as reference.\n        copy: Whether to copy the molecules before performing the alignement.\n        conformer_id: Conformer id to use.\n        backend: Backend to use to compute the alignment from `crippenO3A`, `O3A`.\n\n    Returns:\n        mols: The aligned molecules.\n        scores: The score of the alignement.\n    \"\"\"\n\n    allowed_backends = [\"crippenO3A\", \"O3A\"]\n    if backend not in allowed_backends:\n        raise ValueError(\n            f\"The backend '{backend}' is not supported. Choose from: {allowed_backends}\"\n        )\n\n    # Check all input molecules has a conformer\n    if not all([mol.GetNumConformers() &gt;= 1 for mol in mols]):\n        raise ValueError(\"One or more input molecules is missing a conformer.\")\n\n    # Make a copy of the molecules since they are going to be modified\n    if copy:\n        mols = [dm_mol.copy_mol(mol) for mol in mols]\n\n    # Split ref and probe mols\n    mol_ref = mols[ref_id]\n    mol_probes = mols\n\n    if backend == \"crippenO3A\":\n        # Compute Crippen contributions for every atoms and molecules\n        crippen_contribs = [rdMolDescriptors._CalcCrippenContribs(mol) for mol in mol_probes]\n        crippen_contrib_ref = crippen_contribs[ref_id]\n        crippen_contrib_probes = crippen_contribs\n\n        # Loop and align\n        # NOTE(hadim): we could eventually parallelize this if that's needed.\n\n        scores = []\n        for i, mol in enumerate(mol_probes):\n            crippenO3A = rdMolAlign.GetCrippenO3A(\n                prbMol=mol,\n                refMol=mol_ref,\n                prbCrippenContribs=crippen_contrib_probes[i],\n                refCrippenContribs=crippen_contrib_ref,\n                prbCid=conformer_id,\n                refCid=conformer_id,\n                maxIters=50,\n            )\n            crippenO3A.Align()\n\n            scores.append(crippenO3A.Score())\n\n    elif backend == \"O3A\":\n        # Add hydrogens first\n        mol_probes = [dm_mol.add_hs(mol, add_coords=True) for mol in mol_probes]\n        mol_ref = dm_mol.add_hs(mol_ref, add_coords=True)\n\n        # Compute MMFF params for every molecules\n        mmff_params = [rdForceFieldHelpers.MMFFGetMoleculeProperties(mol) for mol in mol_probes]\n\n        # Split reference and probe molecules\n        mmff_params_ref = mmff_params[ref_id]\n        mmff_params_probes = mmff_params\n\n        # Loop and align\n        # NOTE(hadim): we could eventually parallelize this if that's needed.\n\n        scores = []\n        for i, mol in enumerate(mol_probes):\n            pyO3A = rdMolAlign.GetO3A(\n                prbMol=mol,\n                refMol=mol_ref,\n                prbPyMMFFMolProperties=mmff_params_probes[i],\n                refPyMMFFMolProperties=mmff_params_ref,\n                prbCid=conformer_id,\n                refCid=conformer_id,\n                maxIters=50,\n            )\n            pyO3A.Align()\n\n            scores.append(pyO3A.Score())\n\n        # Remove the hydrogens\n        mol_probes = [dm_mol.remove_hs(mol) for mol in mol_probes]\n\n    else:\n        raise ValueError(f\"Backend {backend} not supported.\")\n\n    scores = np.array(scores)\n\n    return mol_probes, scores\n</code></pre>"},{"location":"api/datamol.conformers.html#datamol.conformers._conformers.cluster","title":"<code>cluster(mol, rms_cutoff=1, already_aligned=False, centroids=True)</code>","text":"<p>Cluster the conformers of a molecule according to an RMS threshold in Angstrom.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule</p> required <code>rms_cutoff</code> <code>float</code> <p>The RMS cutoff in Angstrom.</p> <code>1</code> <code>already_aligned</code> <code>bool</code> <p>Whether or not the conformers are aligned. If False, they will be aligmned furing the RMS computation.</p> <code>False</code> <code>centroids</code> <code>bool</code> <p>If True, return one molecule with centroid conformers only. If False return a list of molecules per cluster with all the conformers of the cluster. Defaults to True.</p> <code>True</code> Source code in <code>datamol/conformers/_conformers.py</code> <pre><code>def cluster(\n    mol: Mol,\n    rms_cutoff: float = 1,\n    already_aligned: bool = False,\n    centroids: bool = True,\n):\n\"\"\"Cluster the conformers of a molecule according to an RMS threshold in Angstrom.\n\n    Args:\n        mol: a molecule\n        rms_cutoff: The RMS cutoff in Angstrom.\n        already_aligned: Whether or not the conformers are aligned. If False,\n            they will be aligmned furing the RMS computation.\n        centroids: If True, return one molecule with centroid conformers\n            only. If False return a list of molecules per cluster with all\n            the conformers of the cluster. Defaults to True.\n    \"\"\"\n\n    # Clone molecule\n    mol = copy.deepcopy(mol)\n\n    # Compute RMS\n    dmat = AllChem.GetConformerRMSMatrix(mol, prealigned=already_aligned)\n\n    # Cluster\n    conf_clusters = Butina.ClusterData(\n        dmat,\n        nPts=mol.GetNumConformers(),\n        distThresh=rms_cutoff,\n        isDistData=True,\n        reordering=False,\n    )\n\n    return return_centroids(mol, conf_clusters, centroids=centroids)\n</code></pre>"},{"location":"api/datamol.conformers.html#datamol.conformers._conformers.generate","title":"<code>generate(mol, n_confs=None, use_random_coords=True, enforce_chirality=True, num_threads=1, rms_cutoff=None, clear_existing=True, align_conformers=True, minimize_energy=False, sort_by_energy=True, method=None, forcefield='UFF', ewindow=np.inf, eratio=np.inf, energy_iterations=200, warning_not_converged=0, random_seed=19, add_hs=True, ignore_failure=False, embed_params=None, verbose=False)</code>","text":"<p>Compute conformers of a molecule.</p> <p>Example:</p> <pre><code>import datamol as dm\nsmiles = \"O=C(C)Oc1ccccc1C(=O)O\"\nmol = dm.to_mol(smiles)\nmol = dm.conformers.generate(mol)\n\n# Get all conformers as a list\nconformers = mol.GetConformers()\n\n# Get the 3D atom positions of the first conformer\npositions = mol.GetConformer(0).GetPositions()\n\n# If minimization has been enabled (default to True)\n# you can access the computed energy.\nconf = mol.GetConformer(1)\nprops = conf.GetPropsAsDict()\nprint(props)\n# {'rdkit_UFF_energy': 35.64074017773132,'rdkit_UFF_delta_energy': 0.24682258222552633}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule</p> required <code>n_confs</code> <code>Optional[int]</code> <p>Number of conformers to generate. Depends on the number of rotatable bonds by default: 50 for &lt;8, 200 for &lt;12 and 300 for &gt;12.</p> <code>None</code> <code>use_random_coords</code> <code>bool</code> <p>Start the embedding from random coordinates instead of using eigenvalues of the distance matrix.</p> <code>True</code> <code>enforce_chirality</code> <code>bool</code> <p>Enforce correct chirilaty if chiral centers are present.</p> <code>True</code> <code>num_threads</code> <code>int</code> <p>Number of threads to use when embedding multiple conformations.</p> <code>1</code> <code>rms_cutoff</code> <code>Optional[float]</code> <p>The minimum RMS value in Angstrom at which two conformers are considered redundant and one is deleted. If None, all conformers are kept. This step is done after an eventual minimization step.</p> <code>None</code> <code>clear_existing</code> <code>bool</code> <p>Whether to overwrite existing conformers for the molecule.</p> <code>True</code> <code>align_conformers</code> <code>bool</code> <p>Whether to align the conformers.</p> <code>True</code> <code>minimize_energy</code> <code>bool</code> <p>Whether to minimize conformer's energies using MMFF94s. Disable to generate conformers much faster.</p> <code>False</code> <code>sort_by_energy</code> <code>bool</code> <p>Sort conformers by energy when minimizing is turned to False.</p> <code>True</code> <code>method</code> <code>Optional[str]</code> <p>RDKit method to use for embedding. Choose among [\"ETDG\", \"ETKDG\", \"ETKDGv2\", \"ETKDGv3\"]. If None, \"ETKDGv3\" is used.</p> <code>None</code> <code>forcefield</code> <code>str</code> <p>molecular forcefield to use, one of ['UFF','MMFF94s','MMFF94s_noEstat']</p> <code>'UFF'</code> <code>ewindow</code> <code>float</code> <p>maximum energy above minimum energy conformer to output</p> <code>np.inf</code> <code>eratio</code> <code>float</code> <p>max delta-energy divided by rotatable bonds for conformers</p> <code>np.inf</code> <code>energy_iterations</code> <code>int</code> <p>Maximum number of iterations during the energy minimization procedure. It corresponds to the <code>maxIters</code> argument in RDKit.</p> <code>200</code> <code>warning_not_converged</code> <code>int</code> <p>Wether to log a warning when the number of not converged conformers during the minimization is higher than <code>warning_not_converged</code>. Only works when <code>verbose</code> is set to True. Disable with 0. Defaults to 10.</p> <code>0</code> <code>random_seed</code> <code>int</code> <p>Set to None or -1 to disable.</p> <code>19</code> <code>add_hs</code> <code>bool</code> <p>Whether to add hydrogens to the mol before embedding. If set to True, the hydrogens are removed in the returned molecule. Warning: explicit hydrogens won't be conserved. It is strongly recommended to let the default value to True. The RDKit documentation says: \"To get good 3D conformations, it's almost always a good idea to add hydrogens to the molecule first.\"</p> <code>True</code> <code>ignore_failure</code> <code>bool</code> <p>It set to True, this will avoid raising an error when the embedding fails and return None instead.</p> <code>False</code> <code>embed_params</code> <code>Optional[dict]</code> <p>Allows the user to specify arbitrary embedding parameters for the conformers. This will override any other default settings. See https://www.rdkit.org/docs/source/rdkit.Chem.rdDistGeom.html#rdkit.Chem.rdDistGeom.EmbedParameters for more details.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Wether to enable logs during the process.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>mol</code> <code>Mol</code> <p>the molecule with the conformers.</p> Source code in <code>datamol/conformers/_conformers.py</code> <pre><code>def generate(\n    mol: Mol,\n    n_confs: Optional[int] = None,\n    use_random_coords: bool = True,\n    enforce_chirality: bool = True,\n    num_threads: int = 1,\n    rms_cutoff: Optional[float] = None,\n    clear_existing: bool = True,\n    align_conformers: bool = True,\n    minimize_energy: bool = False,\n    sort_by_energy: bool = True,\n    method: Optional[str] = None,\n    forcefield: str = \"UFF\",\n    ewindow: float = np.inf,\n    eratio: float = np.inf,\n    energy_iterations: int = 200,\n    warning_not_converged: int = 0,\n    random_seed: int = 19,\n    add_hs: bool = True,\n    ignore_failure: bool = False,\n    embed_params: Optional[dict] = None,\n    verbose: bool = False,\n) -&gt; Mol:\n\"\"\"Compute conformers of a molecule.\n\n    Example:\n\n    ```python\n    import datamol as dm\n    smiles = \"O=C(C)Oc1ccccc1C(=O)O\"\n    mol = dm.to_mol(smiles)\n    mol = dm.conformers.generate(mol)\n\n    # Get all conformers as a list\n    conformers = mol.GetConformers()\n\n    # Get the 3D atom positions of the first conformer\n    positions = mol.GetConformer(0).GetPositions()\n\n    # If minimization has been enabled (default to True)\n    # you can access the computed energy.\n    conf = mol.GetConformer(1)\n    props = conf.GetPropsAsDict()\n    print(props)\n    # {'rdkit_UFF_energy': 35.64074017773132,'rdkit_UFF_delta_energy': 0.24682258222552633}\n    ```\n\n    Args:\n        mol: a molecule\n        n_confs: Number of conformers to generate. Depends on the number of rotatable bonds\n            by default: 50 for &lt;8, 200 for &lt;12 and 300 for &gt;12.\n        use_random_coords: Start the embedding from random coordinates instead of using eigenvalues\n            of the distance matrix.\n        enforce_chirality: Enforce correct chirilaty if chiral centers are present.\n        num_threads: Number of threads to use when embedding multiple conformations.\n        rms_cutoff: The minimum RMS value in Angstrom at which two conformers\n            are considered redundant and one is deleted. If None, all conformers\n            are kept. This step is done after an eventual minimization step.\n        clear_existing: Whether to overwrite existing conformers for the molecule.\n        align_conformers: Whether to align the conformers.\n        minimize_energy: Whether to minimize conformer's energies using MMFF94s.\n            Disable to generate conformers much faster.\n        sort_by_energy: Sort conformers by energy when minimizing is turned to False.\n        method: RDKit method to use for embedding. Choose among\n            [\"ETDG\", \"ETKDG\", \"ETKDGv2\", \"ETKDGv3\"]. If None, \"ETKDGv3\" is used.\n        forcefield: molecular forcefield to use, one of ['UFF','MMFF94s','MMFF94s_noEstat']\n        ewindow: maximum energy above minimum energy conformer to output\n        eratio: max delta-energy divided by rotatable bonds for conformers\n        energy_iterations: Maximum number of iterations during the energy minimization procedure.\n            It corresponds to the `maxIters` argument in RDKit.\n        warning_not_converged: Wether to log a warning when the number of not converged conformers\n            during the minimization is higher than `warning_not_converged`. Only works when `verbose` is set to True.\n            Disable with 0. Defaults to 10.\n        random_seed: Set to None or -1 to disable.\n        add_hs: Whether to add hydrogens to the mol before embedding. If set to True, the hydrogens\n            are removed in the returned molecule. Warning: explicit hydrogens won't be conserved. It is strongly\n            recommended to let the default value to True. The RDKit documentation says: \"To get good 3D conformations,\n            it's almost always a good idea to add hydrogens to the molecule first.\"\n        ignore_failure: It set to True, this will avoid raising an error when the embedding fails and return None instead.\n        embed_params: Allows the user to specify arbitrary embedding parameters for the conformers. This will override any\n            other default settings. See https://www.rdkit.org/docs/source/rdkit.Chem.rdDistGeom.html#rdkit.Chem.rdDistGeom.EmbedParameters\n            for more details.\n        verbose: Wether to enable logs during the process.\n\n    Returns:\n        mol: the molecule with the conformers.\n    \"\"\"\n\n    AVAILABLE_METHODS = [\"ETDG\", \"ETKDG\", \"ETKDGv2\", \"ETKDGv3\"]\n\n    if method is None:\n        method = \"ETKDGv3\"\n\n    if method not in AVAILABLE_METHODS:\n        raise ValueError(f\"The method {method} is not supported. Use from {AVAILABLE_METHODS}\")\n\n    # Random seed\n    if random_seed is None:\n        random_seed = -1\n\n    # Clone molecule\n    mol = copy.deepcopy(mol)\n\n    # Remove existing conformers\n    if clear_existing:\n        mol.RemoveAllConformers()\n\n    # Add hydrogens\n    if add_hs:\n        mol = dm_mol.add_hs(mol)\n\n    rotatable_bonds = descriptors.n_rotatable_bonds(mol)\n    if not n_confs:\n        # Set the number of conformers depends on\n        # the number of rotatable bonds.\n        if rotatable_bonds &lt; 8:\n            n_confs = 50\n        elif rotatable_bonds &lt; 12:\n            n_confs = 200\n        else:\n            n_confs = 300\n\n    # Setup the parameters for the embedding\n    params = getattr(rdDistGeom, method)()\n    params.randomSeed = random_seed\n    params.enforceChirality = enforce_chirality\n    params.useRandomCoords = use_random_coords\n    params.numThreads = num_threads\n\n    if embed_params is not None:\n        for k, v in embed_params.items():\n            setattr(params, k, v)\n\n    # Embed conformers\n    confs = rdDistGeom.EmbedMultipleConfs(mol, numConfs=n_confs, params=params)\n\n    if len(confs) == 0:\n        if ignore_failure:\n            if verbose:\n                logger.warning(\n                    f\"Conformers embedding failed for {convert.to_smiles(mol)}. Returning None because ignore_failure is set.\"\n                )\n            return None\n        raise ValueError(f\"Conformers embedding failed for {convert.to_smiles(mol)}\")\n\n    energies = None\n\n    # Minimize energy\n    if minimize_energy:\n        # Minimize conformer's energy using MMFF\n        ff = _get_ff(mol, forcefield)\n        results = rdForceFieldHelpers.OptimizeMoleculeConfs(\n            mol, ff, maxIters=energy_iterations, numThreads=num_threads\n        )\n        energies = [energy for _, energy in results]\n\n        # Some conformers might not have converged during minimization.\n        not_converged = sum([not_converged for not_converged, _ in results if not_converged])\n        if warning_not_converged != 0 and not_converged &gt; warning_not_converged and verbose:\n            logger.warning(\n                f\"{not_converged}/{len(results)} conformers have not converged for {convert.to_smiles(mol)}\"\n            )\n\n    elif sort_by_energy:\n        energies = []\n        for conf in mol.GetConformers():\n            ff = _get_ff(mol, forcefield, conf_id=conf.GetId())\n            energies.append(ff.CalcEnergy())\n        energies = np.array(energies)\n\n    if energies is not None:\n        minE = np.min(energies)\n        # Add the energy as a property to each conformers\n        [\n            (\n                conf.SetDoubleProp(f\"rdkit_{forcefield}_energy\", energy),\n                conf.SetDoubleProp(f\"rdkit_{forcefield}_delta_energy\", energy - minE),\n            )\n            for energy, conf in zip(energies, mol.GetConformers())\n        ]\n\n        # Now we reorder conformers according to their energies,\n        # so the lowest energies conformers are first.  eliminate conformers that exceed ewindow, eratio\n        mol_clone = copy.deepcopy(mol)\n        ordered_conformers = [\n            conf\n            for E, conf in sorted(zip(energies, mol_clone.GetConformers()), key=lambda x: x[0])\n            if E - minE &lt;= ewindow and (E - minE) / rotatable_bonds &lt;= eratio\n        ]\n        mol.RemoveAllConformers()\n        [mol.AddConformer(conf, assignId=True) for conf in ordered_conformers]\n\n    # Align conformers to each others\n    if align_conformers:\n        rdMolAlign.AlignMolConformers(mol)\n\n    if rms_cutoff is not None:\n        mol = cluster(\n            mol,\n            rms_cutoff=rms_cutoff,\n            already_aligned=align_conformers,\n            centroids=True,\n        )  # type: ignore\n\n    if add_hs:\n        mol = dm_mol.remove_hs(mol)\n\n    return mol\n</code></pre>"},{"location":"api/datamol.conformers.html#datamol.conformers._conformers.return_centroids","title":"<code>return_centroids(mol, conf_clusters, centroids=True)</code>","text":"<p>Given a list of cluster indices, return one single molecule with only the centroid of the clusters of a list of molecules per cluster.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule.</p> required <code>conf_clusters</code> <code>Sequence[Sequence[int]]</code> <p>list of cluster indices.</p> required <code>centroids</code> <code>bool</code> <p>If True, return one molecule with centroid conformers only. If False return a list of molecules per cluster with all the conformers of the cluster.</p> <code>True</code> Source code in <code>datamol/conformers/_conformers.py</code> <pre><code>def return_centroids(\n    mol: Mol,\n    conf_clusters: Sequence[Sequence[int]],\n    centroids: bool = True,\n) -&gt; Union[List[Mol], Mol]:\n\"\"\"Given a list of cluster indices, return one single molecule\n    with only the centroid of the clusters of a list of molecules per cluster.\n\n    Args:\n        mol: a molecule.\n        conf_clusters: list of cluster indices.\n        centroids: If True, return one molecule with centroid conformers\n            only. If False return a list of molecules per cluster with all\n            the conformers of the cluster.\n    \"\"\"\n\n    if centroids:\n        # Collect centroid of each cluster (first element of the list)\n        centroid_list = [indices[0] for indices in conf_clusters]\n\n        # Keep only centroid conformers\n        mol_clone = copy.deepcopy(mol)\n        confs = [mol_clone.GetConformers()[i] for i in centroid_list]\n        mol.RemoveAllConformers()\n        [mol.AddConformer(conf, assignId=True) for conf in confs]\n        return mol\n\n    else:\n        # Create a new molecule for each cluster and add conformers to it.\n        mols = []\n        for cluster in conf_clusters:\n            m = copy.deepcopy(mol)\n            m.RemoveAllConformers()\n            [m.AddConformer(mol.GetConformer(c), assignId=True) for c in cluster]\n            mols.append(m)\n        return mols\n</code></pre>"},{"location":"api/datamol.conformers.html#datamol.conformers._conformers.rmsd","title":"<code>rmsd(mol)</code>","text":"<p>Compute the RMSD between all the conformers of a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule</p> required Source code in <code>datamol/conformers/_conformers.py</code> <pre><code>def rmsd(mol: Mol) -&gt; np.ndarray:\n\"\"\"Compute the RMSD between all the conformers of a molecule.\n\n    Args:\n        mol: a molecule\n    \"\"\"\n\n    if mol.GetNumConformers() &lt;= 1:\n        raise ValueError(\n            \"The molecule has 0 or 1 conformer. You can generate conformers with `dm.conformers.generate(mol)`.\"\n        )\n\n    n_confs = mol.GetNumConformers()\n    rmsds = []\n    for i in range(n_confs):\n        for j in range(n_confs):\n            rmsd = rdMolAlign.AlignMol(prbMol=mol, refMol=mol, prbCid=i, refCid=j)\n            rmsds.append(rmsd)\n    return np.array(rmsds).reshape(n_confs, n_confs)\n</code></pre>"},{"location":"api/datamol.conformers.html#datamol.conformers._conformers.translate","title":"<code>translate(mol, new_centroid, conf_id=-1)</code>","text":"<p>Move a given conformer of a molecule to a new position. The transformation is performed in place.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>the molecule.</p> required <code>new_centroid</code> <code>Union[np.ndarray, List[int]]</code> <p>the new position to move to of shape [x, y, z]</p> required <code>conf_id</code> <code>int</code> <p>id of the conformer.</p> <code>-1</code> Source code in <code>datamol/conformers/_conformers.py</code> <pre><code>def translate(mol: Mol, new_centroid: Union[np.ndarray, List[int]], conf_id: int = -1):\n\"\"\"Move a given conformer of a molecule to a new position. The transformation is performed\n    in place.\n\n    Args:\n        mol: the molecule.\n        new_centroid: the new position to move to of shape [x, y, z]\n        conf_id: id of the conformer.\n    \"\"\"\n\n    # Get conformer\n    conf = mol.GetConformer(conf_id)\n\n    # Compute the vector for translation\n    mol_center = rdMolTransforms.ComputeCentroid(conf)\n    mol_center = np.array([mol_center.x, mol_center.y, mol_center.z])\n\n    # Make the transformation matrix\n    T = np.eye(4)\n    T[:3, 3] = new_centroid - mol_center\n\n    # Transform\n    rdMolTransforms.TransformConformer(conf, T)\n</code></pre>"},{"location":"api/datamol.conformers.html#datamol.conformers._features.center_of_mass","title":"<code>center_of_mass(mol, use_atoms=True, digits=None, conf_id=-1)</code>","text":"<p>Compute the center of mass of a conformer of a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule</p> required <code>use_atoms</code> <code>bool</code> <p>Whether to compute the true center of mass or the geometrical center.</p> <code>True</code> <code>digits</code> <code>Optional[int]</code> <p>Number of digits to round to.</p> <code>None</code> <code>conf_id</code> <code>int</code> <p>the conformer id.</p> <code>-1</code> <p>Returns     cm: Center of mass or geometrical center</p> Source code in <code>datamol/conformers/_features.py</code> <pre><code>def center_of_mass(\n    mol: Mol,\n    use_atoms: bool = True,\n    digits: Optional[int] = None,\n    conf_id: int = -1,\n) -&gt; np.ndarray:\n\"\"\"Compute the center of mass of a conformer of a molecule.\n\n    Args:\n        mol: a molecule\n        use_atoms: Whether to compute the true center of mass or the geometrical center.\n        digits: Number of digits to round to.\n        conf_id: the conformer id.\n\n    Returns\n        cm: Center of mass or geometrical center\n    \"\"\"\n    coords = get_coords(mol, conf_id=conf_id)\n    atom_weight = np.ones((coords.shape[0]))\n\n    if use_atoms:\n        atom_weight = np.array([atom.GetMass() for atom in mol.GetAtoms()])\n\n    atom_weight = atom_weight[:, None]\n    atom_weight /= atom_weight.sum()\n    center = (coords * atom_weight).sum(axis=0)\n\n    if digits is not None:\n        center = center.round(digits)\n\n    return center\n</code></pre>"},{"location":"api/datamol.conformers.html#datamol.conformers._features.get_coords","title":"<code>get_coords(mol, conf_id=-1)</code>","text":"<p>Get the coordinate of a conformer of a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule.</p> required <code>conf_id</code> <code>int</code> <p>a conformer id.</p> <code>-1</code> Source code in <code>datamol/conformers/_features.py</code> <pre><code>def get_coords(mol: Mol, conf_id: int = -1):\n\"\"\"Get the coordinate of a conformer of a molecule.\n\n    Args:\n        mol: a molecule.\n        conf_id: a conformer id.\n    \"\"\"\n\n    if mol.GetNumConformers() == 0:\n        raise ValueError(\"Molecule does not have any conformers.\")\n\n    conf = mol.GetConformer(id=conf_id)\n    return conf.GetPositions()\n</code></pre>"},{"location":"api/datamol.conformers.html#datamol.conformers._features.keep_conformers","title":"<code>keep_conformers(mol, indices_to_keep=-1, assign_id=True, copy=True)</code>","text":"<p>Keep on the specified conformer(s) in <code>indices_to_keep</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <code>indices_to_keep</code> <code>Union[int, List[int]]</code> <p>A indice or a least of indices of conformers to keep.</p> <code>-1</code> <code>assign_id</code> <code>bool</code> <p>Whether to assign the kept conformers an id or keep the original one.</p> <code>True</code> <code>copy</code> <code>bool</code> <p>Whether to copy the molecule or not.</p> <code>True</code> Source code in <code>datamol/conformers/_features.py</code> <pre><code>def keep_conformers(\n    mol: Mol,\n    indices_to_keep: Union[int, List[int]] = -1,\n    assign_id: bool = True,\n    copy: bool = True,\n):\n\"\"\"Keep on the specified conformer(s) in `indices_to_keep`.\n\n    Args:\n        mol: A molecule.\n        indices_to_keep: A indice or a least of indices of conformers to keep.\n        assign_id: Whether to assign the kept conformers an id or keep the original one.\n        copy: Whether to copy the molecule or not.\n    \"\"\"\n\n    if copy:\n        mol = copy_mol(mol)\n\n    if not isinstance(indices_to_keep, list):\n        indices_to_keep = [indices_to_keep]\n\n    # Extract conformers to keep\n    confs_to_keep = [mol.GetConformer(conf_id) for conf_id in indices_to_keep]\n\n    # Copy current mol and remove all conformers\n    mol2 = copy_mol(mol)\n    mol2.RemoveAllConformers()\n\n    # Add conformers\n    _ = [mol2.AddConformer(conf, assignId=assign_id) for conf in confs_to_keep]\n\n    # Cleanup\n    mol = mol2\n\n    return mol\n</code></pre>"},{"location":"api/datamol.conformers.html#datamol.conformers._features.sasa","title":"<code>sasa(mol, conf_id=None, n_jobs=1)</code>","text":"<p>Compute Solvent Accessible Surface Area of all the conformers using FreeSASA (https://freesasa.github.io/). Values are returned as an array and also stored within each conformer as a property called <code>rdkit_free_sasa</code>.</p> <p>Example:</p> <pre><code>smiles = \"O=C(C)Oc1ccccc1C(=O)O\"\nmol = dm.to_mol(smiles)\nmol = dm.conformers.generate(mol)\n\n# Compute SASA for all the conformers without parallelization\nsasa_values = dm.conformers.sasa(mol, conf_id=None, n_jobs=1)\n\n# If minimization has been enabled (default to True)\n# you can access the computed energy.\nconf = mol.GetConformer(0)\nprops = conf.GetPropsAsDict()\nprint(props)\n# {'rdkit_uff_energy': 1.7649408317784008}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule</p> required <code>conf_id</code> <code>Optional[Union[int, List[int]]]</code> <p>Id of the conformers to compute. If None, compute all.</p> <code>None</code> <code>n_jobs</code> <code>int</code> <p>Number of jobs for parallelization. Set to 1 to disable and -1 to use all cores.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>mol</code> <code>np.ndarray</code> <p>the molecule with the conformers.</p> Source code in <code>datamol/conformers/_features.py</code> <pre><code>@decorators.disable_on_os(\"win\")\ndef sasa(\n    mol: Mol,\n    conf_id: Optional[Union[int, List[int]]] = None,\n    n_jobs: int = 1,\n) -&gt; np.ndarray:\n\"\"\"Compute Solvent Accessible Surface Area of all the conformers\n    using FreeSASA (https://freesasa.github.io/). Values are returned\n    as an array and also stored within each conformer as a property\n    called `rdkit_free_sasa`.\n\n    Example:\n\n    ```python\n    smiles = \"O=C(C)Oc1ccccc1C(=O)O\"\n    mol = dm.to_mol(smiles)\n    mol = dm.conformers.generate(mol)\n\n    # Compute SASA for all the conformers without parallelization\n    sasa_values = dm.conformers.sasa(mol, conf_id=None, n_jobs=1)\n\n    # If minimization has been enabled (default to True)\n    # you can access the computed energy.\n    conf = mol.GetConformer(0)\n    props = conf.GetPropsAsDict()\n    print(props)\n    # {'rdkit_uff_energy': 1.7649408317784008}\n    ```\n\n    Args:\n        mol: a molecule\n        conf_id: Id of the conformers to compute. If None, compute all.\n        n_jobs: Number of jobs for parallelization. Set to 1 to disable\n            and -1 to use all cores.\n\n    Returns:\n        mol: the molecule with the conformers.\n    \"\"\"\n    from rdkit.Chem import rdFreeSASA\n\n    if mol.GetNumConformers() == 0:\n        raise ValueError(\n            \"The molecule has 0 conformers. You can generate conformers with `dm.conformers.generate(mol)`.\"\n        )\n\n    # Get Van der Waals radii (angstrom)\n    radii = [PERIODIC_TABLE.GetRvdw(atom.GetAtomicNum()) for atom in mol.GetAtoms()]\n\n    # Which conformers to compute\n    conf_ids = []\n    if conf_id is None:\n        # If None compute for all the conformers\n        conf_ids = list(range(mol.GetNumConformers()))  # type: ignore\n    elif isinstance(conf_id, int):\n        conf_ids = [conf_id]\n    else:\n        conf_ids = conf_id\n\n    # Compute solvent accessible surface area\n    def _get_sasa(i):\n        conf = mol.GetConformer(i)\n        sasa = rdFreeSASA.CalcSASA(mol, radii, confIdx=conf.GetId())\n        conf.SetDoubleProp(\"rdkit_free_sasa\", sasa)\n        return sasa\n\n    runner = JobRunner(n_jobs=n_jobs)\n    sasa_values = runner(_get_sasa, conf_ids)\n    return np.array(sasa_values)\n</code></pre>"},{"location":"api/datamol.convert.html","title":"<code>datamol.convert</code>","text":""},{"location":"api/datamol.convert.html#datamol.convert.from_df","title":"<code>from_df(df, smiles_column='smiles', mol_column=None, conserve_smiles=False, sanitize=True)</code>","text":"<p>Convert a dataframe to a list of mols.</p> <p>For the reverse operation, you might to check <code>dm.to_df()</code>.</p> Note <p>If <code>smiles_column</code> is used to build the molecules, this property is removed from the molecules' properties. You can decide to conserve the SMILES column by setting <code>conserve_smiles</code> to True.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>a dataframe.</p> required <code>smiles_column</code> <code>Optional[str]</code> <p>Column name to extract the molecule.</p> <code>'smiles'</code> <code>mol_column</code> <code>Optional[str]</code> <p>Column name to extract the molecule. It takes precedence over <code>smiles_column</code>.</p> <code>None</code> <code>conserve_smiles</code> <code>bool</code> <p>Whether to conserve the SMILES in the mols' props.</p> <code>False</code> <code>sanitize</code> <code>bool</code> <p>Whether to sanitize if <code>smiles_column</code> is not None.</p> <code>True</code> Source code in <code>datamol/convert.py</code> <pre><code>def from_df(\n    df: pd.DataFrame,\n    smiles_column: Optional[str] = \"smiles\",\n    mol_column: Optional[str] = None,\n    conserve_smiles: bool = False,\n    sanitize: bool = True,\n) -&gt; List[Mol]:\n\"\"\"Convert a dataframe to a list of mols.\n\n    For the reverse operation, you might to check `dm.to_df()`.\n\n    Note:\n        If `smiles_column` is used to build the molecules, this property\n        is removed from the molecules' properties. You can decide to conserve\n        the SMILES column by setting `conserve_smiles` to True.\n\n    Args:\n        df: a dataframe.\n        smiles_column: Column name to extract the molecule.\n        mol_column: Column name to extract the molecule. It takes\n            precedence over `smiles_column`.\n        conserve_smiles: Whether to conserve the SMILES in the mols' props.\n        sanitize: Whether to sanitize if `smiles_column` is not None.\n    \"\"\"\n\n    if smiles_column is None and mol_column is None:\n        raise ValueError(\"Either `smiles_column` or `mol_column` must be not None.\")\n\n    if len(df) == 0:\n        return []\n\n    # Try to detect the mol column if `mol_column` is None.\n    if mol_column is None:\n        for col in df.columns:\n            if isinstance(df[col].iloc[0], Mol):\n                col = cast(str, col)\n                mol_column = col\n\n    def _row_to_mol(row) -&gt; Optional[Mol]:\n        props = row.to_dict()\n\n        if mol_column is not None:\n            mol = props.pop(mol_column)\n        else:\n            if conserve_smiles:\n                smiles = props[smiles_column]\n            else:\n                # If a SMILES column is used to create the molecule then it is removed from the\n                # properties.\n                smiles = props.pop(smiles_column)\n\n            mol = dm.to_mol(smiles, sanitize=sanitize)\n\n        if mol is None:\n            return None\n\n        dm.set_mol_props(mol, props)\n        return mol\n\n    return df.apply(_row_to_mol, axis=1).tolist()  # type: ignore\n</code></pre>"},{"location":"api/datamol.convert.html#datamol.convert.from_inchi","title":"<code>from_inchi(inchi, sanitize=True, remove_hs=True)</code>","text":"<p>Convert an InChi to a mol.</p> <p>Parameters:</p> Name Type Description Default <code>inchi</code> <code>Optional[str]</code> <p>an inchi string.</p> required <code>sanitize</code> <code>bool</code> <p>do sanitize.</p> <code>True</code> <code>remove_hs</code> <code>bool</code> <p>do remove hs.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[Mol]</code> <p>mol</p> Source code in <code>datamol/convert.py</code> <pre><code>def from_inchi(\n    inchi: Optional[str],\n    sanitize: bool = True,\n    remove_hs: bool = True,\n) -&gt; Optional[Mol]:\n\"\"\"Convert an InChi to a mol.\n\n    Args:\n        inchi: an inchi string.\n        sanitize: do sanitize.\n        remove_hs: do remove hs.\n\n    Returns:\n        mol\n    \"\"\"\n    if inchi is None:\n        return None\n\n    return Chem.MolFromInchi(inchi, sanitize=sanitize, removeHs=remove_hs)\n</code></pre>"},{"location":"api/datamol.convert.html#datamol.convert.from_selfies","title":"<code>from_selfies(selfies, as_mol=False)</code>","text":"<p>Convert a SEFLIES to a smiles or a mol.</p> <p>Parameters:</p> Name Type Description Default <code>selfies</code> <code>str</code> <p>a selfies.</p> required <code>as_mol</code> <code>str</code> <p>whether to return a mol or a smiles.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[Union[str, Mol]]</code> <p>smiles or mol.</p> Source code in <code>datamol/convert.py</code> <pre><code>def from_selfies(selfies: str, as_mol: bool = False) -&gt; Optional[Union[str, Mol]]:\n\"\"\"Convert a SEFLIES to a smiles or a mol.\n\n    Args:\n        selfies: a selfies.\n        as_mol (str, optional): whether to return a mol or a smiles.\n\n    Returns:\n        smiles or mol.\n    \"\"\"\n    if selfies is None:\n        return None\n\n    smiles = sf.decoder(selfies)\n\n    if as_mol and smiles is not None:\n        return dm.to_mol(smiles)\n\n    return smiles\n</code></pre>"},{"location":"api/datamol.convert.html#datamol.convert.from_smarts","title":"<code>from_smarts(smarts)</code>","text":"<p>Convert a SMARTS string to a molecule</p> <p>Parameters:</p> Name Type Description Default <code>smarts</code> <code>Optional[str]</code> <p>a smarts string</p> required Source code in <code>datamol/convert.py</code> <pre><code>def from_smarts(smarts: Optional[str]) -&gt; Optional[Mol]:\n\"\"\"Convert a SMARTS string to a molecule\n\n    Args:\n        smarts: a smarts string\n    \"\"\"\n\n    if smarts is None:\n        return None\n    return Chem.MolFromSmarts(smarts)  # type: ignore\n</code></pre>"},{"location":"api/datamol.convert.html#datamol.convert.render_mol_df","title":"<code>render_mol_df(df)</code>","text":"<p>Render the molecules column in a dataframe. The rendering is performed in-place only. So nothing is returned.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>a dataframe.</p> required Source code in <code>datamol/convert.py</code> <pre><code>def render_mol_df(df: pd.DataFrame):\n\"\"\"Render the molecules column in a dataframe. The rendering is performed\n    in-place only. So nothing is returned.\n\n    Args:\n        df: a dataframe.\n    \"\"\"\n\n    # NOTE(hadim): _ChangeMoleculeRendering is not relevant anymore with rdkit&gt;=2022.09\n    if dm.is_lower_than_current_rdkit_version(\"2022.09\"):\n        # NOTE(hadim): replace by `PandaTools.ChangeMoleculeRendering` once\n        # https://github.com/rdkit/rdkit/issues/3563 is fixed.\n        _ChangeMoleculeRendering(df)\n</code></pre>"},{"location":"api/datamol.convert.html#datamol.convert.smiles_as_smarts","title":"<code>smiles_as_smarts(mol, keep_hs=True)</code>","text":"<p>Convert a smiles to a smarts if possible</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[str, Mol]</code> <p>a molecule.</p> required <code>keep_hs</code> <code>bool</code> <p>Whether to keep hydrogen. This will increase the count of H atoms for atoms with attached hydrogens to create a valid smarts without further substitution allowed e.g. [H]-[CH]-[] -&gt; [H]-[CH2]-[]</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>smarts of the molecule</p> Source code in <code>datamol/convert.py</code> <pre><code>def smiles_as_smarts(mol: Union[str, Mol], keep_hs: bool = True) -&gt; Optional[str]:\n\"\"\"Convert a smiles to a smarts if possible\n\n    Args:\n        mol: a molecule.\n        keep_hs: Whether to keep hydrogen. This will increase the count of H atoms\n            for atoms with attached hydrogens to create a valid smarts without further substitution allowed\n            e.g. [H]-[CH]-[*] -&gt; [H]-[CH2]-[*]\n\n    Returns:\n        smarts of the molecule\n    \"\"\"\n\n    if isinstance(mol, str):\n        mol = dm.to_mol(mol)\n\n    if mol is None:\n        return None\n\n    # Change the isotope to 99\n    for atom in mol.GetAtoms():  # type: ignore\n        if keep_hs:\n            s = sum(na.GetAtomicNum() == 1 for na in atom.GetNeighbors())\n            if s:\n                atom.SetNumExplicitHs(atom.GetTotalNumHs() + s)\n        atom.SetIsotope(99)\n\n    # Print out the smiles, all the atom attributes will be fully specified\n    smarts = to_smiles(mol, isomeric=True, explicit_bonds=True)\n\n    if smarts is None:\n        return None\n\n    # Remove the 99 isotope labels\n    smarts = re.sub(r\"\\[99\", \"[\", smarts)\n    return smarts\n</code></pre>"},{"location":"api/datamol.convert.html#datamol.convert.to_df","title":"<code>to_df(mols, smiles_column='smiles', mol_column=None, include_private=False, include_computed=False, render_df_mol=True, render_all_df_mol=False, n_jobs=1)</code>","text":"<p>Convert a list of mols to a dataframe using each mol properties as a column.</p> <p>For the reverse operation, you might to check <code>dm.from_df()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>List[Mol]</code> <p>a molecule.</p> required <code>smiles_column</code> <code>Optional[str]</code> <p>name of the SMILES column.</p> <code>'smiles'</code> <code>mol_column</code> <code>Optional[str]</code> <p>Name of the column. If not None, rdkit.Chem.PandaTools is used to add a molecule column.</p> <code>None</code> <code>include_private</code> <code>bool</code> <p>Include private properties in the columns.</p> <code>False</code> <code>include_computed</code> <code>bool</code> <p>Include computed properties in the columns.</p> <code>False</code> <code>render_df_mol</code> <code>bool</code> <p>whether to render the molecule in the dataframe to images. If called once, it will be applied for the newly created dataframe with mol in it.</p> <code>True</code> <code>render_all_df_mol</code> <code>bool</code> <p>Whether to render all pandas dataframe mol column as images.</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>Number of jobs for parallelization. Leave to 1 for no parallelization. Set to -1 to use all available cores.</p> <code>1</code> Source code in <code>datamol/convert.py</code> <pre><code>def to_df(\n    mols: List[Mol],\n    smiles_column: Optional[str] = \"smiles\",\n    mol_column: Optional[str] = None,\n    include_private: bool = False,\n    include_computed: bool = False,\n    render_df_mol: bool = True,\n    render_all_df_mol: bool = False,\n    n_jobs: Optional[int] = 1,\n) -&gt; pd.DataFrame:\n\"\"\"Convert a list of mols to a dataframe using each mol properties\n    as a column.\n\n    For the reverse operation, you might to check `dm.from_df()`.\n\n    Args:\n        mols: a molecule.\n        smiles_column: name of the SMILES column.\n        mol_column: Name of the column. If not None, rdkit.Chem.PandaTools\n            is used to add a molecule column.\n        include_private: Include private properties in the columns.\n        include_computed: Include computed properties in the columns.\n        render_df_mol: whether to render the molecule in the dataframe to images.\n            If called once, it will be applied for the newly created dataframe with\n            mol in it.\n        render_all_df_mol: Whether to render all pandas dataframe mol column as images.\n        n_jobs: Number of jobs for parallelization. Leave to 1 for no\n            parallelization. Set to -1 to use all available cores.\n    \"\"\"\n\n    # Init a dataframe\n    df = pd.DataFrame()\n\n    # Feed it with smiles\n    if smiles_column is not None:\n        smiles = dm.parallelized(to_smiles, mols, n_jobs=n_jobs)\n        df[smiles_column] = smiles\n\n    # Add a mol column\n    if mol_column is not None:\n        df[mol_column] = mols\n\n    # Add any other properties present in the molecule\n    def _mol_to_prop_dict(mol):\n        if mol is not None:\n            return mol.GetPropsAsDict(\n                includePrivate=include_private,\n                includeComputed=include_computed,\n            )\n        else:\n            return {}\n\n    # EN: You cannot use `processes` here because all properties will be lost\n    # An alternative would be https://www.rdkit.org/docs/source/rdkit.Chem.PropertyMol.html\n    # But this has less overhead\n    props = dm.parallelized(_mol_to_prop_dict, mols, n_jobs=n_jobs, scheduler=\"threads\")\n    props_df = pd.DataFrame(props)\n    if smiles_column is not None and smiles_column in props_df.columns:\n        logger.warning(\n            f\"The SMILES column name provided ('{smiles_column}') is already present in the properties\"\n            \" of the molecules. THe returned dataframe will two columns with the same name.\"\n        )\n\n    # Concat the df with the properties df\n    df = pd.concat([df, props_df], axis=1)\n\n    # Render mol column to images\n    if render_df_mol is True and mol_column is not None:\n        render_mol_df(df)\n\n        if render_all_df_mol:\n            PandasTools.RenderImagesInAllDataFrames()\n\n    return df\n</code></pre>"},{"location":"api/datamol.convert.html#datamol.convert.to_inchi","title":"<code>to_inchi(mol)</code>","text":"<p>Convert a mol to a standard Inchi.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[str, Mol]</code> <p>a molecule.</p> required Source code in <code>datamol/convert.py</code> <pre><code>def to_inchi(mol: Union[str, Mol]) -&gt; Optional[str]:\n\"\"\"Convert a mol to a standard Inchi.\n\n    Args:\n        mol: a molecule.\n    \"\"\"\n\n    if isinstance(mol, str):\n        mol = dm.to_mol(mol)\n\n    if mol is None:\n        return None\n\n    inchi_val = Chem.MolToInchi(mol)\n    if not inchi_val:\n        return None\n    return inchi_val\n</code></pre>"},{"location":"api/datamol.convert.html#datamol.convert.to_inchi_non_standard","title":"<code>to_inchi_non_standard(mol, fixed_hydrogen_layer=True, undefined_stereocenter=True, reconnected_metal_layer=True, tautomerism_keto_enol=True, tautomerism_15=True, options=None)</code>","text":"<p>Convert a mol to a non-standard Inchi.</p> <p>Note that turning all the flags to <code>False</code> will result in the standard Inchi.</p> <p>Warning: this function will return a non-standard Inchi. See https://www.inchi-trust.org/technical-faq-2 for details.</p> <p>It's important to not mix standard and non-standard InChi. If you don't know much about non-standard InChi, we highly recommend you to use the standard InChi with <code>dm.to_inchi()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[str, Mol]</code> <p>a molecule.</p> required <code>fixed_hydrogen_layer</code> <code>bool</code> <p>whether to include a fixed hydrogen layer (<code>/FixedH</code>).</p> <code>True</code> <code>undefined_stereocenter</code> <code>bool</code> <p>whether to include an undefined stereocenter layer (<code>/SUU</code>).</p> <code>True</code> <code>reconnected_metal_layer</code> <code>bool</code> <p>whether to include reconnected metals (<code>/RecMet</code>).</p> <code>True</code> <code>tautomerism_keto_enol</code> <code>bool</code> <p>whether to account tautomerism keto-enol (<code>/KET</code>).</p> <code>True</code> <code>tautomerism_15</code> <code>bool</code> <p>whether to account 1,5-tautomerism (<code>/15T</code>).</p> <code>True</code> <code>options</code> <code>Optional[List[str]]</code> <p>More InchI options in a form of a list of string. Example: <code>[\"/SRel\", \"/AuxNone\"]</code>.</p> <code>None</code> Source code in <code>datamol/convert.py</code> <pre><code>def to_inchi_non_standard(\n    mol: Union[str, Mol],\n    fixed_hydrogen_layer: bool = True,\n    undefined_stereocenter: bool = True,\n    reconnected_metal_layer: bool = True,\n    tautomerism_keto_enol: bool = True,\n    tautomerism_15: bool = True,\n    options: Optional[List[str]] = None,\n) -&gt; Optional[str]:\n\"\"\"Convert a mol to a non-standard Inchi.\n\n    Note that turning all the flags to `False` will result in the standard Inchi.\n\n    **Warning**: this function will return a **non-standard** Inchi. See\n    https://www.inchi-trust.org/technical-faq-2 for details.\n\n    It's important to not mix standard and non-standard InChi. If you don't know\n    much about non-standard InChi, we highly recommend you to use the\n    standard InChi with `dm.to_inchi()`.\n\n    Args:\n        mol: a molecule.\n        fixed_hydrogen_layer: whether to include a fixed hydrogen layer (`/FixedH`).\n        undefined_stereocenter: whether to include an undefined stereocenter layer (`/SUU`).\n        reconnected_metal_layer: whether to include reconnected metals (`/RecMet`).\n        tautomerism_keto_enol: whether to account tautomerism keto-enol (`/KET`).\n        tautomerism_15: whether to account 1,5-tautomerism (`/15T`).\n        options: More InchI options in a form of a list of string. Example:\n            `[\"/SRel\", \"/AuxNone\"]`.\n    \"\"\"\n\n    if isinstance(mol, str):\n        mol = dm.to_mol(mol)\n\n    if mol is None:\n        return None\n\n    inchi_options = _process_inchi_options(\n        fixed_hydrogen_layer=fixed_hydrogen_layer,\n        undefined_stereocenter=undefined_stereocenter,\n        reconnected_metal_layer=reconnected_metal_layer,\n        tautomerism_keto_enol=tautomerism_keto_enol,\n        tautomerism_15=tautomerism_15,\n        options=options,\n    )\n\n    inchi_val = Chem.MolToInchi(mol, options=inchi_options)\n    if not inchi_val:\n        return None\n    return inchi_val\n</code></pre>"},{"location":"api/datamol.convert.html#datamol.convert.to_inchikey","title":"<code>to_inchikey(mol)</code>","text":"<p>Convert a mol to a standard InchiKey.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[str, Mol]</code> <p>a molecule</p> required Source code in <code>datamol/convert.py</code> <pre><code>def to_inchikey(mol: Union[str, Mol]) -&gt; Optional[str]:\n\"\"\"Convert a mol to a standard InchiKey.\n\n    Args:\n        mol: a molecule\n    \"\"\"\n    if isinstance(mol, str):\n        mol = dm.to_mol(mol)\n\n    if mol is None:\n        return None\n\n    inchikey = Chem.MolToInchiKey(mol)\n    if not inchikey:\n        return None\n    return inchikey\n</code></pre>"},{"location":"api/datamol.convert.html#datamol.convert.to_inchikey_non_standard","title":"<code>to_inchikey_non_standard(mol, fixed_hydrogen_layer=True, undefined_stereocenter=True, reconnected_metal_layer=True, tautomerism_keto_enol=True, tautomerism_15=True, options=None)</code>","text":"<p>Convert a mol to a non-standard InchiKey.</p> <p>Note that turning all the flags to <code>False</code> will result in the standard InchiKey.</p> <p>Warning: this function will return a non-standard InchiKey. See https://www.inchi-trust.org/technical-faq-2 for details.</p> <p>It's important to not mix standard and non-standard InChiKey. If you don't know much about non-standard InchiKey, we highly recommend you to use the standard InchiKey with <code>dm.to_inchikey()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[str, Mol]</code> <p>a molecule</p> required <code>fixed_hydrogen_layer</code> <code>bool</code> <p>whether to include a fixed hydrogen layer (<code>/FixedH</code>).</p> <code>True</code> <code>undefined_stereocenter</code> <code>bool</code> <p>whether to include an undefined stereocenter layer (<code>/SUU</code>).</p> <code>True</code> <code>reconnected_metal_layer</code> <code>bool</code> <p>whether to include reconnected metals (<code>/RecMet</code>).</p> <code>True</code> <code>tautomerism_keto_enol</code> <code>bool</code> <p>whether to account tautomerism keto-enol (<code>/KET</code>).</p> <code>True</code> <code>tautomerism_15</code> <code>bool</code> <p>whether to account 1,5-tautomerism (<code>/15T</code>).</p> <code>True</code> <code>options</code> <code>Optional[List[str]]</code> <p>More InchI options in a form of a list of string. Example: <code>[\"/SRel\", \"/AuxNone\"]</code>.</p> <code>None</code> Source code in <code>datamol/convert.py</code> <pre><code>def to_inchikey_non_standard(\n    mol: Union[str, Mol],\n    fixed_hydrogen_layer: bool = True,\n    undefined_stereocenter: bool = True,\n    reconnected_metal_layer: bool = True,\n    tautomerism_keto_enol: bool = True,\n    tautomerism_15: bool = True,\n    options: Optional[List[str]] = None,\n) -&gt; Optional[str]:\n\"\"\"Convert a mol to a non-standard InchiKey.\n\n    Note that turning all the flags to `False` will result in the standard InchiKey.\n\n    **Warning**: this function will return a **non-standard** InchiKey. See\n    https://www.inchi-trust.org/technical-faq-2 for details.\n\n    It's important to not mix standard and non-standard InChiKey. If you don't know\n    much about non-standard InchiKey, we highly recommend you to use the\n    standard InchiKey with `dm.to_inchikey()`.\n\n    Args:\n        mol: a molecule\n        fixed_hydrogen_layer: whether to include a fixed hydrogen layer (`/FixedH`).\n        undefined_stereocenter: whether to include an undefined stereocenter layer (`/SUU`).\n        reconnected_metal_layer: whether to include reconnected metals (`/RecMet`).\n        tautomerism_keto_enol: whether to account tautomerism keto-enol (`/KET`).\n        tautomerism_15: whether to account 1,5-tautomerism (`/15T`).\n        options: More InchI options in a form of a list of string. Example:\n            `[\"/SRel\", \"/AuxNone\"]`.\n    \"\"\"\n\n    if isinstance(mol, str):\n        mol = dm.to_mol(mol)\n\n    if mol is None:\n        return None\n\n    inchi_options = _process_inchi_options(\n        fixed_hydrogen_layer=fixed_hydrogen_layer,\n        undefined_stereocenter=undefined_stereocenter,\n        reconnected_metal_layer=reconnected_metal_layer,\n        tautomerism_keto_enol=tautomerism_keto_enol,\n        tautomerism_15=tautomerism_15,\n        options=options,\n    )\n\n    inchikey = Chem.MolToInchiKey(mol, options=inchi_options)\n    if not inchikey:\n        return None\n    return inchikey\n</code></pre>"},{"location":"api/datamol.convert.html#datamol.convert.to_selfies","title":"<code>to_selfies(mol)</code>","text":"<p>Convert a mol to SELFIES.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[str, Mol]</code> <p>a molecule or a SMILES.</p> required <p>Returns:</p> Name Type Description <code>selfies</code> <code>Optional[str]</code> <p>SELFIES string.</p> Source code in <code>datamol/convert.py</code> <pre><code>def to_selfies(mol: Union[str, Mol]) -&gt; Optional[str]:\n\"\"\"Convert a mol to SELFIES.\n\n    Args:\n        mol: a molecule or a SMILES.\n\n    Returns:\n        selfies: SELFIES string.\n    \"\"\"\n\n    if isinstance(mol, Mol):\n        mol = to_smiles(mol)\n\n    if mol is None:\n        return None\n    selfies = sf.encoder(mol)\n\n    if selfies == -1:\n        return None\n\n    return selfies\n</code></pre>"},{"location":"api/datamol.convert.html#datamol.convert.to_smarts","title":"<code>to_smarts(mol)</code>","text":"<p>Convert a mol to SMARTS format</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule.</p> required Source code in <code>datamol/convert.py</code> <pre><code>def to_smarts(mol: Mol) -&gt; Optional[str]:\n\"\"\"Convert a mol to SMARTS format\n\n    Args:\n        mol: a molecule.\n    \"\"\"\n\n    if mol is None:\n        return None\n\n    return Chem.MolToSmarts(mol)  # type: ignore\n</code></pre>"},{"location":"api/datamol.convert.html#datamol.convert.to_smiles","title":"<code>to_smiles(mol, canonical=True, isomeric=True, kekulize=False, ordered=False, explicit_bonds=False, explicit_hs=False, randomize=False, cxsmiles=False, allow_to_fail=False, with_atom_indices=False)</code>","text":"<p>Convert a mol to a SMILES.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule.</p> required <code>canonical</code> <code>bool</code> <p>if false no attempt will be made to canonicalize the molecule.</p> <code>True</code> <code>isomeric</code> <code>bool</code> <p>whether to include information about stereochemistry in the SMILES.</p> <code>True</code> <code>kekulize</code> <code>bool</code> <p>whether to return the kekule version of the SMILES.</p> <code>False</code> <code>ordered</code> <code>bool</code> <p>whether to force reordering of the atoms first.</p> <code>False</code> <code>explicit_bonds</code> <code>bool</code> <p>if true, all bond orders will be explicitly indicated in the output SMILES.</p> <code>False</code> <code>explicit_hs</code> <code>bool</code> <p>if true, all H counts will be explicitly indicated in the output SMILES.</p> <code>False</code> <code>randomize</code> <code>bool</code> <p>whether to randomize the generated smiles. Override <code>canonical</code>.</p> <code>False</code> <code>cxsmiles</code> <code>bool</code> <p>Whether to return a CXSMILES instead of a SMILES.</p> <code>False</code> <code>allow_to_fail</code> <code>bool</code> <p>Raise an error if the conversion to SMILES fails. Return None otherwise.</p> <code>False</code> <code>with_atom_indices</code> <code>bool</code> <p>Whether to add atom indices to the SMILES.</p> <code>False</code> Source code in <code>datamol/convert.py</code> <pre><code>def to_smiles(\n    mol: Mol,\n    canonical: bool = True,\n    isomeric: bool = True,\n    kekulize: bool = False,\n    ordered: bool = False,\n    explicit_bonds: bool = False,\n    explicit_hs: bool = False,\n    randomize: bool = False,\n    cxsmiles: bool = False,\n    allow_to_fail: bool = False,\n    with_atom_indices: bool = False,\n) -&gt; Optional[str]:\n\"\"\"Convert a mol to a SMILES.\n\n    Args:\n        mol: a molecule.\n        canonical: if false no attempt will be made to canonicalize the molecule.\n        isomeric: whether to include information about stereochemistry in the SMILES.\n        kekulize: whether to return the kekule version of the SMILES.\n        ordered: whether to force reordering of the atoms first.\n        explicit_bonds: if true, all bond orders will be explicitly indicated in the output SMILES.\n        explicit_hs: if true, all H counts will be explicitly indicated in the output SMILES.\n        randomize: whether to randomize the generated smiles. Override `canonical`.\n        cxsmiles: Whether to return a CXSMILES instead of a SMILES.\n        allow_to_fail: Raise an error if the conversion to SMILES fails. Return None otherwise.\n        with_atom_indices: Whether to add atom indices to the SMILES.\n    \"\"\"\n\n    if ordered and canonical is False:\n        mol = dm.reorder_atoms(mol)\n\n    if randomize:\n        mol = dm.randomize_atoms(mol)\n        canonical = False\n\n    if with_atom_indices:\n        mol = dm.atom_indices_to_mol(mol, copy=True)\n\n    smiles = None\n    try:\n        if cxsmiles:\n            smiles = rdmolfiles.MolToCXSmiles(\n                mol,\n                isomericSmiles=isomeric,\n                canonical=canonical,\n                allBondsExplicit=explicit_bonds,\n                allHsExplicit=explicit_hs,\n                kekuleSmiles=kekulize,\n            )\n\n        else:\n            smiles = rdmolfiles.MolToSmiles(\n                mol,\n                isomericSmiles=isomeric,\n                canonical=canonical,\n                allBondsExplicit=explicit_bonds,\n                allHsExplicit=explicit_hs,\n                kekuleSmiles=kekulize,\n            )\n\n    except Exception as e:\n        if allow_to_fail:\n            raise e\n\n        return None\n\n    return smiles\n</code></pre>"},{"location":"api/datamol.data.html","title":"<code>datamol.data</code>","text":"<p>The data module aims to provide a fast and convenient access to various molecular datasets.</p>"},{"location":"api/datamol.data.html#datamol.data.cdk2","title":"<code>cdk2(as_df=True, mol_column='mol')</code>","text":"<p>Return the RDKit CDK2 dataset from <code>RDConfig.RDDocsDir, 'Book/data/cdk2.sdf'</code>.</p> <p>Parameters:</p> Name Type Description Default <code>as_df</code> <code>bool</code> <p>Whether to return a list mol or a pandas DataFrame.</p> <code>True</code> <code>mol_column</code> <code>Optional[str]</code> <p>Name of the mol column. Only relevant if <code>as_df</code> is True.</p> <code>'mol'</code> Source code in <code>datamol/data.py</code> <pre><code>def cdk2(as_df: bool = True, mol_column: Optional[str] = \"mol\"):\n\"\"\"Return the RDKit CDK2 dataset from `RDConfig.RDDocsDir, 'Book/data/cdk2.sdf'`.\n\n    Args:\n        as_df: Whether to return a list mol or a pandas DataFrame.\n        mol_column: Name of the mol column. Only relevant if `as_df` is True.\n    \"\"\"\n\n    with pkg_resources.resource_stream(\"datamol\", \"data/cdk2.sdf\") as f:\n        data = read_sdf(f, as_df=as_df, mol_column=mol_column)\n    return data\n</code></pre>"},{"location":"api/datamol.data.html#datamol.data.freesolv","title":"<code>freesolv(as_df=True)</code>","text":"<p>Return the FreeSolv dataset as a dataframe.</p> <p>The dataset contains 642 molecules and the following columns: <code>['iupac', 'smiles', 'expt', 'calc']</code>.</p> Warning <p>This dataset is only meant to be used as a toy dataset for pedagogic and testing purposes. It is not a dataset for benchmarking, analysis or model training.</p> Source code in <code>datamol/data.py</code> <pre><code>def freesolv(as_df: bool = True) -&gt; Union[List[Mol], pd.DataFrame]:\n\"\"\"Return the FreeSolv dataset as a dataframe.\n\n    The dataset contains 642 molecules and the following columns:\n    `['iupac', 'smiles', 'expt', 'calc']`.\n\n    Warning:\n        This dataset is only meant to be used as a toy dataset for pedagogic and\n        testing purposes. **It is not** a dataset for benchmarking, analysis or\n        model training.\n    \"\"\"\n\n    with pkg_resources.resource_stream(\"datamol\", \"data/freesolv.csv\") as f:\n        data = pd.read_csv(f)\n\n    if not as_df:\n        data = from_df(data)\n\n    return data\n</code></pre>"},{"location":"api/datamol.data.html#datamol.data.solubility","title":"<code>solubility(as_df=True, mol_column='mol')</code>","text":"<p>Return the RDKit solubility dataset from <code>RDConfig.RDDocsDir, 'Book/data/solubility.{train|test}.sdf'</code>.</p> <p>The dataframe or the list of molecules with contain a <code>split</code> column, either <code>train</code> or <code>test</code>.</p> <p>Parameters:</p> Name Type Description Default <code>as_df</code> <code>bool</code> <p>Whether to return a list mol or a pandas DataFrame.</p> <code>True</code> <code>mol_column</code> <code>Optional[str]</code> <p>Name of the mol column. Only relevant if <code>as_df</code> is True.</p> <code>'mol'</code> Source code in <code>datamol/data.py</code> <pre><code>def solubility(as_df: bool = True, mol_column: Optional[str] = \"mol\"):\n\"\"\"Return the RDKit solubility dataset from `RDConfig.RDDocsDir, 'Book/data/solubility.{train|test}.sdf'`.\n\n    The dataframe or the list of molecules with contain a `split` column, either `train` or `test`.\n\n    Args:\n        as_df: Whether to return a list mol or a pandas DataFrame.\n        mol_column: Name of the mol column. Only relevant if `as_df` is True.\n    \"\"\"\n\n    with pkg_resources.resource_stream(\"datamol\", \"data/solubility.train.sdf\") as f:\n        train = read_sdf(f, as_df=True, mol_column=\"mol\", smiles_column=None)\n\n    with pkg_resources.resource_stream(\"datamol\", \"data/solubility.test.sdf\") as f:\n        test = read_sdf(f, as_df=True, mol_column=\"mol\", smiles_column=None)\n\n    train = cast(pd.DataFrame, train)\n    test = cast(pd.DataFrame, test)\n\n    train[\"split\"] = \"train\"\n    test[\"split\"] = \"test\"\n\n    # NOTE(hadim): LMAO RDkit consistency xD\n    test = test.rename(columns={\"SMILES\": \"smiles\"})\n\n    data = pd.concat([train, test], ignore_index=True)\n\n    if as_df:\n        if mol_column is None:\n            data = data.drop(columns=[\"mol\"])\n\n        render_mol_df(data)\n        return data\n\n    return from_df(data, mol_column=mol_column)\n</code></pre>"},{"location":"api/datamol.descriptors.html","title":"<code>datamol.descriptors</code>","text":""},{"location":"api/datamol.descriptors.html#datamol.descriptors.descriptors.n_aromatic_atoms","title":"<code>n_aromatic_atoms(mol)</code>","text":"<p>Calculate the number of aromatic atoms.</p> Source code in <code>datamol/descriptors/descriptors.py</code> <pre><code>def n_aromatic_atoms(mol: Mol) -&gt; int:\n\"\"\"Calculate the number of aromatic atoms.\"\"\"\n    matches = mol.GetSubstructMatches(_AROMATIC_QUERY)\n    return len(matches)\n</code></pre>"},{"location":"api/datamol.descriptors.html#datamol.descriptors.descriptors.n_aromatic_atoms_proportion","title":"<code>n_aromatic_atoms_proportion(mol)</code>","text":"<p>Calculate the aromatic proportion: # aromatic atoms/#atoms total.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <p>Only heavy atoms are considered.</p> Source code in <code>datamol/descriptors/descriptors.py</code> <pre><code>def n_aromatic_atoms_proportion(mol: Mol) -&gt; int:\n\"\"\"Calculate the aromatic proportion: # aromatic atoms/#atoms total.\n\n    Args:\n        mol: A molecule.\n\n    Only heavy atoms are considered.\n    \"\"\"\n    return n_aromatic_atoms(mol) / mol.GetNumHeavyAtoms()\n</code></pre>"},{"location":"api/datamol.descriptors.html#datamol.descriptors.descriptors.n_charged_atoms","title":"<code>n_charged_atoms(mol)</code>","text":"<p>Compute the number of charged atoms in a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <p>Returns:</p> Name Type Description <code>n_charged_atoms</code> <code>int</code> <p>number of charged atoms in the molecule</p> Source code in <code>datamol/descriptors/descriptors.py</code> <pre><code>def n_charged_atoms(mol: Mol) -&gt; int:\n\"\"\"Compute the number of charged atoms in a molecule.\n\n    Args:\n        mol: A molecule.\n\n    Returns:\n        n_charged_atoms: number of charged atoms in the molecule\n    \"\"\"\n    return sum([at.GetFormalCharge() != 0 for at in mol.GetAtoms()])\n</code></pre>"},{"location":"api/datamol.descriptors.html#datamol.descriptors.descriptors.n_rigid_bonds","title":"<code>n_rigid_bonds(mol)</code>","text":"<p>Compute the number of rigid bonds in a molecule.</p> <p>Rigid bonds are bonds that are not single and not in rings.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <p>Returns:</p> Name Type Description <code>n_rigid_bonds</code> <code>int</code> <p>number of rigid bonds in the molecule</p> Source code in <code>datamol/descriptors/descriptors.py</code> <pre><code>def n_rigid_bonds(mol: Mol) -&gt; int:\n\"\"\"Compute the number of rigid bonds in a molecule.\n\n    Rigid bonds are bonds that are not single and not in rings.\n\n    Args:\n        mol: A molecule.\n\n    Returns:\n        n_rigid_bonds: number of rigid bonds in the molecule\n    \"\"\"\n    non_rigid_bonds_count = from_smarts(\"*-&amp;!@*\")\n    n_rigid_bonds = mol.GetNumBonds() - len(mol.GetSubstructMatches(non_rigid_bonds_count))\n    return n_rigid_bonds\n</code></pre>"},{"location":"api/datamol.descriptors.html#datamol.descriptors.descriptors.n_stereo_centers","title":"<code>n_stereo_centers(mol)</code>","text":"<p>Compute the number of stereocenters in a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <p>Returns:</p> Name Type Description <code>n_stero_center</code> <code>int</code> <p>number of stereocenters in the molecule</p> Source code in <code>datamol/descriptors/descriptors.py</code> <pre><code>def n_stereo_centers(mol: Mol) -&gt; int:\n\"\"\"Compute the number of stereocenters in a molecule.\n\n    Args:\n        mol: A molecule.\n\n    Returns:\n        n_stero_center: number of stereocenters in the molecule\n    \"\"\"\n    n = 0\n    try:\n        rdmolops.FindPotentialStereo(mol, cleanIt=False)\n        n = rdMolDescriptors.CalcNumAtomStereoCenters(mol)\n    except:\n        pass\n    return n\n</code></pre>"},{"location":"api/datamol.descriptors.html#datamol.descriptors.descriptors.n_stereo_centers_unspecified","title":"<code>n_stereo_centers_unspecified(mol)</code>","text":"<p>Compute the number of unspecified stereocenters in a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <p>Returns:</p> Name Type Description <code>n_stereo_centers_unspecified</code> <code>int</code> <p>number of unspecified stereocenters in the molecule</p> Source code in <code>datamol/descriptors/descriptors.py</code> <pre><code>def n_stereo_centers_unspecified(mol: Mol) -&gt; int:\n\"\"\"Compute the number of unspecified stereocenters in a molecule.\n\n    Args:\n        mol: A molecule.\n\n    Returns:\n        n_stereo_centers_unspecified: number of unspecified stereocenters in the molecule\n    \"\"\"\n    n = 0\n    try:\n        rdmolops.FindPotentialStereo(mol, cleanIt=False)\n        n = rdMolDescriptors.CalcNumUnspecifiedAtomStereoCenters(mol)\n    except:\n        pass\n    return n\n</code></pre>"},{"location":"api/datamol.descriptors.html#datamol.descriptors.compute.any_rdkit_descriptor","title":"<code>any_rdkit_descriptor(name)</code>","text":"<p>Return a descriptor function by name either from <code>rdkit.Chem import Descriptors</code> or <code>rdkit.Chem.rdMolDescriptors</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Descriptor name.</p> required Source code in <code>datamol/descriptors/compute.py</code> <pre><code>def any_rdkit_descriptor(name: str) -&gt; Callable:\n\"\"\"Return a descriptor function by name either from\n    `rdkit.Chem import Descriptors` or `rdkit.Chem.rdMolDescriptors`.\n\n    Args:\n        name: Descriptor name.\n    \"\"\"\n    fn = getattr(Descriptors, name, None)\n\n    if fn is None:\n        fn = getattr(rdMolDescriptors, name, None)\n\n    if fn is None:\n        raise ValueError(f\"Descriptor {name} not found.\")\n\n    return fn\n</code></pre>"},{"location":"api/datamol.descriptors.html#datamol.descriptors.compute.batch_compute_many_descriptors","title":"<code>batch_compute_many_descriptors(mols, properties_fn=None, add_properties=True, n_jobs=1, batch_size=None, progress=False, progress_leave=True)</code>","text":"<p>Compute a list of opiniated molecular properties on a list of molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>List[Mol]</code> <p>A list of molecules.</p> required <code>properties_fn</code> <code>Optional[Dict[str, Union[Callable, str]]]</code> <p>A list of functions that compute properties. If None, a default list of properties is used. If the function is a string, <code>dm.descriptors.any_descriptor()</code> is used to retrieve the descriptor function.</p> <code>None</code> <code>add_properties</code> <code>bool</code> <p>Whether to add the computed properties to the default list.</p> <code>True</code> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>A dataframe of computed properties with one row per input molecules.</p> Source code in <code>datamol/descriptors/compute.py</code> <pre><code>def batch_compute_many_descriptors(\n    mols: List[Mol],\n    properties_fn: Optional[Dict[str, Union[Callable, str]]] = None,\n    add_properties: bool = True,\n    n_jobs: int = 1,\n    batch_size: Optional[int] = None,\n    progress: bool = False,\n    progress_leave: bool = True,\n) -&gt; pd.DataFrame:\n\"\"\"Compute a list of opiniated molecular properties on a list of molecules.\n\n    Args:\n        mols: A list of molecules.\n        properties_fn: A list of functions that compute properties. If None,\n            a default list of properties is used. If the function is a string,\n            `dm.descriptors.any_descriptor()` is used to retrieve the descriptor\n            function.\n        add_properties: Whether to add the computed properties to the default list.\n\n    Returns:\n        A dataframe of computed properties with one row per input molecules.\n    \"\"\"\n\n    compute_fn = functools.partial(\n        compute_many_descriptors,\n        properties_fn=properties_fn,\n        add_properties=add_properties,\n    )\n\n    props = parallelized(\n        compute_fn,\n        mols,\n        batch_size=batch_size,\n        progress=progress,\n        n_jobs=n_jobs,\n        tqdm_kwargs=dict(leave=progress_leave),\n    )\n    return pd.DataFrame(props)\n</code></pre>"},{"location":"api/datamol.descriptors.html#datamol.descriptors.compute.compute_many_descriptors","title":"<code>compute_many_descriptors(mol, properties_fn=None, add_properties=True)</code>","text":"<p>Compute a list of opiniated molecular properties.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <code>properties_fn</code> <code>Optional[Dict[str, Union[Callable, str]]]</code> <p>A list of functions that compute properties. If None, a default list of properties is used. If the function is a string, <code>dm.descriptors.any_descriptor()</code> is used to retrieve the descriptor function.</p> <code>None</code> <code>add_properties</code> <code>bool</code> <p>Whether to add the computed properties to the default list.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>Computed properties as a dict.</p> Source code in <code>datamol/descriptors/compute.py</code> <pre><code>def compute_many_descriptors(\n    mol: Mol,\n    properties_fn: Optional[Dict[str, Union[Callable, str]]] = None,\n    add_properties: bool = True,\n) -&gt; dict:\n\"\"\"Compute a list of opiniated molecular properties.\n\n    Args:\n        mol: A molecule.\n        properties_fn: A list of functions that compute properties. If None,\n            a default list of properties is used. If the function is a string,\n            `dm.descriptors.any_descriptor()` is used to retrieve the descriptor\n            function.\n        add_properties: Whether to add the computed properties to the default list.\n\n    Returns:\n        Computed properties as a dict.\n    \"\"\"\n\n    if properties_fn is None:\n        properties_fn = _DEFAULT_PROPERTIES_FN\n    elif add_properties:\n        [properties_fn.setdefault(k, v) for k, v in _DEFAULT_PROPERTIES_FN.items()]\n\n    props = {}\n    for k, v in properties_fn.items():\n        if isinstance(v, str):\n            v = any_rdkit_descriptor(v)\n\n        props[k] = v(mol)\n\n    return props\n</code></pre>"},{"location":"api/datamol.fp.html","title":"<code>datamol.fp</code>","text":""},{"location":"api/datamol.fp.html#datamol.fp.fold_count_fp","title":"<code>fold_count_fp(fp, dim=1024, binary=False)</code>","text":"<p>Fast folding of a count fingerprint to the specified dimension.</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>Union[np.ndarray, SparseBitVect, ExplicitBitVect]</code> <p>A fingerprint.</p> required <code>dim</code> <code>int</code> <p>The dimension of the folded array.</p> <code>1024</code> <code>binary</code> <code>bool</code> <p>Whether to fold into a binary array or take use a count vector.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>folded</code> <code>np.ndarray</code> <p>returns folded array to the provided dimension.</p> Source code in <code>datamol/fp.py</code> <pre><code>def fold_count_fp(\n    fp: Union[np.ndarray, SparseBitVect, ExplicitBitVect],\n    dim: int = 1024,\n    binary: bool = False,\n) -&gt; np.ndarray:\n\"\"\"Fast folding of a count fingerprint to the specified dimension.\n\n    Args:\n        fp: A fingerprint.\n        dim: The dimension of the folded array.\n        binary: Whether to fold into a binary array or take use a count vector.\n\n    Returns:\n        folded: returns folded array to the provided dimension.\n    \"\"\"\n    if isinstance(\n        fp,\n        (\n            UIntSparseIntVect,\n            IntSparseIntVect,\n            LongSparseIntVect,\n            ULongSparseIntVect,\n        ),\n    ):\n        tmp = fp.GetNonzeroElements()\n\n    elif isinstance(fp, SparseBitVect):\n        on_bits = fp.GetOnBits()\n        tmp = dict(zip(on_bits, np.ones(len(on_bits))))\n\n    else:\n        raise ValueError(f\"The fingerprint is of wrong type: {type(fp)}\")\n\n    # ON bits dict to (i, v)\n    i = np.array(list(tmp.keys())) % dim\n    v = np.array(list(tmp.values()))\n\n    # Fold indices\n    i = i % dim\n\n    # Create the folded fp\n    folded = np.zeros(dim, dtype=\"int\")\n    np.add.at(folded, i, v)\n\n    if binary:\n        folded = np.clip(folded, a_min=0, a_max=1)\n\n    return folded\n</code></pre>"},{"location":"api/datamol.fp.html#datamol.fp.fp_to_array","title":"<code>fp_to_array(fp)</code>","text":"<p>Convert rdkit fingerprint to numpy array.</p> Note <p>This implementation has shown to be faster than using <code>DataStructs.ConvertToNumpyArray</code> by a factor of ~4. See https://github.com/rdkit/rdkit/discussions/3863.</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>Union[np.ndarray, SparseBitVect, ExplicitBitVect, UIntSparseIntVect]</code> <p>The fingerprint.</p> required Source code in <code>datamol/fp.py</code> <pre><code>def fp_to_array(\n    fp: Union[np.ndarray, SparseBitVect, ExplicitBitVect, UIntSparseIntVect]\n) -&gt; np.ndarray:\n\"\"\"Convert rdkit fingerprint to numpy array.\n\n    Note:\n        This implementation has shown to be faster than using `DataStructs.ConvertToNumpyArray`\n        by a factor of ~4. See https://github.com/rdkit/rdkit/discussions/3863.\n\n    Args:\n        fp: The fingerprint.\n    \"\"\"\n\n    if isinstance(fp, np.ndarray):\n        fp_out = fp\n\n    elif isinstance(fp, SparseBitVect):\n        tmp = np.zeros(fp.GetNumBits(), dtype=int)\n        on_bits = np.array(fp.GetOnBits())\n        tmp[on_bits] = 1\n        fp_out = tmp\n\n    elif isinstance(fp, ExplicitBitVect):\n        fp_out = np.frombuffer(fp.ToBitString().encode(), \"u1\") - ord(\"0\")\n\n    elif isinstance(\n        fp,\n        (\n            UIntSparseIntVect,\n            IntSparseIntVect,\n            LongSparseIntVect,\n            ULongSparseIntVect,\n        ),\n    ):\n        tmp = np.zeros(fp.GetLength(), dtype=int)\n        bit_idx, values = np.array(list(fp.GetNonzeroElements().items())).T\n        tmp[bit_idx] = values\n        fp_out = tmp\n\n    else:\n        raise ValueError(\n            f\"The fingerprint of type '{type(fp)}' is not supported. \"\n            \"Please open a ticket at https://github.com/datamol-io/datamol/issues.\"\n        )\n\n    return fp_out\n</code></pre>"},{"location":"api/datamol.fp.html#datamol.fp.list_supported_fingerprints","title":"<code>list_supported_fingerprints()</code>","text":"<p>Return the supported fingerprints in datamol.</p> Source code in <code>datamol/fp.py</code> <pre><code>def list_supported_fingerprints():\n\"\"\"Return the supported fingerprints in datamol.\"\"\"\n\n    return _FP_FUNCS\n</code></pre>"},{"location":"api/datamol.fp.html#datamol.fp.to_fp","title":"<code>to_fp(mol, as_array=True, fp_type='ecfp', fold_size=None, **fp_args)</code>","text":"<p>Compute the molecular fingerprint given a molecule or a SMILES.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[str, Chem.rdchem.Mol]</code> <p>a molecule or a SMILES.</p> required <code>as_array</code> <code>bool</code> <p>Whether to return a numpy array of an RDKit vec. Default to True.</p> <code>True</code> <code>fp_type</code> <code>str</code> <p>The type of the fingerprint. See <code>dm.list_supported_fingerprints()</code> for a complete list.</p> <code>'ecfp'</code> <code>fold_size</code> <code>Optional[int]</code> <p>If set, fold the fingerprint to the <code>fold_size</code>. If set, returned array is always a numpy array.</p> <code>None</code> <code>**fp_args</code> <code>Any</code> <p>Arguments to build the fingerprint. Refer to the official RDKit documentation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[Union[np.ndarray, SparseBitVect, ExplicitBitVect]]</code> <p>A fingerprint vector or None</p> Source code in <code>datamol/fp.py</code> <pre><code>def to_fp(\n    mol: Union[str, Chem.rdchem.Mol],\n    as_array: bool = True,\n    fp_type: str = \"ecfp\",\n    fold_size: Optional[int] = None,\n    **fp_args: Any,\n) -&gt; Optional[Union[np.ndarray, SparseBitVect, ExplicitBitVect]]:\n\"\"\"Compute the molecular fingerprint given a molecule or a SMILES.\n\n    Args:\n        mol: a molecule or a SMILES.\n        as_array: Whether to return a numpy array of an RDKit vec. Default to True.\n        fp_type: The type of the fingerprint. See `dm.list_supported_fingerprints()` for a\n            complete list.\n        fold_size: If set, fold the fingerprint to the `fold_size`. If set, returned array is\n            always a numpy array.\n        **fp_args: Arguments to build the fingerprint. Refer to the official RDKit documentation.\n\n    Returns:\n        A fingerprint vector or None\n    \"\"\"\n\n    # Get fp function\n    fp_func = _FP_FUNCS.get(fp_type)\n\n    if fp_func is None:\n        raise ValueError(\n            f\"The fingerprint '{fp_type}' is not available. Use `dm.list_supported_fingerprints()` to \"\n            \"get a complete list of the available fingerprints.\"\n        )\n\n    # Convert input to mol if needed\n    if isinstance(mol, str):\n        mol_obj = dm.to_mol(mol)\n    else:\n        mol_obj = mol\n\n    if mol_obj is None:\n        raise ValueError(f\"It seems like the input molecule '{mol}' is invalid.\")\n\n    mol = mol_obj\n\n    # Insert default values.\n    for key, value in _FP_DEFAULT_ARGS[fp_type].items():\n        fp_args.setdefault(key, value)\n\n    # Compute the fingerprint\n    fp = fp_func(mol, **fp_args)\n\n    # Fold the fp if needed.\n    if fold_size is not None:\n        fp = fold_count_fp(fp, dim=fold_size)\n\n    # Convert to a numpy array\n    if not fold_size and as_array:\n        fp = fp_to_array(fp)\n\n    return fp\n</code></pre>"},{"location":"api/datamol.fragment.html","title":"<code>datamol.fragment</code>","text":"<p>maclandrol: 22/07/19 This is an attempt to reverse engineer the BRICS (Breaking of Retrosynthetically Interesting Chemical Substructures) approach for molecule fragmentation and use it as an heuristic for assembling molecules. The original paper on BRICS can be found here: http://dacemirror.sci-hub.tw/journal-article/93060992e8d889318b77b562c0e5b75f/degen2008.pdf. This makes senses from a methodological point of view, but I can't either guarantee that its is working as expected of if it's the best way to tackle this problem. The goal here is to reconstruct a set of original molecules, which if they were to be fragmented using BRICS, should yield the same fragment set in input. Thus, in theory fragments obtained using BRICS CAN be assembled into the original molecules with this method. This differs from rdkit BRICSBuild implementation that requires the presence of dummy indicator atoms added by a prior BRICS fragmentation.</p>"},{"location":"api/datamol.fragment.html#datamol.fragment._fragment.anybreak","title":"<code>anybreak(mol, remove_parent=False, sanitize=True, fix=True)</code>","text":"<p>Fragment molecule by applying brics first, then fall back to frag.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Chem.rdchem.Mol</code> <p>a molecule.</p> required <code>remove_parent</code> <code>bool</code> <p>Remove parent from the fragments.</p> <code>False</code> <code>sanitize</code> <code>bool</code> <p>Wether to sanitize the fragments.</p> <code>True</code> <code>fix</code> <code>bool</code> <p>Wether to fix the fragments.</p> <code>True</code> Source code in <code>datamol/fragment/_fragment.py</code> <pre><code>def anybreak(\n    mol: Chem.rdchem.Mol,\n    remove_parent: bool = False,\n    sanitize: bool = True,\n    fix: bool = True,\n):\n\"\"\"Fragment molecule by applying brics first, then fall back to frag.\n\n    Args:\n        mol: a molecule.\n        remove_parent: Remove parent from the fragments.\n        sanitize: Wether to sanitize the fragments.\n        fix: Wether to fix the fragments.\n    \"\"\"\n    frags = []\n    try:\n        frags = brics(mol, fix=fix, remove_parent=remove_parent, sanitize=sanitize)\n    except:\n        pass\n\n    if len(frags) == 0:\n        frags = frag(mol, remove_parent=remove_parent, sanitize=sanitize, fix=fix)\n\n    return frags\n</code></pre>"},{"location":"api/datamol.fragment.html#datamol.fragment._fragment.brics","title":"<code>brics(mol, singlepass=True, remove_parent=False, sanitize=True, fix=True)</code>","text":"<p>Run BRICS on the molecules and potentially fix dummy atoms.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Chem.rdchem.Mol</code> <p>a molecule.</p> required <code>singlepass</code> <code>bool</code> <p>Single pass for <code>BRICSDecompose</code>.</p> <code>True</code> <code>remove_parent</code> <code>bool</code> <p>Remove parent from the fragments.</p> <code>False</code> <code>sanitize</code> <code>bool</code> <p>Wether to sanitize the fragments.</p> <code>True</code> <code>fix</code> <code>bool</code> <p>Wether to fix the fragments.</p> <code>True</code> Source code in <code>datamol/fragment/_fragment.py</code> <pre><code>def brics(\n    mol: Chem.rdchem.Mol,\n    singlepass: bool = True,\n    remove_parent: bool = False,\n    sanitize: bool = True,\n    fix: bool = True,\n):\n\"\"\"Run BRICS on the molecules and potentially fix dummy atoms.\n\n    Args:\n        mol: a molecule.\n        singlepass: Single pass for `BRICSDecompose`.\n        remove_parent: Remove parent from the fragments.\n        sanitize: Wether to sanitize the fragments.\n        fix: Wether to fix the fragments.\n    \"\"\"\n    frags = BRICS.BRICSDecompose(mol, returnMols=True, singlePass=singlepass)\n    frags = list(frags)\n\n    if fix:\n        frags = [dm.fix_mol(x) for x in frags]\n    if sanitize:\n        frags = [dm.sanitize_mol(x) for x in frags]\n    if remove_parent:\n        frags.pop(0)\n\n    frags = [x for x in frags if x is not None]\n\n    return frags\n</code></pre>"},{"location":"api/datamol.fragment.html#datamol.fragment._fragment.frag","title":"<code>frag(mol, remove_parent=False, sanitize=True, fix=True)</code>","text":"<p>Generate all possible fragmentation of a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Chem.rdchem.Mol</code> <p>a molecule.</p> required <code>remove_parent</code> <code>bool</code> <p>Remove parent from the fragments.</p> <code>False</code> <code>sanitize</code> <code>bool</code> <p>Wether to sanitize the fragments.</p> <code>True</code> <code>fix</code> <code>bool</code> <p>Wether to fix the fragments.</p> <code>True</code> Source code in <code>datamol/fragment/_fragment.py</code> <pre><code>def frag(\n    mol: Chem.rdchem.Mol,\n    remove_parent: bool = False,\n    sanitize: bool = True,\n    fix: bool = True,\n):\n\"\"\"Generate all possible fragmentation of a molecule.\n\n    Args:\n        mol: a molecule.\n        remove_parent: Remove parent from the fragments.\n        sanitize: Wether to sanitize the fragments.\n        fix: Wether to fix the fragments.\n    \"\"\"\n    frags = FraggleSim.generate_fraggle_fragmentation(mol)\n\n    smiles = set([])\n    for seq in frags:\n        smiles |= {s.strip() for s in seq.split(\".\")}\n\n    smiles = list(sorted(smiles, reverse=True))\n    frags = [dm.to_mol(s) for s in smiles]\n\n    if fix:\n        frags = [dm.fix_mol(x) for x in frags]\n    if sanitize:\n        frags = [dm.sanitize_mol(x) for x in frags]\n\n    frags = [x for x in frags if x is not None]\n\n    if remove_parent:\n        return frags\n    return [mol] + frags\n</code></pre>"},{"location":"api/datamol.fragment.html#datamol.fragment._fragment.mmpa_cut","title":"<code>mmpa_cut(mol, rdkit_pattern=False)</code>","text":"<p>Cut molecules to perform mmpa analysis later</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>Molecule to fragment.</p> required <code>rdkit_pattern</code> <code>bool</code> <p>Whether to perform the fragmentation using the default rdkit pattern: [#6+0;!$(=, #[!#6])]!@!=!#[]\"</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[Set[Any]]</code> <p>List of 'smiles,core,chains'</p> Source code in <code>datamol/fragment/_fragment.py</code> <pre><code>def mmpa_cut(mol: dm.Mol, rdkit_pattern: bool = False) -&gt; Optional[Set[Any]]:\n\"\"\"Cut molecules to perform mmpa analysis later\n\n    Args:\n        mol: Molecule to fragment.\n        rdkit_pattern: Whether to perform the fragmentation\n            using the default rdkit pattern: [#6+0;!$(*=, #[!#6])]!@!=!#[*]\"\n\n    Returns:\n        List of 'smiles,core,chains'\n    \"\"\"\n\n    if mol is None:\n        return mol\n\n    outlines = set()\n\n    smiles = dm.to_smiles(mol)\n\n    if rdkit_pattern:\n        frags = mmpa_frag(mol, max_cut=3, max_bond_cut=30)\n    else:\n        # heavy atoms\n        frags = mmpa_frag(mol, pattern=\"[!#1]!@!=!#[!#1]\", max_cut=4, max_bond_cut=30)\n        frags.update(mmpa_frag(mol, pattern=\"[!#1]!@!=!#[!#1]\", max_cut=3, max_bond_cut=30))\n\n    frags = set(frags)\n    for core, chains in frags:\n        output = f\"{smiles},{core},{chains}\\n\"\n        outlines.add(output)\n\n    # hydrogen splitting\n    mol = dm.add_hs(mol)\n    smiles = dm.to_smiles(mol)\n\n    n = mol.GetNumHeavyAtoms()\n    if n &lt; 60:\n        frags = mmpa_frag(mol, pattern=None, max_cut=1, max_bond_cut=100, h_split=True)\n        for core, chains in frags:\n            output = f\"{smiles},{core},{chains}\\n\"\n            outlines.add(output)\n\n    return outlines\n</code></pre>"},{"location":"api/datamol.fragment.html#datamol.fragment._fragment.mmpa_frag","title":"<code>mmpa_frag(mol, pattern=None, max_cut=1, max_bond_cut=20, h_split=False)</code>","text":"<p>Fragment molecule on specific bonds suitable for a MMPA analysis.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>Molecule to fragment.</p> required <code>pattern</code> <code>Optional[str]</code> <p>Bond pattern to split on. Will use default rdkit pattern '[#6+0;!$(=,#[!#6])]!@!=!#[]' if not provided.</p> <code>None</code> <code>max_cut</code> <code>int</code> <p>Number of cuts.</p> <code>1</code> <code>max_bond_cut</code> <code>int</code> <p>Maximum number of bond to cut. Default to 20.</p> <code>20</code> <code>h_split</code> <code>bool</code> <p>Whether to split at hydrogen position too. This is equivalent to enabling the addition of new fragments.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[Set[dm.Mol]]</code> <p>List of fragments.</p> Source code in <code>datamol/fragment/_fragment.py</code> <pre><code>def mmpa_frag(\n    mol: dm.Mol,\n    pattern: Optional[str] = None,\n    max_cut: int = 1,\n    max_bond_cut: int = 20,\n    h_split: bool = False,\n) -&gt; Optional[Set[dm.Mol]]:\n\"\"\"Fragment molecule on specific bonds suitable for a MMPA analysis.\n\n    Args:\n        mol: Molecule to fragment.\n        pattern: Bond pattern to split on. Will use default rdkit pattern\n            '[#6+0;!$(*=,#[!#6])]!@!=!#[*]' if not provided.\n        max_cut: Number of cuts.\n        max_bond_cut: Maximum number of bond to cut. Default to 20.\n        h_split:  Whether to split at hydrogen position too.\n            This is equivalent to enabling the addition of new fragments.\n\n    Returns:\n        List of fragments.\n    \"\"\"\n\n    frags = []\n    if pattern is None:\n        frags = rdMMPA.FragmentMol(\n            mol,\n            maxCuts=max_cut,\n            resultsAsMols=False,\n            maxCutBonds=max_bond_cut,\n        )\n    elif pattern:\n        frags = rdMMPA.FragmentMol(\n            mol,\n            pattern=pattern,\n            maxCuts=max_cut,\n            resultsAsMols=False,\n            maxCutBonds=max_bond_cut,\n        )\n\n    if h_split:\n        mol = dm.add_hs(mol)\n        frags += rdMMPA.FragmentMol(\n            mol,\n            pattern=\"[#1]!@!=!#[!#1]\",\n            maxCuts=1,\n            resultsAsMols=False,\n            maxCutBonds=max_bond_cut,\n        )\n    return set(frags)\n</code></pre>"},{"location":"api/datamol.fragment.html#datamol.fragment._fragment.recap","title":"<code>recap(mol, remove_parent=False, sanitize=True, fix=True)</code>","text":"<p>Fragment the molecule using the recap algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Chem.rdchem.Mol</code> <p>a molecule.</p> required <code>remove_parent</code> <code>bool</code> <p>Remove parent from the fragments.</p> <code>False</code> <code>sanitize</code> <code>bool</code> <p>Wether to sanitize the fragments.</p> <code>True</code> <code>fix</code> <code>bool</code> <p>Wether to fix the fragments.</p> <code>True</code> Source code in <code>datamol/fragment/_fragment.py</code> <pre><code>def recap(\n    mol: Chem.rdchem.Mol,\n    remove_parent: bool = False,\n    sanitize: bool = True,\n    fix: bool = True,\n):\n\"\"\"Fragment the molecule using the recap algorithm.\n\n    Args:\n        mol: a molecule.\n        remove_parent: Remove parent from the fragments.\n        sanitize: Wether to sanitize the fragments.\n        fix: Wether to fix the fragments.\n    \"\"\"\n    res = Recap.RecapDecompose(mol)\n    frags = [dm.to_mol(x) for x in res.GetAllChildren().keys()]\n\n    if fix:\n        frags = [dm.fix_mol(x) for x in frags]\n    if sanitize:\n        frags = [dm.sanitize_mol(x) for x in frags]\n\n    frags = [x for x in frags if x is not None]\n\n    if remove_parent:\n        return frags\n    return [mol] + frags\n</code></pre>"},{"location":"api/datamol.fragment.html#datamol.fragment._assemble.assemble_fragment_iter","title":"<code>assemble_fragment_iter(fragmentlist, seens=None, scrambleReagents=False, max_n_mols=float('inf'), maxdepth=3, as_smiles=True, RXNS=None)</code>","text":"<p>Perform an assembly from fragment given all potential RXNS transformation.</p> Source code in <code>datamol/fragment/_assemble.py</code> <pre><code>def assemble_fragment_iter(\n    fragmentlist,\n    seens=None,\n    scrambleReagents=False,\n    max_n_mols=float(\"inf\"),\n    maxdepth=3,\n    as_smiles=True,\n    RXNS=None,\n):\n\"\"\"Perform an assembly from fragment given all potential RXNS transformation.\"\"\"\n\n    if RXNS is None:\n        RXNS = ALL_BRICS_RETRO\n\n    seen = set()\n    if max_n_mols &lt;= 0:\n        return\n    if not seens:\n        seens = list(fragmentlist)\n    if scrambleReagents:\n        seens = list(seens)\n        random.shuffle(seens, random=random.random)\n\n    for seen in seens:\n        nextSteps = []\n        for rxn in RXNS:\n            for fg in fragmentlist:\n                for m, pSmi in _run_at_all_rct(rxn, fg, seen):\n                    if pSmi not in seen:\n                        seen.add(pSmi)\n                        yield m if not as_smiles else pSmi\n                    if _can_continue_with(m, rxn):\n                        nextSteps.append(m)\n\n        if nextSteps and len(seen) &lt;= max_n_mols and maxdepth &gt; 0:\n            for p in assemble_fragment_iter(\n                fragmentlist,\n                seens=nextSteps,\n                scrambleReagents=scrambleReagents,\n                max_n_mols=(max_n_mols - len(seen)),\n                maxdepth=maxdepth - 1,\n            ):\n                pSmi = dm.to_smiles(p, True)\n                if pSmi not in seen:\n                    seen.add(pSmi)\n                    yield p if not as_smiles else pSmi\n                    if len(seen) &gt;= max_n_mols:\n                        return\n</code></pre>"},{"location":"api/datamol.fragment.html#datamol.fragment._assemble.assemble_fragment_order","title":"<code>assemble_fragment_order(fragmentlist, seen=None, allow_incomplete=False, max_n_mols=float('inf'), RXNS=None)</code>","text":"<p>Assemble a list of fragment into a set of possible molecules under rules defined by the brics algorithm</p> We are of course assuming <ol> <li>that the order in the fragmentlist matter :D !</li> <li>that none of the fragment has explicitly defined hydrogen atoms.</li> <li>only a list of unique molecule is internally maintained</li> </ol> <p>Parameters:</p> Name Type Description Default <code>fragmentlist</code> <code>list</code> <p>list of original fragments to grow</p> required <code>seen</code> <code>Optional[Mol]</code> <p>original molecules used as base. If none, the first element of fragment list will be poped out</p> <code>None</code> <code>allow_incomplete</code> <code>bool</code> <p>Whether to accept assembled molecules with missing fragment</p> <code>False</code> Source code in <code>datamol/fragment/_assemble.py</code> <pre><code>def assemble_fragment_order(\n    fragmentlist: list,\n    seen: Optional[Mol] = None,\n    allow_incomplete: bool = False,\n    max_n_mols: float = float(\"inf\"),\n    RXNS=None,\n):\n\"\"\"Assemble a list of fragment into a set of possible molecules under rules defined by the brics algorithm\n\n    We are of course assuming:\n\n        1. that the order in the fragmentlist matter :D !\n        2. that none of the fragment has explicitly defined hydrogen atoms.\n        3. only a list of unique molecule is internally maintained\n\n    Args:\n        fragmentlist: list of original fragments to grow\n        seen: original molecules used as base. If none, the first element of fragment list will be poped out\n        allow_incomplete: Whether to accept assembled molecules with missing fragment\n    \"\"\"\n\n    if RXNS is None:\n        RXNS = ALL_BRICS_RETRO\n\n    fragmentlist = list(fragmentlist)\n    yield_counter = 0\n    if seen is None:\n        seen = fragmentlist.pop(0)\n    seen = [dm.to_smiles(seen)]  # only one molecule to assemble\n    while yield_counter &lt; max_n_mols and len(fragmentlist) &gt; 0:\n        # find all the way to add this fragment to seen\n        frag = fragmentlist.pop(0)\n        level_set = [dm.to_mol(x) for x in seen]\n        seen = set()\n        for sm in level_set:\n            try:\n                # there is no point in even trying something on molecules that cannot be kekulized\n                for rxn in RXNS:\n                    for m, mSmi in _run_at_all_rct(rxn, frag, sm):\n                        if allow_incomplete and mSmi not in seen:\n                            yield m\n                            yield_counter += 1\n                        seen.add(mSmi)\n            except Exception as e:\n                print(e)\n                pass\n\n    for m in seen:\n        if yield_counter &lt; max_n_mols:\n            yield dm.to_mol(m)\n            yield_counter += 1\n</code></pre>"},{"location":"api/datamol.fragment.html#datamol.fragment._assemble.break_mol","title":"<code>break_mol(mol, minFragmentSize=1, silent=True, onlyUseReactions=[], randomize=False, mode='brics', returnTree=False)</code>","text":"<p>Breaks a molecules into a list of fragment.</p> Source code in <code>datamol/fragment/_assemble.py</code> <pre><code>def break_mol(\n    mol: Chem.rdchem.Mol,\n    minFragmentSize: int = 1,\n    silent: bool = True,\n    onlyUseReactions: list = [],\n    randomize: bool = False,\n    mode: str = \"brics\",\n    returnTree: bool = False,\n):\n\"\"\"Breaks a molecules into a list of fragment.\"\"\"\n\n    if mode.lower() == \"brics\":\n        all_reactions = ALL_BRICS\n        all_reactions_type = ALL_BRICS_TYPE\n    elif mode.lower() == \"rxn\":\n        all_reactions = ALL_RXNS\n        all_reactions_type = ALL_RXNS_TYPE\n    else:\n        all_reactions = ALL_BRICS + ALL_RXNS\n        all_reactions_type = ALL_BRICS_TYPE + ALL_RXNS_TYPE\n    if randomize:\n        p = np.random.permutation(len(all_reactions))\n        all_reactions = [all_reactions[ind] for ind in p]\n        all_reactions_type = [all_reactions_type[ind] for ind in p]\n\n    nx = dm.graph._get_networkx()\n    mSmi = dm.to_smiles(mol, isomeric=True)\n    G = nx.DiGraph()\n    node_num = 0\n    G.add_node(node_num, smiles=mSmi, mol=mol)\n    allNodes = set()\n    activePool = {mSmi: node_num}\n    allNodes.add(mSmi)\n    while activePool:\n        nSmi = list(activePool.keys())[0]\n        parent = activePool.pop(nSmi)\n        node = G.nodes[parent]\n        mol = node[\"mol\"]\n        for rxnIdx, reaction in zip(all_reactions_type, all_reactions):\n            if onlyUseReactions and rxnIdx not in onlyUseReactions:\n                continue\n            ps = reaction.RunReactants((mol,))\n            if ps:\n                all_pass = [\n                    all([prod.GetNumAtoms(onlyExplicit=True) &gt; minFragmentSize for prod in p_])\n                    for p_ in ps\n                ]\n                nz_i = 0\n                while nz_i &lt; len(all_pass) and not all_pass[nz_i]:\n                    nz_i += 1\n                if not silent:\n                    print(nSmi, \"-&gt;\", len(ps), \"products and selected \", nz_i)\n                    # display(MolsToGridImage(list(itertools.chain(*list(ps))), molsPerRow=2))\n                prodSeq = ps[nz_i % len(all_pass)]\n                seqOk = True\n                # we want to disqualify small fragments, so sort the product sequence by size\n                prodSeq = [(prod.GetNumAtoms(onlyExplicit=True), prod) for prod in prodSeq]\n                prodSeq.sort(key=lambda x: x[0])\n                for _, prod in prodSeq:\n                    prod.sanitized = True\n                    try:\n                        Chem.SanitizeMol(prod)\n                    except:\n                        if dm.sanitize_mol(prod) is None:\n                            seqOk = False\n                            break\n                        continue\n                    pSmi = dm.to_smiles(prod, isomeric=True)\n                    seqOk = seqOk and (dm.to_mol(pSmi) is not None)\n\n                    notDummies = sum([atm.GetSymbol() != \"*\" for atm in prod.GetAtoms()])\n                    # nDummies = pSmi.count('*')\n                    # if minFragmentSize &gt; 0 and (nats - nDummies &lt; minFragmentSize):\n                    if minFragmentSize &gt; 0 and notDummies &lt; minFragmentSize:\n                        seqOk = False\n                        break\n                    prod.pSmi = pSmi\n\n                if seqOk:\n                    for _, prod in prodSeq:\n                        if not prod.sanitized:\n                            continue\n                        pSmi = prod.pSmi\n                        node_num += 1\n                        usmi = dm.to_smiles(dm.fix_mol(prod), isomeric=True)\n                        G.add_node(node_num, smiles=usmi, mol=prod)\n                        G.add_edge(parent, node_num)\n                        if usmi not in allNodes:\n                            activePool[pSmi] = node_num\n                            allNodes.add(usmi)\n                    G.nodes[parent][\"rxn\"] = rxnIdx\n                    break  # at least one reaction matches\n\n    leaves_smiles = [\n        G.nodes[n][\"smiles\"] for n in G.nodes() if G.in_degree(n) != 0 and G.out_degree(n) == 0\n    ]\n    if returnTree:\n        return leaves_smiles, allNodes, G\n    return leaves_smiles, allNodes\n</code></pre>"},{"location":"api/datamol.fragment.html#datamol.fragment._assemble.build","title":"<code>build(ll_mols, max_n_mols=float('inf'), mode='brics', frag_rxn=None, ADD_RNXS=[])</code>","text":"<p>Build a super molecule from a list of fragments</p> Source code in <code>datamol/fragment/_assemble.py</code> <pre><code>def build(ll_mols, max_n_mols=float(\"inf\"), mode=\"brics\", frag_rxn=None, ADD_RNXS=[]):\n\"\"\"Build a super molecule from a list of fragments\"\"\"\n\n    seen = set()\n    stop = False\n    CUR_RXNS = []\n    CUR_RXNS_TYPE = []\n\n    if mode == \"brics\":\n        CUR_RXNS = ALL_BRICS_RETRO\n        CUR_RXNS_TYPE = ALL_BRICS_TYPE\n    elif mode == \"rxn\":\n        CUR_RXNS = ALL_RXNS_RETRO\n        CUR_RXNS_TYPE = ALL_RXNS_TYPE\n    elif mode is not None:\n        CUR_RXNS = ALL_BRICS_RETRO + ALL_RXNS_RETRO\n        CUR_RXNS_TYPE = ALL_BRICS_TYPE + ALL_RXNS_TYPE\n\n    if ADD_RNXS is not None:\n        ADD_RNXS_TYPE = [f\"RXN-{i}\" for i in range(len(ADD_RNXS))]\n        if isinstance(ADD_RNXS, dict):\n            ADD_RNXS_TYPE = ADD_RNXS.keys()\n            ADD_RNXS = ADD_RNXS.values()\n        CUR_RXNS += list(ADD_RNXS)\n        CUR_RXNS_TYPE += list(ADD_RNXS_TYPE)\n\n    for i, rxn_type in enumerate(CUR_RXNS_TYPE):\n        if (frag_rxn is not None) and (frag_rxn.strip('\"') == rxn_type):\n            CUR_RXNS = [CUR_RXNS[i]]\n            break\n\n    for fraglist in itertools.product(*ll_mols):\n        if stop:\n            break\n\n        fraglist = list(fraglist)\n        for rxn in CUR_RXNS:  # should be size==1 if frag_rxn is provided\n            ps = []\n            try:\n                ps = _run_at_all_rct(rxn, fraglist[0], fraglist[1])\n            except Exception:\n                pass\n            for m, mSmi in ps:\n                if len(seen) &gt;= max_n_mols:\n                    stop = True\n                    break\n                if mSmi not in seen:\n                    seen.add(mSmi)\n                    yield m\n</code></pre>"},{"location":"api/datamol.graph.html","title":"<code>datamol.graph</code>","text":""},{"location":"api/datamol.graph.html#datamol.graph.get_all_path_between","title":"<code>get_all_path_between(mol, atom_idx_1, atom_idx_2, ignore_cycle_basis=False)</code>","text":"<p>Get all simple path between two atoms of a molecule</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>a molecule</p> required <code>atom_idx_1</code> <code>int</code> <p>Atom index 1.</p> required <code>atom_idx_2</code> <code>int</code> <p>Atom index 2.</p> required <code>ignore_cycle_basis</code> <code>bool</code> <p>Whether to ignore cycle basis. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>list of path between two atoms.</p> Source code in <code>datamol/graph.py</code> <pre><code>def get_all_path_between(\n    mol: dm.Mol,\n    atom_idx_1: int,\n    atom_idx_2: int,\n    ignore_cycle_basis: bool = False,\n) -&gt; list:\n\"\"\"Get all simple path between two atoms of a molecule\n\n    Args:\n        mol (dm.Mol): a molecule\n        atom_idx_1 (int): Atom index 1.\n        atom_idx_2 (int): Atom index 2.\n        ignore_cycle_basis: Whether to ignore cycle basis.\n            Defaults to False.\n\n    Returns:\n        list of path between two atoms.\n    \"\"\"\n\n    nx = _get_networkx()\n\n    adj = GetAdjacencyMatrix(mol)\n    G = nx.Graph(adj)\n    path = nx.all_simple_paths(G, source=atom_idx_1, target=atom_idx_2)\n\n    if ignore_cycle_basis:\n        rings = [set(x) for x in mol.GetRingInfo().AtomRings()]\n        final_path = []\n        for p in path:\n            reject_path = False\n            for r in rings:\n                if r.issubset(set(p)):\n                    reject_path = True\n                    break\n            if not reject_path:\n                final_path.append(p)\n        path = final_path\n\n    return list(path)\n</code></pre>"},{"location":"api/datamol.graph.html#datamol.graph.match_molecular_graphs","title":"<code>match_molecular_graphs(mol1, mol2, match_atoms_on=['atomic_num'], match_bonds_on=['bond_type'])</code>","text":"<p>Match the node indices of 2 molecular graphs, with optional usage of atomic number and edge type.</p> Note <p>The matching fails if the hydrogens are implicit in one molecule, but explicit in the other.</p> Note <p>Explicit hydrogens might lead to too many matches, since for an atom with 2 hydrogens, they can be re-ordered in any way.</p> <p>Parameters:</p> Name Type Description Default <code>mol1</code> <code>dm.Mol</code> <p>A molecule.</p> required <code>mol2</code> <code>dm.Mol</code> <p>A molecule.</p> required <code>match_atoms_on</code> <code>List[str]</code> <p>Properties on which to match the atom types. By default, it matches on the <code>'atomic_num'</code> property. Empty list means that it does not consider atom features during matching.</p> <p>Other properties are defined by the <code>datamol.graph.to_graph</code> function and include: - atomic_num - formal_charge - chiral_tag - hybridization - num_explicit_hs - implicit_valence - degree - symbol - ring_atom - is_aromatic</p> <code>['atomic_num']</code> <code>match_bonds_on</code> <code>List[str]</code> <p>Properties on which to match the bond types. Empty list means that it does not consider bond features during matching. By default, it matches on the <code>'bond_type'</code> property. No other properties are defined by the <code>datamol.graph.to_graph</code> function.</p> <code>['bond_type']</code> <p>Returns:</p> Type Description <code>List[Dict[int, int]]</code> <p>A list of all matches dictionaries. In case of a single match, the list has len==1.</p> <code>List[Dict[int, int]]</code> <p>Each dictionary contains as key the indices of <code>mol1</code> and as value the corresponding</p> <code>List[Dict[int, int]]</code> <p>indices of <code>mol2</code>.</p> Source code in <code>datamol/graph.py</code> <pre><code>def match_molecular_graphs(\n    mol1: dm.Mol,\n    mol2: dm.Mol,\n    match_atoms_on: List[str] = [\"atomic_num\"],\n    match_bonds_on: List[str] = [\"bond_type\"],\n) -&gt; List[Dict[int, int]]:\n\"\"\"\n    Match the node indices of 2 molecular graphs,\n    with optional usage of atomic number and edge type.\n\n    Note:\n        The matching fails if the hydrogens are implicit in one molecule,\n        but explicit in the other.\n\n    Note:\n        Explicit hydrogens might lead to too many matches, since for an atom with 2\n        hydrogens, they can be re-ordered in any way.\n\n    Args:\n        mol1: A molecule.\n        mol2: A molecule.\n        match_atoms_on: Properties on which to match the atom types.\n            By default, it matches on the `'atomic_num'` property.\n            Empty list means that it does not consider atom features during matching.\n\n            Other properties are defined by the `datamol.graph.to_graph` function and include:\n            - atomic_num\n            - formal_charge\n            - chiral_tag\n            - hybridization\n            - num_explicit_hs\n            - implicit_valence\n            - degree\n            - symbol\n            - ring_atom\n            - is_aromatic\n\n        match_bonds_on: Properties on which to match the bond types.\n            Empty list means that it does not consider bond features during matching.\n            By default, it matches on the `'bond_type'` property.\n            No other properties are defined by the `datamol.graph.to_graph` function.\n\n    Returns:\n        A list of all matches dictionaries. In case of a single match, the list has len==1.\n        Each dictionary contains as key the indices of `mol1` and as value the corresponding\n        indices of `mol2`.\n    \"\"\"\n\n    nx = _get_networkx()\n\n    if isinstance(match_atoms_on, str):\n        match_atoms_on = [match_atoms_on]\n    if isinstance(match_bonds_on, str):\n        match_bonds_on = [match_bonds_on]\n\n    def node_match_fn(node1, node2):\n\"\"\"Function that matches the atomic number\"\"\"\n        return all([node1[prop] == node2[prop] for prop in match_atoms_on])\n\n    def edge_match_fn(edge1, edge2):\n\"\"\"Function that matches the bond type\"\"\"\n        return all([edge1[prop] == edge2[prop] for prop in match_bonds_on])\n\n    # Convert to networkx graph\n    g1 = to_graph(mol1)\n    g2 = to_graph(mol2)\n\n    # Use the `match` function to find the matching indices\n    node_match = node_match_fn if len(match_atoms_on) &gt; 0 else None\n    edge_match = edge_match_fn if len(match_bonds_on) &gt; 0 else None\n    graph_matcher = nx.algorithms.isomorphism.vf2userfunc.GraphMatcher(\n        g1, g2, node_match=node_match, edge_match=edge_match\n    )\n    matches = list(graph_matcher.match())\n\n    return matches\n</code></pre>"},{"location":"api/datamol.graph.html#datamol.graph.reorder_mol_from_template","title":"<code>reorder_mol_from_template(mol, mol_template, enforce_atomic_num=False, enforce_bond_type=False, ambiguous_match_mode='No', verbose=True)</code>","text":"<p>Re-order the nodes of a molecular graph from the nodes of a template molecule. Molecular graphs and atom types need to be identical, but edge types and charges are not enforced.</p> <p>This is particularily useful when dealing with XYZ files containing node ordering, but with missing information regarding charges and edge types.</p> <p>Note</p> <ul> <li>If you only need to match bond orders, you can check the function <code>rdkit.Chem.AllChem.AssignBondOrdersFromTemplate</code>.</li> <li>The matching fails if the hydrogens are implicit in one molecule, but explicit in the other.</li> <li>Explicit hydrogens might lead to too many matches, since for an atom with 2 hydrogens, they can be re-ordered in any way.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>The molecule to re-order</p> required <code>mol_template</code> <code>dm.Mol</code> <p>The molecule containing the right node order.</p> required <code>enforce_atomic_num</code> <code>bool</code> <p>Whether to enforce atomic number. Atomic numbers are always enforced for a first try. If no match are found and this parameter is <code>False</code>, the matching is tried again.</p> <code>False</code> <code>enforce_bond_type</code> <code>bool</code> <p>Whether to enforce bond types. Bond types are always enforced for a first try. If no match are found and this parameter is <code>False</code>, the matching is tried again.</p> <code>False</code> <code>ambiguous_match_mode</code> <code>str</code> <p>Whether to allow ambiguous matching. This means that, if there are many matches to the molecule, it will still re-order the molecule according to specific rules. Options are: - \"no\": Does not allow ambiguous matching. - \"hs-only\": Allow matching of ambiguous hydrogens. Does not work if trying   to match implicit with explicit hydrogens. - \"first\": Return the first match. - \"best\": Return the match with the least errors on atom type, edges type, and edge stereo.   Errors on the atoms are counted with 1 point, on the charge with 0.25 points,   on the edges with 0.25 points, and on the Stereo with 0.05 points.   If the option <code>enforce_atomic_num</code> is used, then no errors on the atoms are allowed.   If the option <code>enforce_bond_type</code> is used, then no errors on the edges are allowed. - \"best-first\": \"best\", followed by \"first\".</p> <code>'No'</code> <code>verbose</code> <code>bool</code> <p>Whether to warn when the matching does not work or is ambiguous. Different warnings are raised depending on the value of <code>ambiguous_match_mode</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[dm.Mol]</code> <ul> <li><code>None</code> if the molecular graphs do not match (both the graph and atom types). Pring a warning.</li> </ul> <code>Optional[dm.Mol]</code> <ul> <li><code>None</code> if multiple matche are found, which can happen for symmetric molecules such as benzene Pring a warning.</li> </ul> <code>Optional[dm.Mol]</code> <ul> <li><code>Mol</code> The re-ordered molecule when a single match is found.</li> </ul> Source code in <code>datamol/graph.py</code> <pre><code>def reorder_mol_from_template(\n    mol: dm.Mol,\n    mol_template: dm.Mol,\n    enforce_atomic_num: bool = False,\n    enforce_bond_type: bool = False,\n    ambiguous_match_mode: str = \"No\",\n    verbose: bool = True,\n) -&gt; Optional[dm.Mol]:\n\"\"\"\n    Re-order the nodes of a molecular graph from the nodes of a template molecule.\n    Molecular graphs and atom types need to be identical, but edge types and charges\n    are not enforced.\n\n    This is particularily useful when dealing with XYZ files containing node ordering,\n    but with missing information regarding charges and edge types.\n\n    !!! note\n\n        * If you only need to match bond orders, you can check the function\n        `rdkit.Chem.AllChem.AssignBondOrdersFromTemplate`.\n        * The matching fails if the hydrogens are implicit in one molecule,\n        but explicit in the other.\n        * Explicit hydrogens might lead to too many matches, since for an atom with 2\n        hydrogens, they can be re-ordered in any way.\n\n    Args:\n        mol: The molecule to re-order\n        mol_template: The molecule containing the right node order.\n        enforce_atomic_num: Whether to enforce atomic number. Atomic numbers are always enforced\n            for a first try. If no match are found and this parameter is `False`,\n            the matching is tried again.\n        enforce_bond_type: Whether to enforce bond types. Bond types are always enforced\n            for a first try. If no match are found and this parameter is `False`,\n            the matching is tried again.\n        ambiguous_match_mode: Whether to allow ambiguous matching. This means that,\n            if there are many matches to the molecule, it will still re-order\n            the molecule according to specific rules. Options are:\n            - \"no\": Does not allow ambiguous matching.\n            - \"hs-only\": Allow matching of ambiguous hydrogens. Does not work if trying\n              to match implicit with explicit hydrogens.\n            - \"first\": Return the first match.\n            - \"best\": Return the match with the least errors on atom type, edges type, and edge stereo.\n              Errors on the atoms are counted with 1 point, on the charge with 0.25 points,\n              on the edges with 0.25 points, and on the Stereo with 0.05 points.\n              If the option `enforce_atomic_num` is used, then no errors on the atoms are allowed.\n              If the option `enforce_bond_type` is used, then no errors on the edges are allowed.\n            - \"best-first\": \"best\", followed by \"first\".\n        verbose: Whether to warn when the matching does not work or is ambiguous.\n            Different warnings are raised depending on the value of `ambiguous_match_mode`.\n\n    Returns:\n        - `None` if the molecular graphs do not match (both the graph and atom types).\n            Pring a warning.\n        - `None` if multiple matche are found, which can happen for symmetric molecules such as benzene\n            Pring a warning.\n        - `Mol` The re-ordered molecule when a single match is found.\n    \"\"\"\n\n    ambiguous_match_mode = ambiguous_match_mode.lower()\n\n    # Match the ordering of the graphs\n    matches = match_molecular_graphs(\n        mol_template,\n        mol,\n        match_atoms_on=[\"atomic_num\"],\n        match_bonds_on=[\"bond_type\"],\n    )\n\n    # If no matches were found, retry without bond types\n    if (len(matches) == 0) and (not enforce_bond_type):\n        matches = match_molecular_graphs(\n            mol_template,\n            mol,\n            match_atoms_on=[\"atomic_num\"],\n            match_bonds_on=[],\n        )\n\n    # If no matches were found, retry without atom types\n    if (len(matches) == 0) and (not enforce_atomic_num):\n        matches = match_molecular_graphs(\n            mol_template,\n            mol,\n            match_atoms_on=[],\n            match_bonds_on=[\"bond_type\"],\n        )\n\n    # If no matches were found, retry without bond and atom types\n    if (len(matches) == 0) and (not enforce_bond_type) and (not enforce_atomic_num):\n        matches = match_molecular_graphs(mol_template, mol, match_atoms_on=[], match_bonds_on=[])\n\n    # If no match were found, exit the function and return None\n    if len(matches) == 0:\n        if verbose:\n            logger.warning(\"No match was found\")\n        return None\n\n    if len(matches) &gt; 1:\n        # In case we want to allow ambiguous match of hydrogens\n        if ambiguous_match_mode == \"hs-only\":\n            first_keys = list(matches[0].keys())\n            all_hs_mismatch = True\n            for this_match in matches:\n                this_keys = list(this_match.keys())\n                keys_mismatch = [\n                    ii for ii in range(len(this_keys)) if (first_keys[ii] != this_keys[ii])\n                ]\n                atoms_mismatch = [mol.GetAtomWithIdx(key).GetAtomicNum() for key in keys_mismatch]\n                all_hs = all([atom == 1 for atom in atoms_mismatch])\n                if not all_hs:\n                    all_hs_mismatch = False\n                    break\n            if all_hs_mismatch:\n                matches = matches[0:1]\n            else:\n                if verbose:\n                    logger.warning(\n                        f\"{len(matches)} matches were found, ordering is ambiguous, even when ignoring hydrogens\"\n                    )\n                return None\n\n        # Compute the number of atoms and bonds mismatch, and select the one with the least mismatch\n        if (ambiguous_match_mode in [\"best\", \"best-first\"]) and not (\n            enforce_atomic_num and enforce_bond_type\n        ):\n            num_mismatches = []\n            for this_match in matches:\n                num_atoms_mismatch, num_charge_mismatch = 0, 0\n\n                # Get the number of atomic mismatch\n                for key, val in this_match.items():\n                    atom1 = mol.GetAtomWithIdx(val)\n                    atom2 = mol_template.GetAtomWithIdx(key)\n                    num_atoms_mismatch += atom1.GetAtomicNum() != atom2.GetAtomicNum()\n                    num_charge_mismatch += atom1.GetFormalCharge() != atom2.GetFormalCharge()\n\n                # Get the number of bond mismatch\n                num_bonds_type_mismatch, num_bonds_stereo_mismatch = 0, 0\n                for bond1 in mol_template.GetBonds():\n                    begin_idx, end_idx = bond1.GetBeginAtomIdx(), bond1.GetEndAtomIdx()\n                    bond2 = mol.GetBondBetweenAtoms(this_match[begin_idx], this_match[end_idx])\n                    num_bonds_type_mismatch += bond1.GetBondType() != bond2.GetBondType()\n                    num_bonds_stereo_mismatch += (bond1.GetStereo() != bond2.GetStereo()) or (\n                        bond1.GetBondDir() != bond2.GetBondDir()\n                    )\n\n                num_mismatches.append(\n                    (1 * num_atoms_mismatch)\n                    + (0.25 * num_charge_mismatch)\n                    + (0.25 * num_bonds_type_mismatch)\n                    + (0.05 * num_bonds_stereo_mismatch)\n                )\n            min_mismatch_idx = [\n                ii for ii in range(len(num_mismatches)) if num_mismatches[ii] == min(num_mismatches)\n            ]\n            matches = [matches[idx] for idx in min_mismatch_idx]\n\n        # Select the first matching element\n        if ambiguous_match_mode in [\"first\", \"best-first\"]:\n            matches = [matches[0]]\n\n    if len(matches) &gt; 1:\n        # If many matches were found, exit the function and return None\n        if ambiguous_match_mode == \"no\":\n            if verbose:\n                logger.warning(f\"{len(matches)} matches were found, ordering is ambiguous\")\n            return None\n\n    # Re-order the molecule from the matching indices of the template\n    match = matches[0]\n    match = [match[ii] for ii in range(mol.GetNumAtoms())]\n    reordered_mol = RenumberAtoms(mol, match)\n\n    return reordered_mol\n</code></pre>"},{"location":"api/datamol.graph.html#datamol.graph.to_graph","title":"<code>to_graph(mol)</code>","text":"<p>Convert a molecule to a network x graph. A list of properties are added to every nodes and edges.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>a molecule.</p> required <p>Returns:</p> Name Type Description <code>mol_graph</code> <code>networkx.Graph</code> <p>a graph representing the molecule.</p> Source code in <code>datamol/graph.py</code> <pre><code>def to_graph(mol: dm.Mol):\n\"\"\"Convert a molecule to a network x graph. A list of properties are added\n    to every nodes and edges.\n\n    Args:\n        mol (dm.Mol): a molecule.\n\n    Returns:\n        mol_graph (networkx.Graph): a graph representing the molecule.\n    \"\"\"\n\n    nx = _get_networkx()\n\n    mol_graph = nx.Graph()\n    for atom in mol.GetAtoms():\n        mol_graph.add_node(\n            atom.GetIdx(),\n            atomic_num=atom.GetAtomicNum(),\n            formal_charge=atom.GetFormalCharge(),\n            chiral_tag=atom.GetChiralTag(),\n            hybridization=atom.GetHybridization(),\n            num_explicit_hs=atom.GetNumExplicitHs(),\n            implicit_valence=atom.GetImplicitValence(),\n            degree=atom.GetDegree(),\n            symbol=atom.GetSymbol(),\n            ring_atom=atom.IsInRing(),\n            is_aromatic=atom.GetIsAromatic(),\n        )\n    for bond in mol.GetBonds():\n        mol_graph.add_edge(\n            bond.GetBeginAtomIdx(),\n            bond.GetEndAtomIdx(),\n            bond_type=bond.GetBondType(),\n        )\n    return mol_graph\n</code></pre>"},{"location":"api/datamol.io.html","title":"<code>datamol.io</code>","text":""},{"location":"api/datamol.io.html#datamol.io.read_csv","title":"<code>read_csv(urlpath, smiles_column=None, mol_column='mol', **kwargs)</code>","text":"<p>Read a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>urlpath</code> <code>Union[str, os.PathLike, IO]</code> <p>Path to a file or a file-like object. Path can be remote or local.</p> required <code>smiles_column</code> <code>Optional[str]</code> <p>Use this column to build a mol column.</p> <code>None</code> <code>mol_column</code> <code>str</code> <p>Name to give to the mol column. If not None a mol column will be build. Avoid when loading a very large file.</p> <code>'mol'</code> <code>**kwargs</code> <code>Any</code> <p>Arguments to pass to <code>pd.read_csv()</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>df</code> <code>pd.DataFrame</code> <p>a <code>pandas.DataFrame</code></p> Source code in <code>datamol/io.py</code> <pre><code>def read_csv(\n    urlpath: Union[str, os.PathLike, IO],\n    smiles_column: Optional[str] = None,\n    mol_column: str = \"mol\",\n    **kwargs: Any,\n) -&gt; pd.DataFrame:\n\"\"\"Read a CSV file.\n\n    Args:\n        urlpath: Path to a file or a file-like object. Path can be remote or local.\n        smiles_column: Use this column to build a mol column.\n        mol_column: Name to give to the mol column. If not None a mol column will be build.\n            Avoid when loading a very large file.\n        **kwargs: Arguments to pass to `pd.read_csv()`.\n\n    Returns:\n        df: a `pandas.DataFrame`\n    \"\"\"\n\n    df = pd.read_csv(urlpath, **kwargs)\n    df = cast(pd.DataFrame, df)\n\n    if smiles_column is not None:\n        PandasTools.AddMoleculeColumnToFrame(df, smiles_column, mol_column)\n\n    return df\n</code></pre>"},{"location":"api/datamol.io.html#datamol.io.read_excel","title":"<code>read_excel(urlpath, sheet_name=0, smiles_column=None, mol_column='mol', **kwargs)</code>","text":"<p>Read an excel file.</p> <p>Parameters:</p> Name Type Description Default <code>urlpath</code> <code>Union[str, os.PathLike, IO]</code> <p>Path to a file or a file-like object. Path can be remote or local.</p> required <code>sheet_name</code> <code>Optional[Union[str, int, list]]</code> <p>see <code>pandas.read_excel()</code> doc.</p> <code>0</code> <code>mol_column</code> <code>str</code> <p>Name to give to the mol column. If not None a mol column will be build. Avoid when loading a very large file.</p> <code>'mol'</code> <code>mol_column</code> <code>str</code> <p>name to give to the mol column.</p> <code>'mol'</code> <code>**kwargs</code> <code>Any</code> <p>Arguments to pass to <code>pd.read_excel()</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>df</code> <code>pd.DataFrame</code> <p>a <code>pandas.DataFrame</code></p> Source code in <code>datamol/io.py</code> <pre><code>def read_excel(\n    urlpath: Union[str, os.PathLike, IO],\n    sheet_name: Optional[Union[str, int, list]] = 0,\n    smiles_column: Optional[str] = None,\n    mol_column: str = \"mol\",\n    **kwargs: Any,\n) -&gt; pd.DataFrame:\n\"\"\"Read an excel file.\n\n    Args:\n        urlpath: Path to a file or a file-like object. Path can be remote or local.\n        sheet_name: see `pandas.read_excel()` doc.\n        mol_column: Name to give to the mol column. If not None a mol column will be build.\n            Avoid when loading a very large file.\n        mol_column: name to give to the mol column.\n        **kwargs: Arguments to pass to `pd.read_excel()`.\n\n    Returns:\n        df: a `pandas.DataFrame`\n    \"\"\"\n\n    df = pd.read_excel(urlpath, sheet_name=sheet_name, **kwargs)\n    df = cast(pd.DataFrame, df)\n\n    if smiles_column is not None:\n        PandasTools.AddMoleculeColumnToFrame(df, smiles_column, mol_column)\n\n    return df\n</code></pre>"},{"location":"api/datamol.io.html#datamol.io.read_molblock","title":"<code>read_molblock(molblock, sanitize=True, strict_parsing=True, remove_hs=True, fail_if_invalid=False)</code>","text":"<p>Read a Mol block.</p> <p>Note that potential molecule properties are not read.</p> <p>Parameters:</p> Name Type Description Default <code>molblock</code> <code>str</code> <p>String containing the Mol block.</p> required <code>sanitize</code> <code>bool</code> <p>Whether to sanitize the molecules.</p> <code>True</code> <code>strict_parsing</code> <code>bool</code> <p>If set to false, the parser is more lax about correctness of the contents.</p> <code>True</code> <code>remove_hs</code> <code>bool</code> <p>Whether to remove the existing hydrogens in the SDF files.</p> <code>True</code> <code>fail_if_invalid</code> <code>bool</code> <p>If set to true, the parser will raise an exception if the molecule is invalid instead of returning None.</p> <code>False</code> Source code in <code>datamol/io.py</code> <pre><code>def read_molblock(\n    molblock: str,\n    sanitize: bool = True,\n    strict_parsing: bool = True,\n    remove_hs: bool = True,\n    fail_if_invalid: bool = False,\n) -&gt; Optional[dm.Mol]:\n\"\"\"Read a Mol block.\n\n    Note that potential molecule properties are **not** read.\n\n    Args:\n        molblock: String containing the Mol block.\n        sanitize: Whether to sanitize the molecules.\n        strict_parsing: If set to false, the parser is more lax about correctness of the contents.\n        remove_hs: Whether to remove the existing hydrogens in the SDF files.\n        fail_if_invalid: If set to true, the parser will raise an exception if the molecule is invalid\n            instead of returning None.\n    \"\"\"\n\n    mol = rdmolfiles.MolFromMolBlock(\n        molblock,\n        sanitize=sanitize,\n        removeHs=remove_hs,\n        strictParsing=strict_parsing,\n    )\n\n    if mol is None and fail_if_invalid:\n        raise ValueError(f\"Invalid molecule: {molblock}\")\n\n    return mol\n</code></pre>"},{"location":"api/datamol.io.html#datamol.io.read_pdbblock","title":"<code>read_pdbblock(molblock, sanitize=True, remove_hs=True, flavor=0, proximity_bonding=True)</code>","text":"<p>Read a PDB string block.</p> <p>Parameters:</p> Name Type Description Default <code>molblock</code> <code>str</code> <p>String containing the Mol block.</p> required <code>sanitize</code> <code>bool</code> <p>Whether to sanitize the molecules.</p> <code>True</code> <code>remove_hs</code> <code>bool</code> <p>Whether to remove the existing hydrogens in the SDF files.</p> <code>True</code> <code>flavor</code> <code>int</code> <p>RDKit flavor options.</p> <code>0</code> <code>proximity_bonding</code> <code>bool</code> <p>Whether to toggles automatic proximity bonding.</p> <code>True</code> Source code in <code>datamol/io.py</code> <pre><code>def read_pdbblock(\n    molblock: str,\n    sanitize: bool = True,\n    remove_hs: bool = True,\n    flavor: int = 0,\n    proximity_bonding: bool = True,\n) -&gt; dm.Mol:\n\"\"\"Read a PDB string block.\n\n    Args:\n        molblock: String containing the Mol block.\n        sanitize: Whether to sanitize the molecules.\n        remove_hs: Whether to remove the existing hydrogens in the SDF files.\n        flavor: RDKit flavor options.\n        proximity_bonding: Whether to toggles automatic proximity bonding.\n    \"\"\"\n\n    mol = rdmolfiles.MolFromPDBBlock(\n        molblock,\n        sanitize=sanitize,\n        removeHs=remove_hs,\n        flavor=flavor,\n        proximityBonding=proximity_bonding,\n    )\n    return mol\n</code></pre>"},{"location":"api/datamol.io.html#datamol.io.read_pdbfile","title":"<code>read_pdbfile(urlpath, sanitize=True, remove_hs=True, flavor=0, proximity_bonding=True)</code>","text":"<p>Read a PDB file.</p> <p>Parameters:</p> Name Type Description Default <code>urlpath</code> <code>Union[str, os.PathLike]</code> <p>Path to a file or a file-like object. Path can be remote or local.</p> required <code>sanitize</code> <code>bool</code> <p>Whether to sanitize the molecules.</p> <code>True</code> <code>remove_hs</code> <code>bool</code> <p>Whether to remove the existing hydrogens in the SDF files.</p> <code>True</code> <code>flavor</code> <code>int</code> <p>RDKit flavor options.</p> <code>0</code> <code>proximity_bonding</code> <code>bool</code> <p>Whether to toggles automatic proximity bonding.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>mol</code> <code>Mol</code> <p>a molecule</p> Source code in <code>datamol/io.py</code> <pre><code>def read_pdbfile(\n    urlpath: Union[str, os.PathLike],\n    sanitize: bool = True,\n    remove_hs: bool = True,\n    flavor: int = 0,\n    proximity_bonding: bool = True,\n) -&gt; Mol:\n\"\"\"Read a PDB file.\n\n    Args:\n        urlpath: Path to a file or a file-like object. Path can be remote or local.\n        sanitize: Whether to sanitize the molecules.\n        remove_hs: Whether to remove the existing hydrogens in the SDF files.\n        flavor: RDKit flavor options.\n        proximity_bonding: Whether to toggles automatic proximity bonding.\n\n    Returns:\n        mol: a molecule\n    \"\"\"\n\n    with fsspec.open(urlpath, \"r\") as f:\n        f = cast(IO, f)\n        mol = read_pdbblock(\n            f.read(),\n            sanitize=sanitize,\n            remove_hs=remove_hs,\n            flavor=flavor,\n            proximity_bonding=proximity_bonding,\n        )\n    return mol\n</code></pre>"},{"location":"api/datamol.io.html#datamol.io.read_sdf","title":"<code>read_sdf(urlpath, sanitize=True, as_df=False, smiles_column='smiles', mol_column=None, include_private=False, include_computed=False, strict_parsing=True, remove_hs=True, max_num_mols=None, discard_invalid=True, n_jobs=1)</code>","text":"<p>Read an SDF file.</p> <p>Note: This function is meant to be used with dataset that fit in-memory. For a more advanced usage we suggest you to use directly <code>Chem.ForwardSDMolSupplier</code>.</p> <p>Parameters:</p> Name Type Description Default <code>urlpath</code> <code>Union[str, os.PathLike, IO]</code> <p>Path to a file or a file-like object. Path can be remote or local.</p> required <code>sanitize</code> <code>bool</code> <p>Whether to sanitize the molecules.</p> <code>True</code> <code>as_df</code> <code>bool</code> <p>Whether to return a list mol or a pandas DataFrame.</p> <code>False</code> <code>smiles_column</code> <code>Optional[str]</code> <p>Name of the SMILES column. Only relevant if <code>as_df</code> is True.</p> <code>'smiles'</code> <code>mol_column</code> <code>Optional[str]</code> <p>Name of the mol column. Only relevant if <code>as_df</code> is True.</p> <code>None</code> <code>include_private</code> <code>bool</code> <p>Include private properties in the columns.  Only relevant if <code>as_df</code> is True.</p> <code>False</code> <code>include_computed</code> <code>bool</code> <p>Include computed properties in the columns.  Only relevant if <code>as_df</code> is True.</p> <code>False</code> <code>strict_parsing</code> <code>bool</code> <p>If set to false, the parser is more lax about correctness of the contents.</p> <code>True</code> <code>remove_hs</code> <code>bool</code> <p>Whether to remove the existing hydrogens in the SDF files.</p> <code>True</code> <code>max_num_mols</code> <code>Optional[int]</code> <p>Maximum number of molecules to read from the SDF file. Read all by default when set to <code>None</code>.</p> <code>None</code> <code>discard_invalid</code> <code>bool</code> <p>Discard the molecules that failed to be read correctly. Otherwise, invalid molecules will be loaded as <code>None</code>.</p> <code>True</code> <code>n_jobs</code> <code>Optional[int]</code> <p>Optional number of jobs for parallelization of <code>to_df</code>. Leave to 1 for no parallelization. Set to -1 to use all available cores. Only relevant is <code>as_df</code> is True</p> <code>1</code> Source code in <code>datamol/io.py</code> <pre><code>def read_sdf(\n    urlpath: Union[str, os.PathLike, IO],\n    sanitize: bool = True,\n    as_df: bool = False,\n    smiles_column: Optional[str] = \"smiles\",\n    mol_column: Optional[str] = None,\n    include_private: bool = False,\n    include_computed: bool = False,\n    strict_parsing: bool = True,\n    remove_hs: bool = True,\n    max_num_mols: Optional[int] = None,\n    discard_invalid: bool = True,\n    n_jobs: Optional[int] = 1,\n) -&gt; Union[List[Mol], pd.DataFrame]:\n\"\"\"Read an SDF file.\n\n    Note: This function is meant to be used with dataset that fit _in-memory_.\n    For a more advanced usage we suggest you to use directly `Chem.ForwardSDMolSupplier`.\n\n    Args:\n        urlpath: Path to a file or a file-like object. Path can be remote or local.\n        sanitize: Whether to sanitize the molecules.\n        as_df: Whether to return a list mol or a pandas DataFrame.\n        smiles_column: Name of the SMILES column. Only relevant if `as_df` is True.\n        mol_column: Name of the mol column. Only relevant if `as_df` is True.\n        include_private: Include private properties in the columns.  Only relevant if\n            `as_df` is True.\n        include_computed: Include computed properties in the columns.  Only relevant if\n            `as_df` is True.\n        strict_parsing: If set to false, the parser is more lax about correctness of the contents.\n        remove_hs: Whether to remove the existing hydrogens in the SDF files.\n        max_num_mols: Maximum number of molecules to read from the SDF file. Read all by default when set\n            to `None`.\n        discard_invalid: Discard the molecules that failed to be read correctly. Otherwise,\n            invalid molecules will be loaded as `None`.\n        n_jobs: Optional number of jobs for parallelization of `to_df`. Leave to 1 for no\n            parallelization. Set to -1 to use all available cores. Only relevant is `as_df` is True\n    \"\"\"\n\n    # File-like object\n    if isinstance(urlpath, io.IOBase):\n        supplier = rdmolfiles.ForwardSDMolSupplier(\n            urlpath,\n            sanitize=sanitize,\n            strictParsing=strict_parsing,\n            removeHs=remove_hs,\n        )\n        mols = _get_supplier_mols(supplier, max_num_mols)\n\n    # Regular local or remote paths\n    else:\n        with fsspec.open(urlpath, compression=\"infer\") as f:\n            supplier = rdmolfiles.ForwardSDMolSupplier(\n                f,\n                sanitize=sanitize,\n                strictParsing=strict_parsing,\n                removeHs=remove_hs,\n            )\n            mols = _get_supplier_mols(supplier, max_num_mols)\n\n    # Discard None values\n    if discard_invalid:\n        mols = [mol for mol in mols if mol is not None]\n\n    # Convert to dataframe\n    if as_df:\n        return dm.to_df(\n            mols,\n            smiles_column=smiles_column,\n            mol_column=mol_column,\n            include_private=include_private,\n            include_computed=include_computed,\n            n_jobs=n_jobs,\n        )  # type: ignore\n\n    return mols\n</code></pre>"},{"location":"api/datamol.io.html#datamol.io.read_smi","title":"<code>read_smi(urlpath)</code>","text":"<p>Read a list of smiles from am <code>.smi</code> file.</p> <p>Note: We strongly recommend you to use <code>dm.read_csv</code> or <code>pandas.read_csv</code> instead of <code>dm.read_smi</code> since <code>.smi</code> files are CSV-like format. The only difference are the default settings which changes:</p> <ul> <li>The default separator is a space <code></code> instead of a comma <code>,</code>.</li> <li>The headers of the column are not included.</li> </ul> <p>By modifying the args of <code>dm.read_csv()</code>, you will be able to read an <code>.smi</code> files.</p> <p>Parameters:</p> Name Type Description Default <code>urlpath</code> <code>Union[str, pathlib.Path, io.IOBase, fsspec.core.OpenFile]</code> <p>Path to a file or a file-like object. Path can be remote or local.</p> required Source code in <code>datamol/io.py</code> <pre><code>def read_smi(\n    urlpath: Union[str, pathlib.Path, io.IOBase, fsspec.core.OpenFile],\n) -&gt; Sequence[Mol]:\n\"\"\"Read a list of smiles from am `.smi` file.\n\n    Note: We **strongly** recommend you to use `dm.read_csv` or `pandas.read_csv` instead\n    of `dm.read_smi` since `.smi` files are CSV-like format. The only difference are the\n    default settings which changes:\n\n    - The default separator is a space ` ` instead of a comma `,`.\n    - The headers of the column are not included.\n\n    By modifying the args of `dm.read_csv()`, you will be able to read an `.smi` files.\n\n    Args:\n        urlpath: Path to a file or a file-like object. Path can be remote or local.\n    \"\"\"\n\n    active_path = urlpath\n\n    # NOTE(hadim): the temporary local file copy\n    # is because `SmilesMolSupplier` does not support\n    # using file-like object, only path.\n\n    # Copy to a local temporary path if the path is a remote one.\n    if not fsspec.utils.can_be_local(str(urlpath)):\n        active_path = pathlib.Path(tempfile.mkstemp()[1])\n        dm.utils.fs.copy_file(urlpath, active_path, force=True)\n\n    # Read the molecules\n    supplier = rdmolfiles.SmilesMolSupplier(str(active_path), titleLine=0)\n    mols = [mol for mol in supplier if mol is not None]\n\n    # Delete the local temporary path\n    if not fsspec.utils.can_be_local(str(urlpath)):\n        pathlib.Path(str(active_path)).unlink()\n\n    return mols\n</code></pre>"},{"location":"api/datamol.io.html#datamol.io.to_molblock","title":"<code>to_molblock(mol, include_stereo=True, conf_id=-1, kekulize=True, force_V3000=False)</code>","text":"<p>Convert a molecule to a mol block string.</p> <p>Note that any molecule properties are lost.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <code>include_stereo</code> <code>bool</code> <p>Toggles inclusion of stereochemical information in the output.</p> <code>True</code> <code>conf_id</code> <code>int</code> <p>Selects which conformation to output.</p> <code>-1</code> <code>kekulize</code> <code>bool</code> <p>Triggers kekulization of the molecule before it's written, as suggested by the MDL spec.</p> <code>True</code> <code>force_V3000</code> <code>bool</code> <p>Force generation a V3000 mol block (happens automatically with more than 999 atoms or bonds).</p> <code>False</code> Source code in <code>datamol/io.py</code> <pre><code>def to_molblock(\n    mol: Mol,\n    include_stereo: bool = True,\n    conf_id: int = -1,\n    kekulize: bool = True,\n    force_V3000: bool = False,\n):\n\"\"\"Convert a molecule to a mol block string.\n\n    Note that any molecule properties are lost.\n\n    Args:\n        mol: A molecule.\n        include_stereo: Toggles inclusion of stereochemical information in the output.\n        conf_id: Selects which conformation to output.\n        kekulize: Triggers kekulization of the molecule before it's written,\n            as suggested by the MDL spec.\n        force_V3000: Force generation a V3000 mol block (happens automatically\n            with more than 999 atoms or bonds).\n    \"\"\"\n\n    molblock = rdmolfiles.MolToMolBlock(\n        mol,\n        includeStereo=include_stereo,\n        confId=conf_id,\n        kekulize=kekulize,\n        forceV3000=force_V3000,\n    )\n\n    return molblock\n</code></pre>"},{"location":"api/datamol.io.html#datamol.io.to_pdbblock","title":"<code>to_pdbblock(mol, conf_id=-1)</code>","text":"<p>Convert a molecule to a PDB string block.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <code>conf_id</code> <code>int</code> <p>Selects which conformation to use.</p> <code>-1</code> Source code in <code>datamol/io.py</code> <pre><code>def to_pdbblock(mol: Mol, conf_id: int = -1) -&gt; str:\n\"\"\"Convert a molecule to a PDB string block.\n\n    Args:\n        mol: A molecule.\n        conf_id: Selects which conformation to use.\n    \"\"\"\n    molblock = rdmolfiles.MolToPDBBlock(mol, confId=conf_id)\n    return molblock\n</code></pre>"},{"location":"api/datamol.io.html#datamol.io.to_pdbfile","title":"<code>to_pdbfile(mol, urlpath, conf_id=-1)</code>","text":"<p>Save a molecule to a PDB file.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <code>urlpath</code> <code>Union[str, os.PathLike]</code> <p>Path to a file or a file-like object. Path can be remote or local.</p> required <code>conf_id</code> <code>int</code> <p>Selects which conformation to use.</p> <code>-1</code> Source code in <code>datamol/io.py</code> <pre><code>def to_pdbfile(\n    mol: Mol,\n    urlpath: Union[str, os.PathLike],\n    conf_id: int = -1,\n):\n\"\"\"Save a molecule to a PDB file.\n\n    Args:\n        mol: A molecule.\n        urlpath: Path to a file or a file-like object. Path can be remote or local.\n        conf_id: Selects which conformation to use.\n    \"\"\"\n    molblock = to_pdbblock(mol, conf_id=conf_id)\n    with fsspec.open(urlpath, \"w\") as f:\n        f = cast(IO, f)\n        f.write(molblock)\n</code></pre>"},{"location":"api/datamol.io.html#datamol.io.to_sdf","title":"<code>to_sdf(mols, urlpath, smiles_column='smiles', mol_column=None)</code>","text":"<p>Write molecules to a file.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Union[Mol, Sequence[Mol], pd.DataFrame]</code> <p>a dataframe, a molecule or a list of molecule.</p> required <code>urlpath</code> <code>Union[str, os.PathLike, IO]</code> <p>Path to a file or a file-like object. Path can be remote or local.</p> required <code>smiles_column</code> <code>Optional[str]</code> <p>Column name to extract the molecule.</p> <code>'smiles'</code> <code>mol_column</code> <code>Optional[str]</code> <p>Column name to extract the molecule. It takes precedence over <code>smiles_column</code>.</p> <code>None</code> Source code in <code>datamol/io.py</code> <pre><code>def to_sdf(\n    mols: Union[Mol, Sequence[Mol], pd.DataFrame],\n    urlpath: Union[str, os.PathLike, IO],\n    smiles_column: Optional[str] = \"smiles\",\n    mol_column: Optional[str] = None,\n):\n\"\"\"Write molecules to a file.\n\n    Args:\n        mols: a dataframe, a molecule or a list of molecule.\n        urlpath: Path to a file or a file-like object. Path can be remote or local.\n        smiles_column: Column name to extract the molecule.\n        mol_column: Column name to extract the molecule. It takes\n            precedence over `smiles_column`.\n    \"\"\"\n\n    if isinstance(mols, pd.DataFrame):\n        mols = dm.from_df(mols, smiles_column=smiles_column, mol_column=mol_column)\n\n    elif isinstance(mols, Mol):\n        mols = [mols]\n\n    # Filter out None values\n    mols = [mol for mol in mols if mol is not None]\n\n    # File-like object\n    if isinstance(urlpath, io.IOBase):\n        writer = rdmolfiles.SDWriter(urlpath)\n        for mol in mols:\n            writer.write(mol)\n        writer.close()\n\n    # Regular local or remote paths\n    else:\n        with fsspec.open(urlpath, mode=\"w\") as f:\n            writer = rdmolfiles.SDWriter(f)\n            for mol in mols:\n                writer.write(mol)\n            writer.close()\n</code></pre>"},{"location":"api/datamol.io.html#datamol.io.to_smi","title":"<code>to_smi(mols, urlpath, error_if_empty=False)</code>","text":"<p>Save a list of molecules in an <code>.smi</code> file.</p> <p>Note: We strongly recommend you to use <code>dm.to_csv</code> instead of <code>dm.to_smi</code> since <code>.smi</code> files are CSV-like format. The only difference are the default settings which changes:</p> <ul> <li>The default separator is a space <code></code> instead of a comma <code>,</code>.</li> <li>The headers of the column are not included.</li> </ul> <p>By modifying the args of <code>dm.to_csv()</code>, you will be able to save a SMI compatible file.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Mol]</code> <p>a list of molecules.</p> required <code>urlpath</code> <code>Union[str, os.PathLike, IO]</code> <p>Path to a file or a file-like object. Path can be remote or local.</p> required <code>error_if_empty</code> <code>bool</code> <p>whether to raise and error if the input list is empty.</p> <code>False</code> Source code in <code>datamol/io.py</code> <pre><code>def to_smi(\n    mols: Sequence[Mol],\n    urlpath: Union[str, os.PathLike, IO],\n    error_if_empty: bool = False,\n):\n\"\"\"Save a list of molecules in an `.smi` file.\n\n    Note: We **strongly** recommend you to use `dm.to_csv` instead\n    of `dm.to_smi` since `.smi` files are CSV-like format. The only difference are the\n    default settings which changes:\n\n    - The default separator is a space ` ` instead of a comma `,`.\n    - The headers of the column are not included.\n\n    By modifying the args of `dm.to_csv()`, you will be able to save a SMI compatible file.\n\n    Args:\n        mols: a list of molecules.\n        urlpath: Path to a file or a file-like object. Path can be remote or local.\n        error_if_empty: whether to raise and error if the input list is empty.\n    \"\"\"\n\n    if len(mols) == 0 and error_if_empty:\n        raise ValueError(\"The list of mols/smiles provided is empty.\")\n\n    # Filter out None values\n    mols = [mol for mol in mols if mol is not None]\n\n    # File-like object\n    if isinstance(urlpath, io.IOBase):\n        writer = rdmolfiles.SmilesWriter(urlpath, includeHeader=False, nameHeader=\"\")\n        for mol in mols:\n            writer.write(mol)\n        writer.close()\n\n    # Regular local or remote paths\n    else:\n        with fsspec.open(urlpath, \"w\") as f:\n            writer = rdmolfiles.SmilesWriter(f, includeHeader=False, nameHeader=\"\")\n            for mol in mols:\n                writer.write(mol)\n            writer.close()\n</code></pre>"},{"location":"api/datamol.io.html#datamol.io.to_xlsx","title":"<code>to_xlsx(mols, urlpath, smiles_column='smiles', mol_column='mol', mol_size=[300, 300])</code>","text":"<p>Write molecules to an Excel file with a molecule column as an RDKit rendered image.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Union[Mol, Sequence[Mol], pd.DataFrame]</code> <p>a dataframe, a molecule or a list of molecule.</p> required <code>urlpath</code> <code>Union[str, os.PathLike]</code> <p>Path to a file or a file-like object. Path can be remote or local.</p> required <code>smiles_column</code> <code>Optional[str]</code> <p>Column name to extract the molecule.</p> <code>'smiles'</code> <code>mol_column</code> <code>str</code> <p>Column name to extract the molecule. It takes precedence over <code>smiles_column</code>. Column name to write the RDKit rendered image. If none, the molecule images are not written.</p> <code>'mol'</code> Source code in <code>datamol/io.py</code> <pre><code>def to_xlsx(\n    mols: Union[Mol, Sequence[Mol], pd.DataFrame],\n    urlpath: Union[str, os.PathLike],\n    smiles_column: Optional[str] = \"smiles\",\n    mol_column: str = \"mol\",\n    mol_size: List[int] = [300, 300],\n):\n\"\"\"Write molecules to an Excel file with a molecule column as an RDKit rendered\n    image.\n\n    Args:\n        mols: a dataframe, a molecule or a list of molecule.\n        urlpath: Path to a file or a file-like object. Path can be remote or local.\n        smiles_column: Column name to extract the molecule.\n        mol_column: Column name to extract the molecule. It takes\n            precedence over `smiles_column`.\n            Column name to write the RDKit rendered image. If none,\n            the molecule images are not written.\n    \"\"\"\n\n    if isinstance(mols, Mol):\n        mols = [mols]\n\n    if isinstance(mols, Sequence):\n        mols = [mol for mol in mols if mol is not None]\n        mols = dm.to_df(mols, smiles_column=smiles_column, mol_column=mol_column)\n\n    if mols is None or mols.empty:  # type: ignore\n        raise ValueError(\"No molecules to write\")\n\n    with fsspec.open(urlpath, mode=\"wb\") as f:\n        PandasTools.SaveXlsxFromFrame(mols, f, molCol=mol_column, size=mol_size)\n</code></pre>"},{"location":"api/datamol.isomers.html","title":"<code>datamol.isomers</code>","text":""},{"location":"api/datamol.log.html","title":"<code>datamol.log</code>","text":""},{"location":"api/datamol.log.html#datamol.log.without_rdkit_log","title":"<code>without_rdkit_log</code>","text":"<p>Context manager to disable RDKit logs. By default all logs are disabled.</p> <p>Example:</p> <pre><code>import datamol as dm\n\nwith dm.without_rdkit_log():\n    mol = dm.to_mol(\"CCCCO\")  # potential RDKit logs won't show\n</code></pre> Source code in <code>datamol/log.py</code> <pre><code>class without_rdkit_log:\n\"\"\"Context manager to disable RDKit logs. By default all logs are disabled.\n\n    Example:\n\n    ```python\n    import datamol as dm\n\n    with dm.without_rdkit_log():\n        mol = dm.to_mol(\"CCCCO\")  # potential RDKit logs won't show\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        mute_errors: bool = True,\n        mute_warning: bool = True,\n        mute_info: bool = True,\n        mute_debug: bool = True,\n        enable: bool = True,\n    ):\n        if enable is False:\n            mute_errors = False\n            mute_warning = False\n            mute_info = False\n            mute_debug = False\n\n        # Get current log state\n        self.previous_status = self._get_log_status()\n\n        # Init the desired log state to apply during in the context\n        self.desired_status = {}\n        self.desired_status[\"rdApp.error\"] = not mute_errors\n        self.desired_status[\"rdApp.warning\"] = not mute_warning\n        self.desired_status[\"rdApp.debug\"] = not mute_debug\n        self.desired_status[\"rdApp.info\"] = not mute_info\n\n    def _get_log_status(self):\n\"\"\"Get the current log status of RDKit logs.\"\"\"\n        log_status = rdBase.LogStatus()\n        log_status = {st.split(\":\")[0]: st.split(\":\")[1] for st in log_status.split(\"\\n\")}\n        log_status = {k: True if v == \"enabled\" else False for k, v in log_status.items()}\n        return log_status\n\n    def _apply_log_status(self, log_status):\n\"\"\"Apply an RDKit log status.\"\"\"\n        for k, v in log_status.items():\n            if v is True:\n                rdBase.EnableLog(k)\n            else:\n                rdBase.DisableLog(k)\n\n    def __enter__(self):\n        self._apply_log_status(self.desired_status)\n\n    def __exit__(self, *args, **kwargs):\n        self._apply_log_status(self.previous_status)\n</code></pre>"},{"location":"api/datamol.log.html#datamol.log.disable_rdkit_log","title":"<code>disable_rdkit_log()</code>","text":"<p>Disable all rdkit logs.</p> Source code in <code>datamol/log.py</code> <pre><code>def disable_rdkit_log():\n\"\"\"Disable all rdkit logs.\"\"\"\n    for log_level in RDLogger._levels:\n        rdBase.DisableLog(log_level)\n</code></pre>"},{"location":"api/datamol.log.html#datamol.log.enable_rdkit_log","title":"<code>enable_rdkit_log()</code>","text":"<p>Enable all rdkit logs.</p> Source code in <code>datamol/log.py</code> <pre><code>def enable_rdkit_log():\n\"\"\"Enable all rdkit logs.\"\"\"\n    for log_level in RDLogger._levels:\n        rdBase.EnableLog(log_level)\n</code></pre>"},{"location":"api/datamol.mol.html","title":"<code>datamol.mol</code>","text":""},{"location":"api/datamol.mol.html#datamol.mol.add_hs","title":"<code>add_hs(mol, explicit_only=False, add_coords=False, only_on_atoms=None, add_residue_info=False)</code>","text":"<p>Adds hydrogens to the molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule.</p> required <code>explicit_only</code> <code>bool</code> <p>whether to only add explicit hydrogens.</p> <code>False</code> <code>add_coords</code> <code>bool</code> <p>whether to add 3D coordinates to the hydrogens.</p> <code>False</code> <code>only_on_atoms</code> <code>Optional[List[int]]</code> <p>a list of atoms to add hydrogens only on.</p> <code>None</code> <code>add_residue_info</code> <code>bool</code> <p>whether to add residue information to the hydrogens. Useful for PDB files.</p> <code>False</code> Source code in <code>datamol/mol.py</code> <pre><code>def add_hs(\n    mol: Mol,\n    explicit_only: bool = False,\n    add_coords: bool = False,\n    only_on_atoms: Optional[List[int]] = None,\n    add_residue_info: bool = False,\n):\n\"\"\"Adds hydrogens to the molecule.\n\n    Args:\n        mol: a molecule.\n        explicit_only: whether to only add explicit hydrogens.\n        add_coords: whether to add 3D coordinates to the hydrogens.\n        only_on_atoms: a list of atoms to add hydrogens only on.\n        add_residue_info: whether to add residue information to the hydrogens.\n            Useful for PDB files.\n    \"\"\"\n    mol = rdmolops.AddHs(\n        mol,\n        explicitOnly=explicit_only,\n        addCoords=add_coords,\n        onlyOnAtoms=only_on_atoms,\n        addResidueInfo=add_residue_info,\n    )\n\n    return mol\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.adjust_singleton","title":"<code>adjust_singleton(mol)</code>","text":"<p>Remove all atoms that are essentially disconnected singleton nodes in the molecular graph. For example, the chlorine atom and methane fragment will be removed in Cl.[N:1]1=CC(O)=CC2CCCCC12.CC.C\", but not the ethane fragment.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule.</p> required Source code in <code>datamol/mol.py</code> <pre><code>def adjust_singleton(mol: Mol) -&gt; Optional[Mol]:\n\"\"\"Remove all atoms that are essentially disconnected singleton nodes in the molecular graph.\n    For example, the chlorine atom and methane fragment will be removed in Cl.[N:1]1=CC(O)=CC2CCCCC12.CC.C\",\n    but not the ethane fragment.\n\n    Args:\n        mol: a molecule.\n    \"\"\"\n    to_rem = []\n    em = rdchem.RWMol(mol)\n    for atom in mol.GetAtoms():\n        if atom.GetExplicitValence() == 0:\n            to_rem.append(atom.GetIdx())\n    to_rem.sort(reverse=True)\n    for a_idx in to_rem:\n        em.RemoveAtom(a_idx)\n    return em.GetMol()\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.atom_indices_to_mol","title":"<code>atom_indices_to_mol(mol, copy=True)</code>","text":"<p>Add the <code>molAtomMapNumber</code> property to each atoms.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the molecule.</p> <code>True</code> Source code in <code>datamol/mol.py</code> <pre><code>def atom_indices_to_mol(mol: Mol, copy: bool = True):\n\"\"\"Add the `molAtomMapNumber` property to each atoms.\n\n    Args:\n        mol: a molecule\n        copy: Whether to copy the molecule.\n    \"\"\"\n\n    if copy is True:\n        mol = copy_mol(mol)\n\n    for atom in mol.GetAtoms():\n        atom.SetProp(\"molAtomMapNumber\", str(atom.GetIdx()))\n    return mol\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.atom_list_to_bond","title":"<code>atom_list_to_bond(mol, atom_indices, bond_as_idx=False)</code>","text":"<p>Return a list of existing bond indices between a list of atom indices.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <code>atom_indices</code> <code>List[int]</code> <p>A list of atom indices.</p> required Source code in <code>datamol/mol.py</code> <pre><code>def atom_list_to_bond(\n    mol: Mol,\n    atom_indices: List[int],\n    bond_as_idx: bool = False,\n):\n\"\"\"Return a list of existing bond indices between a list of\n    atom indices.\n\n    Args:\n        mol: A molecule.\n        atom_indices: A list of atom indices.\n    \"\"\"\n\n    # Build an atom map\n    atom_map = {}\n    submol = rdmolops.PathToSubmol(mol, atom_indices, useQuery=True, atomMap=atom_map)\n    atom_map_reversed = {v: k for k, v in atom_map.items()}\n\n    bonds = []\n\n    for bond in submol.GetBonds():\n        a1, a2 = bond.GetBeginAtomIdx(), bond.GetEndAtomIdx()\n        ori_a1 = atom_map_reversed[a1]\n        ori_a2 = atom_map_reversed[a2]\n\n        if ori_a1 in atom_indices and ori_a2 in atom_indices:\n            ori_bond = mol.GetBondBetweenAtoms(ori_a1, ori_a2)\n            if bond_as_idx:\n                bonds.append(ori_bond.GetIdx())\n            else:\n                bonds.append(ori_bond)\n\n    return bonds\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.clear_atom_map_number","title":"<code>clear_atom_map_number(mol, copy=True)</code>","text":"<p>Clear the <code>molAtomMapNumber</code> property of the atom's molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the molecule.</p> <code>True</code> Source code in <code>datamol/mol.py</code> <pre><code>def clear_atom_map_number(mol: Mol, copy: bool = True):\n\"\"\"Clear the `molAtomMapNumber` property of the atom's molecule.\n\n    Args:\n        mol: A molecule.\n        copy: Whether to copy the molecule.\n    \"\"\"\n    return clear_atom_props(mol, copy=copy, property_keys=\"molAtomMapNumber\")\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.clear_atom_props","title":"<code>clear_atom_props(mol, property_keys=None, copy=True, include_private=False, include_computed=False)</code>","text":"<p>Clear atom properties from a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <code>property_keys</code> <code>Optional[Union[List[str], str]]</code> <p>If set, only the set properties will be cleared. It not set, all the properties are cleared.</p> <code>None</code> <code>copy</code> <code>bool</code> <p>Whether to copy the molecule.</p> <code>True</code> <code>include_private</code> <code>bool</code> <p>Whether to also clean the private properties.</p> <code>False</code> <code>include_computed</code> <code>bool</code> <p>Whether to also clean the computed properties.</p> <code>False</code> Source code in <code>datamol/mol.py</code> <pre><code>def clear_atom_props(\n    mol: Mol,\n    property_keys: Optional[Union[List[str], str]] = None,\n    copy: bool = True,\n    include_private: bool = False,\n    include_computed: bool = False,\n) -&gt; Mol:\n\"\"\"Clear atom properties from a molecule.\n\n    Args:\n        mol: A molecule.\n        property_keys: If set, only the set properties will be cleared.\n            It not set, all the properties are cleared.\n        copy: Whether to copy the molecule.\n        include_private: Whether to also clean the private properties.\n        include_computed: Whether to also clean the computed properties.\n    \"\"\"\n\n    if copy:\n        mol = copy_mol(mol)\n\n    if property_keys is not None and isinstance(property_keys, str):\n        property_keys = [property_keys]\n\n    for atom in mol.GetAtoms():\n        if property_keys is None:\n            props = atom.GetPropsAsDict(\n                includePrivate=include_private, includeComputed=include_computed\n            )\n            property_keys = list(props.keys())\n\n        for key in property_keys:\n            atom.ClearProp(key)\n\n    return mol\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.clear_mol_props","title":"<code>clear_mol_props(mol, property_keys=None, copy=True, include_private=False, include_computed=False)</code>","text":"<p>Clear properties from a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <code>property_keys</code> <code>Optional[Union[List[str], str]]</code> <p>If set, only the set properties will be cleared. It not set, all the properties are cleared.</p> <code>None</code> <code>copy</code> <code>bool</code> <p>Whether to copy the molecule.</p> <code>True</code> <code>include_private</code> <code>bool</code> <p>Whether to also clean the private properties.</p> <code>False</code> <code>include_computed</code> <code>bool</code> <p>Whether to also clean the computed properties.</p> <code>False</code> Source code in <code>datamol/mol.py</code> <pre><code>def clear_mol_props(\n    mol: Mol,\n    property_keys: Optional[Union[List[str], str]] = None,\n    copy: bool = True,\n    include_private: bool = False,\n    include_computed: bool = False,\n) -&gt; Mol:\n\"\"\"Clear properties from a molecule.\n\n    Args:\n        mol: A molecule.\n        property_keys: If set, only the set properties will be cleared.\n            It not set, all the properties are cleared.\n        copy: Whether to copy the molecule.\n        include_private: Whether to also clean the private properties.\n        include_computed: Whether to also clean the computed properties.\n    \"\"\"\n\n    if copy:\n        mol = copy_mol(mol)\n\n    if property_keys is not None and isinstance(property_keys, str):\n        property_keys = [property_keys]\n\n    if property_keys is None:\n        props = mol.GetPropsAsDict(includePrivate=include_private, includeComputed=include_computed)\n        property_keys = list(props.keys())\n\n    for key in property_keys:\n        mol.ClearProp(key)\n\n    return mol\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.compute_ring_system","title":"<code>compute_ring_system(mol, include_spiro=True)</code>","text":"<p>Compute the list of ring system in a molecule. This is based on RDKit's cookbook: https://www.rdkit.org/docs/Cookbook.html#rings-aromaticity-and-kekulization</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>input molecule</p> required <code>include_spiro</code> <code>bool</code> <p>whether to include spiro rings.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>ring_system</code> <code>List[Set[int]]</code> <p>list of ring system (atom indices).</p> Source code in <code>datamol/mol.py</code> <pre><code>def compute_ring_system(mol: Mol, include_spiro: bool = True) -&gt; List[Set[int]]:\n\"\"\"Compute the list of ring system in a molecule. This is based on RDKit's cookbook:\n    https://www.rdkit.org/docs/Cookbook.html#rings-aromaticity-and-kekulization\n\n    Args:\n        mol: input molecule\n        include_spiro: whether to include spiro rings.\n\n    Returns:\n        ring_system: list of ring system (atom indices).\n    \"\"\"\n    ri = mol.GetRingInfo()\n    systems = []\n    for ring in ri.AtomRings():\n        ringAts = set(ring)\n        nSystems = []\n        for system in systems:\n            nInCommon = len(ringAts.intersection(system))\n            if nInCommon and (include_spiro or nInCommon &gt; 1):\n                ringAts = ringAts.union(system)\n            else:\n                nSystems.append(system)\n        nSystems.append(ringAts)\n        systems = nSystems\n    return systems\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.copy_mol","title":"<code>copy_mol(mol)</code>","text":"<p>Copy a molecule and return a new one.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule to copy.</p> required Source code in <code>datamol/mol.py</code> <pre><code>def copy_mol(mol: Mol) -&gt; Mol:\n\"\"\"Copy a molecule and return a new one.\n\n    Args:\n        mol: a molecule to copy.\n    \"\"\"\n    return copy.deepcopy(mol)\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.copy_mol_props","title":"<code>copy_mol_props(source, destination, include_private=False, include_computed=False)</code>","text":"<p>Copy properties from one source molecule to another destination molecule.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Mol</code> <p>a molecule to copy from.</p> required <code>destination</code> <code>Mol</code> <p>a molecule to copy to.</p> required <code>include_private</code> <code>bool</code> <p>Include private properties.</p> <code>False</code> <code>include_computed</code> <code>bool</code> <p>Include computed properties.</p> <code>False</code> Source code in <code>datamol/mol.py</code> <pre><code>def copy_mol_props(\n    source: Mol,\n    destination: Mol,\n    include_private: bool = False,\n    include_computed: bool = False,\n):\n\"\"\"Copy properties from one source molecule to another destination\n    molecule.\n\n    Args:\n        source: a molecule to copy from.\n        destination: a molecule to copy to.\n        include_private: Include private properties.\n        include_computed: Include computed properties.\n    \"\"\"\n\n    props = source.GetPropsAsDict(includePrivate=include_private, includeComputed=include_computed)\n    set_mol_props(destination, props)\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.decrease_bond","title":"<code>decrease_bond(bond)</code>","text":"<p>Remove one single bond from the input bond. Note that you should first kekulize your molecules and remove non-standard bond.</p> <p>Parameters:</p> Name Type Description Default <code>bond</code> <code>Chem.rdchem.Bond</code> <p>a bond.</p> required Source code in <code>datamol/mol.py</code> <pre><code>def decrease_bond(bond: Chem.rdchem.Bond) -&gt; Optional[Union[list, Chem.rdchem.Bond]]:\n\"\"\"Remove one single bond from the input bond. Note that you should\n    first kekulize your molecules and remove non-standard bond.\n\n    Args:\n        bond: a bond.\n    \"\"\"\n    if bond.GetBondType() == TRIPLE_BOND:\n        return DOUBLE_BOND\n    if bond.GetBondType() == DOUBLE_BOND:\n        return SINGLE_BOND\n    if bond.GetBondType() == SINGLE_BOND:\n        return None\n    return bond\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.fix_mol","title":"<code>fix_mol(mol, n_iter=1, remove_singleton=False, largest_only=False, inplace=False)</code>","text":"<p>Fix error in molecule using a greedy approach.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>input molecule to fix</p> required <code>n_iter</code> <code>int</code> <p>Number of valence fix iteration to apply</p> <code>1</code> <code>remove_singleton</code> <code>bool</code> <p>Whether <code>adjust_singleton</code> should be applied</p> <code>False</code> <code>largest_only</code> <code>bool</code> <p>Whether only the largest fragment should be kept</p> <code>False</code> <code>inplace</code> <code>bool</code> <p>Whether to return a copy of the mol or perform in place operation</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[Mol]</code> <p>Fixed molecule.</p> Source code in <code>datamol/mol.py</code> <pre><code>def fix_mol(\n    mol: Mol,\n    n_iter: int = 1,\n    remove_singleton: bool = False,\n    largest_only: bool = False,\n    inplace: bool = False,\n) -&gt; Optional[Mol]:\n\"\"\"Fix error in molecule using a greedy approach.\n\n    Args:\n        mol: input molecule to fix\n        n_iter: Number of valence fix iteration to apply\n        remove_singleton: Whether `adjust_singleton` should be applied\n        largest_only: Whether only the largest fragment should be kept\n        inplace: Whether to return a copy of the mol or perform in place operation\n\n    Returns:\n        Fixed molecule.\n    \"\"\"\n\n    if not inplace:\n        mol = copy.copy(mol)\n\n    m = sanitize_mol(mol) or mol  # fail back to mol when the fixer fail\n\n    if m is not None:\n        m = remove_dummies(m)\n        for _ in range(n_iter):\n            m = fix_valence(m)\n\n        if remove_singleton:\n            m = adjust_singleton(m)\n\n        if largest_only:\n            # m = max(Chem.rdmolops.GetMolFrags(m, asMols=True, sanitizeFrags=False), key=lambda m: m.GetNumAtoms())\n            m = rdMolStandardize.FragmentParent(m, skipStandardize=True)\n\n    return m\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.fix_valence","title":"<code>fix_valence(mol, inplace=False, allow_ring_break=False)</code>","text":"<p>Identify and try to fix valence issues by removing any supplemental bond that should not be in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>input molecule with incorrect valence for some atoms</p> required <code>inplace</code> <code>bool</code> <p>Whether to modify in place or make a copy</p> <code>False</code> <code>allow_ring_break</code> <code>bool</code> <p>Whether bond removal involving ring is allowed.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[Mol]</code> <p>Fixed potential valence issue in molecule or original molecule when nothing is broken</p> <code>Optional[Mol]</code> <p>of if failed.</p> Source code in <code>datamol/mol.py</code> <pre><code>def fix_valence(mol: Mol, inplace: bool = False, allow_ring_break: bool = False) -&gt; Optional[Mol]:\n\"\"\"Identify and try to fix valence issues by removing any supplemental bond\n    that should not be in the graph.\n\n    Args:\n        mol: input molecule with incorrect valence for some atoms\n        inplace: Whether to modify in place or make a copy\n        allow_ring_break: Whether bond removal involving ring is allowed.\n\n    Returns:\n        Fixed potential valence issue in molecule or original molecule when nothing is broken\n        of if failed.\n    \"\"\"\n    if not inplace:\n        mol = copy.copy(mol)\n\n    vm = rdMolStandardize.RDKitValidation()\n    if len(vm.validate(mol)) == 0:  # don't fix something that is not broken\n        return mol\n\n    try:\n        m = remove_hs(\n            mol,\n            implicit_only=False,\n            update_explicit_count=True,\n            sanitize=False,\n        )\n        m.UpdatePropertyCache(False)\n\n        # first pass using explicit false count\n        for atom in m.GetAtoms():\n            while incorrect_valence(atom) and atom.GetTotalNumHs() &gt; 0:\n                cur_hydrogen = atom.GetTotalNumHs()\n                atom.SetNumExplicitHs(max(0, cur_hydrogen - 1))\n                atom.SetFormalCharge(max(0, atom.GetFormalCharge() - 1))\n                # atom.SetNumRadicalElectrons(0)\n            atom.UpdatePropertyCache(False)\n\n        em = rdchem.RWMol(m)\n        bonds = em.GetBonds()\n        bonds = [\n            bond\n            for bond in bonds\n            if any(\n                [\n                    incorrect_valence(bond.GetBeginAtom()),\n                    incorrect_valence(bond.GetEndAtom()),\n                ]\n            )\n        ]\n        for bond in bonds:\n            a1 = bond.GetBeginAtom()\n            a2 = bond.GetEndAtom()\n            if incorrect_valence(a1) or incorrect_valence(a2):\n                mbond = decrease_bond(bond)\n                if allow_ring_break or (mbond or not bond.IsInRing()):\n                    em.RemoveBond(a1.GetIdx(), a2.GetIdx())\n                    if mbond is not None:\n                        em.AddBond(a1.GetIdx(), a2.GetIdx(), mbond)\n            a1.UpdatePropertyCache(False)\n            a2.UpdatePropertyCache(False)\n        m = em.GetMol()\n\n    except Exception:\n        return None\n\n    return m\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.fix_valence_charge","title":"<code>fix_valence_charge(mol, inplace=False)</code>","text":"<p>Fix valence issues that are due to incorrect charges.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>Input molecule with incorrect valence for some atoms</p> required <code>inplace</code> <code>bool</code> <p>Whether to modify in place or make a copy.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[Mol]</code> <p>Fixed molecule via charge correction or original molecule if failed.</p> Source code in <code>datamol/mol.py</code> <pre><code>def fix_valence_charge(mol: Mol, inplace: bool = False) -&gt; Optional[Mol]:\n\"\"\"Fix valence issues that are due to incorrect charges.\n\n    Args:\n        mol: Input molecule with incorrect valence for some atoms\n        inplace: Whether to modify in place or make a copy.\n\n    Returns:\n        Fixed molecule via charge correction or original molecule if failed.\n    \"\"\"\n\n    vm = rdMolStandardize.RDKitValidation()\n\n    # Don't fix something that is not broken\n    if len(vm.validate(mol)) &gt; 0:\n        if not inplace:\n            mol = copy.copy(mol)\n\n        mol.UpdatePropertyCache(False)\n        for a in mol.GetAtoms():\n            n_electron = (\n                a.GetImplicitValence()\n                + a.GetExplicitValence()\n                - PERIODIC_TABLE.GetDefaultValence(a.GetSymbol())\n            )\n            a.SetFormalCharge(n_electron)\n\n    return mol\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.get_atom_positions","title":"<code>get_atom_positions(mol, conf_id=-1, reorder_to_atom_map_number=False)</code>","text":"<p>Return the atom positions of a given molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <code>conf_id</code> <code>int</code> <p>The conformer ID to set the conformer to.</p> <code>-1</code> <code>reorder_to_atom_map_number</code> <code>bool</code> <p>Whether to reorder the positions to map the atom map numbers given by the <code>molAtomMapNumber</code> atom property.</p> <code>False</code> Source code in <code>datamol/mol.py</code> <pre><code>def get_atom_positions(\n    mol: Mol,\n    conf_id: int = -1,\n    reorder_to_atom_map_number: bool = False,\n) -&gt; np.ndarray:\n\"\"\"Return the atom positions of a given molecule.\n\n    Args:\n        mol: A molecule.\n        conf_id: The conformer ID to set the conformer to.\n        reorder_to_atom_map_number: Whether to reorder the positions to map the\n            atom map numbers given by the `molAtomMapNumber` atom property.\n    \"\"\"\n\n    if mol.GetNumConformers() == 0:\n        raise ValueError(\"This molecule does not have conformers.\")\n\n    if reorder_to_atom_map_number and not all(\n        [\"molAtomMapNumber\" in a.GetPropsAsDict() for a in mol.GetAtoms()]\n    ):\n        raise ValueError(\n            f\"The atoms of the input molecule does not contain the molAtomMapNumber property.\"\n            \"Set it before calling this function or set `from_atom_map_numbers` to `False`.\"\n        )\n\n    conformer = mol.GetConformer(id=conf_id)\n    positions = conformer.GetPositions()\n\n    if reorder_to_atom_map_number:\n        # Remap the rows order in `positions` so it matches\n        # with the atom map numbers.\n        mapped_indices = np.array([a.GetAtomMapNum() for a in mol.GetAtoms()]) - 1\n        positions = positions[mapped_indices, :]\n\n    return positions\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.hash_mol","title":"<code>hash_mol(mol, hash_scheme='all')</code>","text":"<p>Generate a unique hash code for a molecule based on chemistry. If two molecules are chemically \u201cthe same\u201d, they should have the same hash.</p> <p>Using molhash adds value beyond using SMILES because it:</p> <ul> <li>Ignores SMILES features that are not chemically meaningful (e.g. atom map numbers).</li> <li>Canonicalizes enhanced stereochemistry groups. For example <code>C[C@H](O)CC |&amp;1:1|</code> and <code>C[C@@H](O)CC |&amp;1:1|</code> have the same molhash.</li> <li>Canonicalizes S group data (for example, polymer data).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <code>hash_scheme</code> <code>str</code> <p>There are three hash schemes: - \"all\": most strict hash scheme utilizing all layers. - \"no_stereo\": excludes stereo sensitive layers. - \"no_tautomers\": excludes tautomer sensitive layers.</p> <code>'all'</code> <p>Returns:</p> Type Description <code>str</code> <p>The hash as a 40 chars string.</p> Source code in <code>datamol/mol.py</code> <pre><code>def hash_mol(mol: Mol, hash_scheme: str = \"all\") -&gt; str:\n\"\"\"Generate a unique hash code for a molecule based on chemistry. If two molecules are\n    chemically \u201cthe same\u201d, they should have the same hash.\n\n    Using molhash adds value beyond using SMILES because it:\n\n    - Ignores SMILES features that are not chemically meaningful (e.g. atom map numbers).\n    - Canonicalizes enhanced stereochemistry groups. For example `C[C@H](O)CC |&amp;1:1|` and `C[C@@H](O)CC |&amp;1:1|`\n    have the same molhash.\n    - Canonicalizes S group data (for example, polymer data).\n\n    Args:\n        mol: A molecule.\n        hash_scheme: There are three hash schemes:\n            - \"all\": most strict hash scheme utilizing all layers.\n            - \"no_stereo\": excludes stereo sensitive layers.\n            - \"no_tautomers\": excludes tautomer sensitive layers.\n\n    Returns:\n        The hash as a 40 chars string.\n    \"\"\"\n\n    if is_lower_than_current_rdkit_version(\"2022.09\"):\n        raise NotImplementedError(\"`datamol.hash_mol() is only available with RDKit&gt;=2022.09.\")\n\n    from rdkit.Chem import RegistrationHash\n\n    # Compute the mol layers\n    all_layers = RegistrationHash.GetMolLayers(mol)\n\n    # Select the hash scheme\n    if hash_scheme == \"all\":\n        hash_scheme_enum = RegistrationHash.HashScheme.ALL_LAYERS\n    elif hash_scheme == \"no_stereo\":\n        hash_scheme_enum = RegistrationHash.HashScheme.STEREO_INSENSITIVE_LAYERS\n    elif hash_scheme == \"no_tautomers\":\n        hash_scheme_enum = RegistrationHash.HashScheme.TAUTOMER_INSENSITIVE_LAYERS\n    else:\n        raise ValueError(\n            f\"`hash_scheme` is invalid. Please choose from: 'all', 'no_stereo' or 'no_tautomers'.\"\n        )\n\n    # Generate the hash\n    return RegistrationHash.GetMolHash(all_layers=all_layers, hash_scheme=hash_scheme_enum)\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.incorrect_valence","title":"<code>incorrect_valence(a, update=False)</code>","text":"<p>Check if an atom connection is not valid or all the atom of a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Union[Mol, Chem.rdchem.Atom]</code> <p>atom or molecule to check for valence issue.</p> required <code>update</code> <code>bool</code> <p>Update owning molecule property cache first.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the input atom valence is correct.</p> Source code in <code>datamol/mol.py</code> <pre><code>def incorrect_valence(a: Union[Mol, Chem.rdchem.Atom], update: bool = False) -&gt; bool:\n\"\"\"Check if an atom connection is not valid or all the atom of a molecule.\n\n    Args:\n        a: atom or molecule to check for valence issue.\n        update: Update owning molecule property cache first.\n\n    Returns:\n        Whether the input atom valence is correct.\n    \"\"\"\n    if isinstance(a, Mol):\n        a.UpdatePropertyCache(False)\n        vm = rdMolStandardize.RDKitValidation()\n        return len(vm.validate(a)) &gt; 0\n\n    if update:\n        m = a.GetOwningMol()\n        m.UpdatePropertyCache(False)\n    return (a.GetImplicitValence() == 0) and (\n        a.GetExplicitValence() &gt; max(PERIODIC_TABLE.GetValenceList(a.GetSymbol()))\n    )\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.is_transition_metal","title":"<code>is_transition_metal(at)</code>","text":"<p>Check if atom is a transition metal.</p> <p>Parameters:</p> Name Type Description Default <code>at</code> <code>Chem.rdchem.Atom</code> <p>an atom.</p> required Source code in <code>datamol/mol.py</code> <pre><code>def is_transition_metal(at: Chem.rdchem.Atom) -&gt; bool:\n\"\"\"Check if atom is a transition metal.\n\n    Args:\n        at: an atom.\n    \"\"\"\n    n = at.GetAtomicNum()\n    return (n &gt;= 22 and n &lt;= 29) or (n &gt;= 40 and n &lt;= 47) or (n &gt;= 72 and n &lt;= 79)\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.keep_largest_fragment","title":"<code>keep_largest_fragment(mol)</code>","text":"<p>Only keep largest fragment of each molecule.</p> Source code in <code>datamol/mol.py</code> <pre><code>def keep_largest_fragment(mol: Mol) -&gt; Optional[Mol]:\n\"\"\"Only keep largest fragment of each molecule.\"\"\"\n    return max(\n        rdmolops.GetMolFrags(mol, asMols=True),\n        default=mol,\n        key=lambda m: m.GetNumAtoms(),\n    )\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.make_scaffold_generic","title":"<code>make_scaffold_generic(mol, include_bonds=False)</code>","text":"<p>Make the atom in a scaffold or molecule generic.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule or a scaffold.</p> required <code>include_bonds</code> <code>bool</code> <p>Whether we should also update bond order or keep as is.</p> <code>False</code> Source code in <code>datamol/mol.py</code> <pre><code>def make_scaffold_generic(mol: Mol, include_bonds: bool = False):\n\"\"\"Make the atom in a scaffold or molecule generic.\n\n    Args:\n        mol: A molecule or a scaffold.\n        include_bonds: Whether we should also update bond order or keep as is.\n    \"\"\"\n\n    for atom in mol.GetAtoms():\n        if atom.GetAtomicNum() != 1:\n            atom.SetAtomicNum(0)\n\n        atom.SetFormalCharge(0)\n        atom.SetChiralTag(rdchem.ChiralType.CHI_UNSPECIFIED)\n        atom.SetNoImplicit(0)\n        atom.SetNumExplicitHs(0)\n\n    if include_bonds:\n        for bond in mol.GetBonds():\n            bond.SetBondType(UNSPECIFIED_BOND)\n\n    mol.UpdatePropertyCache()\n    Chem.GetSymmSSSR(mol)  # type: ignore\n\n    return mol\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.protect_atoms","title":"<code>protect_atoms(mol, substruct=None, atoms=None, in_place=False)</code>","text":"<p>Protect a list of atoms or substruct in a molecule.</p> <p>The _protected attributes of a molecule is used by RDKit in several functions, especially for reactions where \"protected\" atoms are disallowed from taking part in reactions.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>input molecule to protect</p> required <code>substruct</code> <code>Optional[Mol]</code> <p>optional substructure query to identify atoms to protect</p> <code>None</code> <code>atoms</code> <code>Optional[Union[List[int], int]]</code> <p>optional list of atom indices to protect</p> <code>None</code> <code>in_place</code> <code>bool</code> <p>whether to perform the protection in place or return a copy of the molecule</p> <code>False</code> Source code in <code>datamol/mol.py</code> <pre><code>def protect_atoms(\n    mol: Mol,\n    substruct: Optional[Mol] = None,\n    atoms: Optional[Union[List[int], int]] = None,\n    in_place: bool = False,\n) -&gt; Mol:\n\"\"\"Protect a list of atoms or substruct in a molecule.\n\n    The _protected attributes of a molecule is used by RDKit in several functions, especially for reactions\n    where \"protected\" atoms are disallowed from taking part in reactions.\n\n    Args:\n        mol: input molecule to protect\n        substruct: optional substructure query to identify atoms to protect\n        atoms: optional list of atom indices to protect\n        in_place: whether to perform the protection in place or return a copy of the molecule\n    \"\"\"\n    if atoms is None:\n        atoms = []\n    elif not isinstance(atoms, (tuple, list)):\n        atoms = [atoms]\n\n    # do not perform protection in place\n    if in_place:\n        mol_copy = mol\n    else:\n        mol_copy = copy_mol(mol)\n\n    if substruct is not None:\n        matches = mol_copy.GetSubstructMatches(substruct)\n        atoms.extend(itertools.chain(*matches))\n\n    for a in atoms:\n        if a is None:\n            continue\n        mol_copy.GetAtomWithIdx(a).SetProp(\"_protected\", \"1\")\n\n    return mol_copy\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.randomize_atoms","title":"<code>randomize_atoms(mol)</code>","text":"<p>Randomize the position of the atoms in a mol.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule.</p> required <p>Returns:</p> Name Type Description <code>mol</code> <code>Optional[Mol]</code> <p>a molecule.</p> Source code in <code>datamol/mol.py</code> <pre><code>def randomize_atoms(mol: Mol) -&gt; Optional[Mol]:\n\"\"\"Randomize the position of the atoms in a mol.\n\n    Args:\n        mol: a molecule.\n\n    Returns:\n        mol: a molecule.\n    \"\"\"\n    if mol.GetNumAtoms() == 0:\n        return mol\n\n    atom_indices = list(range(mol.GetNumAtoms()))\n    random.shuffle(atom_indices)\n    return rdmolops.RenumberAtoms(mol, atom_indices)\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.remove_dummies","title":"<code>remove_dummies(mol, dummy='*')</code>","text":"<p>Remove dummy atoms from molecules.</p> Source code in <code>datamol/mol.py</code> <pre><code>def remove_dummies(mol: Mol, dummy: str = \"*\") -&gt; Optional[Mol]:\n\"\"\"Remove dummy atoms from molecules.\"\"\"\n\n    du = to_mol(dummy)\n    out = mol\n\n    try:\n        out = rdmolops.ReplaceSubstructs(mol, du, to_mol(\"[H]\"), True)[0]\n        out = remove_hs(out)\n    except Exception:\n        out = rdmolops.DeleteSubstructs(mol, du)\n    return out\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.remove_hs","title":"<code>remove_hs(mol, implicit_only=False, update_explicit_count=False, sanitize=True)</code>","text":"<p>Removes hydrogens from a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule.</p> required <code>implicit_only</code> <code>bool</code> <p>whether to only remove implicit hydrogens.</p> <code>False</code> <code>update_explicit_count</code> <code>bool</code> <p>whether to update the explicit hydrogen count.</p> <code>False</code> <code>sanitize</code> <code>bool</code> <p>whether to sanitize the molecule after the hydrogens are removed.</p> <code>True</code> Source code in <code>datamol/mol.py</code> <pre><code>def remove_hs(\n    mol: Mol,\n    implicit_only: bool = False,\n    update_explicit_count: bool = False,\n    sanitize: bool = True,\n):\n\"\"\"Removes hydrogens from a molecule.\n\n    Args:\n        mol: a molecule.\n        implicit_only: whether to only remove implicit hydrogens.\n        update_explicit_count: whether to update the explicit hydrogen count.\n        sanitize: whether to sanitize the molecule after the hydrogens are removed.\n    \"\"\"\n    mol = rdmolops.RemoveHs(\n        mol,\n        implicitOnly=implicit_only,\n        updateExplicitCount=update_explicit_count,\n        sanitize=sanitize,\n    )\n\n    return mol\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.reorder_atoms","title":"<code>reorder_atoms(mol, break_ties=True, include_chirality=True, include_isotopes=True)</code>","text":"<p>Reorder the atoms in a mol. It ensures a single atom order for the same molecule, regardless of its original representation.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule.</p> required <code>break_ties</code> <code>bool</code> <p>Force breaking of ranked ties.</p> <code>True</code> <code>include_chirality</code> <code>bool</code> <p>Use chiral information when computing rank.</p> <code>True</code> <code>include_isotopes</code> <code>bool</code> <p>Use isotope information when computing rank.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>mol</code> <code>Optional[Mol]</code> <p>a molecule.</p> Source code in <code>datamol/mol.py</code> <pre><code>def reorder_atoms(\n    mol: Mol,\n    break_ties: bool = True,\n    include_chirality: bool = True,\n    include_isotopes: bool = True,\n) -&gt; Optional[Mol]:\n\"\"\"Reorder the atoms in a mol. It ensures a single atom order for the same molecule,\n    regardless of its original representation.\n\n    Args:\n        mol: a molecule.\n        break_ties: Force breaking of ranked ties.\n        include_chirality: Use chiral information when computing rank.\n        include_isotopes: Use isotope information when computing rank.\n\n    Returns:\n        mol: a molecule.\n    \"\"\"\n    if mol.GetNumAtoms() == 0:\n        return mol\n\n    new_order = rdmolfiles.CanonicalRankAtoms(\n        mol,\n        breakTies=break_ties,\n        includeChirality=include_chirality,\n        includeIsotopes=include_isotopes,\n    )\n    new_order = sorted([(y, x) for x, y in enumerate(new_order)])\n    return rdmolops.RenumberAtoms(mol, [y for (x, y) in new_order])\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.replace_dummies_atoms","title":"<code>replace_dummies_atoms(mol, atom='C', dummy='*', replace_all=True)</code>","text":"<p>Remove dummy atoms from molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>molecule with dummies</p> required <code>atom</code> <code>str</code> <p>replacement atom, default is carbon</p> <code>'C'</code> <code>dummy</code> <code>str</code> <p>dummy atom representation</p> <code>'*'</code> <code>replace_all</code> <code>bool</code> <p>Whether to replace all dummies</p> <code>True</code> <p>Returns:</p> Name Type Description <code>mol</code> <code>Optional[Mol]</code> <p>Molecule with dummy replaced</p> Source code in <code>datamol/mol.py</code> <pre><code>def replace_dummies_atoms(\n    mol: Mol,\n    atom: str = \"C\",\n    dummy: str = \"*\",\n    replace_all: bool = True,\n) -&gt; Optional[Mol]:\n\"\"\"Remove dummy atoms from molecules.\n\n    Args:\n        mol: molecule with dummies\n        atom: replacement atom, default is carbon\n        dummy: dummy atom representation\n        replace_all: Whether to replace all dummies\n\n    Returns:\n        mol: Molecule with dummy replaced\n    \"\"\"\n    du = to_mol(dummy)\n    replacement = to_mol(atom)\n    out = rdmolops.ReplaceSubstructs(mol, du, replacement, replaceAll=replace_all)[0]\n    return out\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.same_mol","title":"<code>same_mol(mol1, mol2, use_non_standard_inchikey=False)</code>","text":"<p>Check two molecules are the same by comparing their InChiKey.</p> <p>Invalid molecules (None) are always considered as not the same.</p> <p>Parameters:</p> Name Type Description Default <code>mol1</code> <code>Optional[Mol]</code> <p>A molecule.</p> required <code>mol2</code> <code>Optional[Mol]</code> <p>A molecule.</p> required <code>use_non_standard_inchikey</code> <code>bool</code> <p>Whether to use the standard or non-standard InChiKey.</p> <code>False</code> Source code in <code>datamol/mol.py</code> <pre><code>def same_mol(\n    mol1: Optional[Mol],\n    mol2: Optional[Mol],\n    use_non_standard_inchikey: bool = False,\n) -&gt; bool:\n\"\"\"Check two molecules are the same by comparing their InChiKey.\n\n    Invalid molecules (None) are always considered as not the same.\n\n    Args:\n        mol1: A molecule.\n        mol2: A molecule.\n        use_non_standard_inchikey: Whether to use the standard or non-standard InChiKey.\n    \"\"\"\n\n    if mol1 is None or mol2 is None:\n        return False\n\n    if use_non_standard_inchikey:\n        return to_inchikey_non_standard(mol1) == to_inchikey_non_standard(mol2)\n    else:\n        return to_inchikey(mol1) == to_inchikey(mol2)\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.sanitize_first","title":"<code>sanitize_first(mols, charge_neutral=False, sanifix=True)</code>","text":"<p>Sanitize a list of molecules and return the first valid molecule seen in the list.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>List[Mol]</code> <p>a list of molecules.</p> required <code>charge_neutral</code> <code>bool</code> <p>whether charge neutralization should be applied.</p> <code>False</code> <code>sanifix</code> <code>bool</code> <p>whether to run the sanifix from James Davidson (sanifix4.py) that try to adjust aromatic nitrogens.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>mol</code> <code>Mol</code> <p>a molecule.</p> Source code in <code>datamol/mol.py</code> <pre><code>def sanitize_first(mols: List[Mol], charge_neutral: bool = False, sanifix: bool = True) -&gt; Mol:\n\"\"\"Sanitize a list of molecules and return the first valid molecule seen in the list.\n\n    Args:\n        mols: a list of molecules.\n        charge_neutral: whether charge neutralization should be applied.\n        sanifix: whether to run the sanifix from James Davidson\n            (sanifix4.py) that try to adjust aromatic nitrogens.\n\n    Returns:\n        mol: a molecule.\n    \"\"\"\n    for mol in mols:\n        mol = sanitize_mol(mol, charge_neutral=charge_neutral, sanifix=sanifix)\n        if mol:\n            return mol\n    return None\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.sanitize_mol","title":"<code>sanitize_mol(mol, charge_neutral=False, sanifix=True, verbose=True, add_hs=False)</code>","text":"<p>An augmented version of RDKit <code>sanitize=True</code>. It uses a mol-SMILES-mol conversion to catch potential aromaticity errors and try to fix aromatic nitrogen (using the popular sanifix4 script). Optionally, it can neutralize the charge of the molecule.</p> <p>Note #1: Only the first conformer (if present) will be preserved and a warning will be displayed if more than one conformer is detected.</p> <p>Note #2: The molecule's properties will be preserved but the atom's properties will be lost.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>a molecule.</p> required <code>charge_neutral</code> <code>bool</code> <p>whether charge neutralization should be applied.</p> <code>False</code> <code>sanifix</code> <code>bool</code> <p>whether to run the sanifix from James Davidson (sanifix4.py) that try to adjust aromatic nitrogens.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Whether displaying a warning about multiple conformers.</p> <code>True</code> <code>add_hs</code> <code>bool</code> <p>Add hydrogens to the returned molecule. Useful when the input molecule already contains hydrogens.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>mol</code> <code>Optional[Mol]</code> <p>a molecule.</p> Source code in <code>datamol/mol.py</code> <pre><code>def sanitize_mol(\n    mol: Mol,\n    charge_neutral: bool = False,\n    sanifix: bool = True,\n    verbose: bool = True,\n    add_hs: bool = False,\n) -&gt; Optional[Mol]:\n\"\"\"An augmented version of RDKit `sanitize=True`. It uses a\n    mol-SMILES-mol conversion to catch potential aromaticity errors\n    and try to fix aromatic nitrogen (using the popular sanifix4 script).\n    Optionally, it can neutralize the charge of the molecule.\n\n    Note #1: Only the first conformer (if present) will be preserved and\n    a warning will be displayed if more than one conformer is detected.\n\n    Note #2: The molecule's properties will be preserved but the atom's\n    properties will be lost.\n\n    Args:\n        mol: a molecule.\n        charge_neutral: whether charge neutralization should be applied.\n        sanifix: whether to run the sanifix from James Davidson\n            (sanifix4.py) that try to adjust aromatic nitrogens.\n        verbose: Whether displaying a warning about multiple conformers.\n        add_hs: Add hydrogens to the returned molecule. Useful when the input\n            molecule already contains hydrogens.\n\n    Returns:\n        mol: a molecule.\n    \"\"\"\n    if mol is None:\n        return mol\n\n    # Extract properties.\n    original_mol = copy_mol(mol)\n    properties = original_mol.GetPropsAsDict()\n\n    if charge_neutral:\n        mol = to_neutral(mol)\n\n    if sanifix:\n        mol = _sanifix4.sanifix(mol)\n\n    if mol is not None:\n        # Detect multiple conformers\n        if verbose and mol.GetNumConformers() &gt; 1:\n            logger.warning(\n                f\"The molecule contains multiple conformers. Only the first one will be preserved.\"\n            )\n\n        # Try catch to avoid occasional aromaticity errors\n        try:\n            # `cxsmiles` is used here to preserve the first conformer.\n            mol = to_mol(to_smiles(mol, cxsmiles=True), sanitize=True, add_hs=add_hs)\n        except Exception:\n            mol = None\n\n    if mol is not None:\n        # Insert back properties.\n        mol = set_mol_props(mol, properties)\n\n    return mol\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.sanitize_smiles","title":"<code>sanitize_smiles(smiles, isomeric=True)</code>","text":"<p>Takes SMILES string and returns its sanitized version.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>Optional[str]</code> <p>smiles to be sanitized.</p> required <code>isomeric</code> <code>bool</code> <p>Whether to include information about stereochemistry in the SMILES.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>sanitized smiles.</p> Source code in <code>datamol/mol.py</code> <pre><code>def sanitize_smiles(smiles: Optional[str], isomeric: bool = True) -&gt; Optional[str]:\n\"\"\"Takes SMILES string and returns its sanitized version.\n\n    Args:\n        smiles: smiles to be sanitized.\n        isomeric: Whether to include information about stereochemistry in the SMILES.\n\n    Returns:\n        sanitized smiles.\n    \"\"\"\n\n    mol = None\n\n    try:\n        mol = to_mol(smiles, sanitize=False)\n        mol = sanitize_mol(mol, False)\n    except Exception:\n        return None\n\n    if mol is None:\n        return None\n\n    try:\n        smiles = to_smiles(mol, isomeric=isomeric)\n    except:\n        return None\n\n    return smiles\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.set_atom_positions","title":"<code>set_atom_positions(mol, positions, conf_id=0, copy=True, use_atom_map_numbers=True, remove_previous_conformers=True)</code>","text":"<p>Add a conformer to a molecule given the atom's positions.</p> <p>The conformer 3D flag is automatically set if all the z coordinates are 0.</p> <p>Example:</p> <p>The below example is common when you want to reconstruct a molecule object from its SMILES and its held out atomic positions. The position array is ordered according to the atom number seen in the SMILES. This is a common data structure when working with Quantum Mechanics dataset.</p> <pre><code>import datamol as dm\nimport numpy as np\n\n# We start with a SMILES where every atoms is mapped to a specific number\nsmiles = \"[H:14][c:5]1[c:3]([c:7]([c:4]([c:6]([c:8]1[N:10]([H:18])[C:2](=[N+:11]([H:19])[H:20])[N:9]([H:16])[H:17])[H:15])[H:13])[F:1])[H:12]\"\n\n# Every atom position below is mapped to the atom number in the SMILES above\npositions = [\n    [1.7, -6.67, 3.15],\n    [0.2, 4.72, 0.78],\n    [3.54, -2.64, 2.88],\n    [0.43, -3.87, -0.09],\n    [3.44, -0.2, 1.8],\n    [0.02, -1.5, -1.0],\n    [2.12, -4.54, 1.9],\n    [1.5, 0.48, 0.02],\n    [0.53, 7.24, 0.25],\n    [1.17, 2.91, -0.85],\n    [-1.22, 4.15, 2.71],\n    [4.64, -3.24, 4.55],\n    [-0.89, -5.43, -0.78],\n    [4.52, 1.43, 2.45],\n    [-1.45, -1.02, -2.48],\n    [-0.15, 8.68, 1.38],\n    [1.65, 7.88, -1.21],\n    [2.24, 3.64, -2.15],\n    [-1.96, 2.4, 3.0],\n    [-2.02, 5.59, 3.71],\n]\n\n# We build the mol object by setting `remove_hs` to `False`.\n# This is important so the hydrogens and their atom number are preserved.\nmol = dm.to_mol(smiles, remove_hs=False)\n\n# If you plot the molecule with `dm.to_image(mol)`, you'll notice\n# the atom numbers are added to the drawing.\n\n# Now we set the atom positions to the newly constructed `mol` object.\n# Here it's important to set `use_atom_map_numbers` to `True`, so the atom numbers\n# from the SMILES are used to match the input positions array.\n# Under the hood, RDKit has set the `molAtomMapNumber` property to all the atoms in the\n# molecule.\nnew_mol = dm.set_atom_positions(\n    mol=mol,\n    positions=positions,\n    conf_id=0,\n    use_atom_map_numbers=True,\n)\n\n# The newly set conformer now had the correct 3D positions.\n# You can visualize the molecule with `dm.to_image(new_mol)` in 2D\n# or `dm.viz.conformers(new_mol)`.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <code>positions</code> <code>npt.ArrayLike</code> <p>An array or a list of atomic positions. Shape of <code>[n_atoms, 3]</code>.</p> required <code>conf_id</code> <code>int</code> <p>The conformer ID to set the conformer to.</p> <code>0</code> <code>copy</code> <code>bool</code> <p>Whether to copy the molecule.</p> <code>True</code> <code>use_atom_map_numbers</code> <code>bool</code> <p>Whether to input positions are ordered given the atom mapped numbers set in the <code>molAtomMapNumber</code> atom property keys. If set to False, the default atom indices order is assumed.</p> <code>True</code> <code>remove_previous_conformers</code> <code>bool</code> <p>Whether to remove the previous conformers if any in the input molecule.</p> <code>True</code> Source code in <code>datamol/mol.py</code> <pre><code>def set_atom_positions(\n    mol: Mol,\n    positions: npt.ArrayLike,\n    conf_id: int = 0,\n    copy: bool = True,\n    use_atom_map_numbers: bool = True,\n    remove_previous_conformers: bool = True,\n) -&gt; Mol:\n\"\"\"Add a conformer to a molecule given the atom's positions.\n\n    The conformer 3D flag is automatically set if all the z coordinates are 0.\n\n    **Example:**\n\n    The below example is common when you want to reconstruct a molecule object\n    from its SMILES and its held out atomic positions. The position array\n    is ordered according to the atom number seen in the SMILES. This is a common\n    data structure when working with Quantum Mechanics dataset.\n\n    ```python\n\n    import datamol as dm\n    import numpy as np\n\n    # We start with a SMILES where every atoms is mapped to a specific number\n    smiles = \"[H:14][c:5]1[c:3]([c:7]([c:4]([c:6]([c:8]1[N:10]([H:18])[C:2](=[N+:11]([H:19])[H:20])[N:9]([H:16])[H:17])[H:15])[H:13])[F:1])[H:12]\"\n\n    # Every atom position below is mapped to the atom number in the SMILES above\n    positions = [\n        [1.7, -6.67, 3.15],\n        [0.2, 4.72, 0.78],\n        [3.54, -2.64, 2.88],\n        [0.43, -3.87, -0.09],\n        [3.44, -0.2, 1.8],\n        [0.02, -1.5, -1.0],\n        [2.12, -4.54, 1.9],\n        [1.5, 0.48, 0.02],\n        [0.53, 7.24, 0.25],\n        [1.17, 2.91, -0.85],\n        [-1.22, 4.15, 2.71],\n        [4.64, -3.24, 4.55],\n        [-0.89, -5.43, -0.78],\n        [4.52, 1.43, 2.45],\n        [-1.45, -1.02, -2.48],\n        [-0.15, 8.68, 1.38],\n        [1.65, 7.88, -1.21],\n        [2.24, 3.64, -2.15],\n        [-1.96, 2.4, 3.0],\n        [-2.02, 5.59, 3.71],\n    ]\n\n    # We build the mol object by setting `remove_hs` to `False`.\n    # This is important so the hydrogens and their atom number are preserved.\n    mol = dm.to_mol(smiles, remove_hs=False)\n\n    # If you plot the molecule with `dm.to_image(mol)`, you'll notice\n    # the atom numbers are added to the drawing.\n\n    # Now we set the atom positions to the newly constructed `mol` object.\n    # Here it's important to set `use_atom_map_numbers` to `True`, so the atom numbers\n    # from the SMILES are used to match the input positions array.\n    # Under the hood, RDKit has set the `molAtomMapNumber` property to all the atoms in the\n    # molecule.\n    new_mol = dm.set_atom_positions(\n        mol=mol,\n        positions=positions,\n        conf_id=0,\n        use_atom_map_numbers=True,\n    )\n\n    # The newly set conformer now had the correct 3D positions.\n    # You can visualize the molecule with `dm.to_image(new_mol)` in 2D\n    # or `dm.viz.conformers(new_mol)`.\n    ```\n\n    Args:\n        mol: A molecule.\n        positions: An array or a list of atomic positions. Shape of `[n_atoms, 3]`.\n        conf_id: The conformer ID to set the conformer to.\n        copy: Whether to copy the molecule.\n        use_atom_map_numbers: Whether to input positions are ordered given the atom mapped\n            numbers set in the `molAtomMapNumber` atom property keys. If set to False,\n            the default atom indices order is assumed.\n        remove_previous_conformers: Whether to remove the previous conformers if any in the input molecule.\n    \"\"\"\n\n    if copy:\n        mol = copy_mol(mol)\n\n    # Convert to an array\n    positions = np.array(positions)\n\n    # Perform a few sanity checks\n\n    if positions.ndim != 2:\n        raise ValueError(f\"The positions array is not of dimension 2. Found: {positions.ndim}.\")\n\n    excpected_shape = (mol.GetNumAtoms(), 3)\n    if positions.shape != excpected_shape:\n        raise ValueError(\n            f\"The shape of `positions` is {positions.shape} instead of {excpected_shape}.\"\n        )\n\n    if use_atom_map_numbers and not all(\n        [\"molAtomMapNumber\" in a.GetPropsAsDict() for a in mol.GetAtoms()]\n    ):\n        raise ValueError(\n            f\"The atoms of the input molecule does not contain the molAtomMapNumber property.\"\n            \"Set it before calling this function or set `from_atom_map_numbers` to `False`.\"\n        )\n\n    # Remove previous conformers\n    if remove_previous_conformers:\n        mol.RemoveAllConformers()\n\n    # Remap the rows order in `positions` so it matches\n    # with the atom map numbers.\n    if use_atom_map_numbers:\n        mapped_indices = np.array([a.GetAtomMapNum() for a in mol.GetAtoms()]) - 1\n        positions = positions[mapped_indices, :]\n\n    # Check if it's 3D or 2D coords\n    is_3d = not np.all(positions[:, 2] == 0)\n\n    # Create the conformer object\n    conf = rdchem.Conformer()\n    conf.Set3D(is_3d)\n    conf.SetId(conf_id)\n\n    # Set the positions\n    for i, xyz in enumerate(positions):\n        conf.SetAtomPosition(i, rdGeometry.Point3D(*xyz.tolist()))\n\n    # Add the conformer to the molecule\n    mol.AddConformer(conf)\n\n    return mol\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.set_dative_bonds","title":"<code>set_dative_bonds(mol, from_atoms=(7, 8))</code>","text":"<p>Replaces some single bonds between metals and atoms with atomic numbers in fromAtoms with dative bonds. The replacement is only done if the atom has \"too many\" bonds.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>molecule with bond to modify</p> required <code>from_atoms</code> <code>Tuple[int, int]</code> <p>List of atoms  (symbol or atomic number) to consider for bond replacement. By default, only Nitrogen (7) and Oxygen (8) are considered.</p> <code>(7, 8)</code> <p>Returns:</p> Type Description <code>Optional[Mol]</code> <p>The modified molecule.</p> Source code in <code>datamol/mol.py</code> <pre><code>def set_dative_bonds(mol: Mol, from_atoms: Tuple[int, int] = (7, 8)) -&gt; Optional[Mol]:\n\"\"\"Replaces some single bonds between metals and atoms with atomic numbers in fromAtoms\n    with dative bonds. The replacement is only done if the atom has \"too many\" bonds.\n\n    Arguments:\n        mol: molecule with bond to modify\n        from_atoms: List of atoms  (symbol or atomic number) to consider for bond replacement.\n            By default, only Nitrogen (7) and Oxygen (8) are considered.\n\n    Returns:\n        The modified molecule.\n    \"\"\"\n    rwmol = rdchem.RWMol(mol)\n    rwmol.UpdatePropertyCache(strict=False)\n\n    metals = [at for at in rwmol.GetAtoms() if is_transition_metal(at)]\n    for metal in metals:\n        for nbr in metal.GetNeighbors():\n            if (nbr.GetAtomicNum() in from_atoms or nbr.GetSymbol() in from_atoms) and (\n                nbr.GetExplicitValence() &gt; PERIODIC_TABLE.GetDefaultValence(nbr.GetAtomicNum())\n                and rwmol.GetBondBetweenAtoms(nbr.GetIdx(), metal.GetIdx()).GetBondType()\n                == SINGLE_BOND\n            ):\n                rwmol.RemoveBond(nbr.GetIdx(), metal.GetIdx())\n                rwmol.AddBond(nbr.GetIdx(), metal.GetIdx(), DATIVE_BOND)\n    return rwmol\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.set_mol_props","title":"<code>set_mol_props(mol, props, copy=False)</code>","text":"<p>Set properties to a mol from a dict.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>the mol where to copy the props.</p> required <code>props</code> <code>Dict[str, Any]</code> <p>the props to copy.</p> required <code>copy</code> <code>bool</code> <p>whether to copy the provided mol</p> <code>False</code> Source code in <code>datamol/mol.py</code> <pre><code>def set_mol_props(\n    mol: Mol,\n    props: Dict[str, Any],\n    copy: bool = False,\n) -&gt; Mol:\n\"\"\"Set properties to a mol from a dict.\n\n    Args:\n        mol: the mol where to copy the props.\n        props: the props to copy.\n        copy: whether to copy the provided mol\n\n    \"\"\"\n\n    if copy is True:\n        mol = copy_mol(mol)\n\n    for k, v in props.items():\n        if isinstance(v, bool):\n            mol.SetBoolProp(k, v)\n        elif isinstance(v, int):\n            # NOTE(hadim): A Python integer is 32 bits and RDKit seems\n            # to overflow before that. Here we catch the error\n            # and instead uses silently `SetDoubleProp` instead.\n            try:\n                mol.SetIntProp(k, v)\n            except OverflowError:\n                mol.SetDoubleProp(k, v)\n        elif isinstance(v, float):\n            mol.SetDoubleProp(k, v)\n        else:\n            mol.SetProp(k, str(v))\n\n    return mol\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.standardize_mol","title":"<code>standardize_mol(mol, disconnect_metals=False, normalize=True, reionize=True, uncharge=False, stereo=True)</code>","text":"<p>This function returns a standardized version the given molecule. It relies on the RDKit <code>rdMolStandardize</code> module which is largely inspired from MolVS.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule to standardize.</p> required <code>disconnect_metals</code> <code>bool</code> <p>Disconnect metals that are defined as covalently bonded to non-metal. Depending on the source of the database, some compounds may be reported in salt form or associated to metallic ions (e.g. the sodium salt of a carboxylic compound). In most cases, these counter-ions are not relevant so the use of this function is required before further utilization of the dataset. In summary the process is the following:</p> <ul> <li>Break covalent bonds between metals and organic atoms under certain conditions.</li> <li>First, disconnect N, O, F from any metal. Then disconnect other non-metals from transition metals (with exceptions).</li> <li>For every bond broken, adjust the charges of the begin and end atoms accordingly.</li> </ul> <code>False</code> <code>normalize</code> <code>bool</code> <p>Applies a series of standard transformations to correct functional groups and recombine charges. It corrects drawing errors and standardizes functional groups in the molecule as well as ensuring the overall proper charge of the compound. It includes:</p> <ul> <li>Uncharge-separate sulfones</li> <li>Charge-separate nitro groups</li> <li>Charge-separate pyridine oxide</li> <li>Charge-separate azide</li> <li>Charge-separate diazo and azo groups</li> <li>Charge-separate sulfoxides</li> <li>Hydrazine-diazonium system</li> </ul> <code>True</code> <code>reionize</code> <code>bool</code> <p>If one or more acidic functionalities are present in the molecule, this option ensures the correct neutral/ionized state for such functional groups. Molecules are uncharged by adding and/or removing hydrogens. For zwitterions, hydrogens are moved to eliminate charges where possible. However, in cases where there is a positive charge that is not neutralizable, an attempt is made to also preserve the corresponding negative charge The algorithm works as follows:</p> <ul> <li>Use SMARTS to find the strongest protonated acid and the weakest ionized acid.</li> <li>If the ionized acid is weaker than the protonated acid, swap proton and repeat.</li> </ul> <code>True</code> <code>uncharge</code> <code>bool</code> <p>This option neutralize the molecule by reversing the protonation state of protonated and deprotonated groups, if present (e.g. a carboxylate is re-protonated to the corresponding carboxylic acid). In cases where there is a positive charge that is not neutralizable, an attempt is made to also preserve the corresponding negative charge to ensure a net zero charge.</p> <code>False</code> <code>stereo</code> <code>bool</code> <p>Stereochemical information is corrected and/or added if missing using built-in RDKit functionality to force a clean recalculation of stereochemistry (<code>AssignStereochemistry</code>).</p> <code>True</code> <p>Returns:</p> Name Type Description <code>mol</code> <code>Mol</code> <p>A standardized molecule.</p> Source code in <code>datamol/mol.py</code> <pre><code>def standardize_mol(\n    mol: Mol,\n    disconnect_metals: bool = False,\n    normalize: bool = True,\n    reionize: bool = True,\n    uncharge: bool = False,\n    stereo: bool = True,\n) -&gt; Mol:\nr\"\"\"\n    This function returns a standardized version the given molecule. It relies on the\n    RDKit [`rdMolStandardize` module](https://www.rdkit.org/docs/source/rdkit.Chem.MolStandardize.rdMolStandardize.html)\n    which is largely inspired from [MolVS](https://github.com/mcs07/MolVS).\n\n    Arguments:\n        mol: A molecule to standardize.\n\n        disconnect_metals: Disconnect metals that are defined as covalently bonded to non-metal.\n            Depending on the source of the database, some compounds may be reported in salt form\n            or associated to metallic ions (e.g. the sodium salt of a carboxylic compound).\n            In most cases, these counter-ions are not relevant so the use of this function is required\n            before further utilization of the dataset. In summary the process is the following:\n\n            - Break covalent bonds between metals and organic atoms under certain conditions.\n            - First, disconnect N, O, F from any metal. Then disconnect other non-metals from transition metals (with exceptions).\n            - For every bond broken, adjust the charges of the begin and end atoms accordingly.\n\n        normalize: Applies a series of standard transformations to correct functional groups and recombine charges.\n            It corrects drawing errors and standardizes functional groups in the molecule as well as ensuring the\n            overall proper charge of the compound. It includes:\n\n            - Uncharge-separate sulfones\n            - Charge-separate nitro groups\n            - Charge-separate pyridine oxide\n            - Charge-separate azide\n            - Charge-separate diazo and azo groups\n            - Charge-separate sulfoxides\n            - Hydrazine-diazonium system\n\n        reionize: If one or more acidic functionalities are present in the molecule, this option ensures the correct\n            neutral/ionized state for such functional groups. Molecules are uncharged by adding and/or removing hydrogens.\n            For zwitterions, hydrogens are moved to eliminate charges where possible. However, in cases where there is a\n            positive charge that is not neutralizable, an attempt is made to also preserve the corresponding negative charge\n            The algorithm works as follows:\n\n            - Use SMARTS to find the strongest protonated acid and the weakest ionized acid.\n            - If the ionized acid is weaker than the protonated acid, swap proton and repeat.\n\n        uncharge: This option neutralize the molecule by reversing the protonation state of protonated and deprotonated groups,\n            if present (e.g. a carboxylate is re-protonated to the corresponding carboxylic acid).\n            In cases where there is a positive charge that is not neutralizable, an attempt is made to also preserve the\n            corresponding negative charge to ensure a net zero charge.\n\n        stereo: Stereochemical information is corrected and/or added if missing using built-in RDKit functionality to force a clean recalculation of stereochemistry (`AssignStereochemistry`).\n\n    Returns:\n        mol: A standardized molecule.\n    \"\"\"\n    mol = copy_mol(mol)\n\n    if disconnect_metals:\n        md = rdMolStandardize.MetalDisconnector()\n        mol = md.Disconnect(mol)\n\n    if normalize:\n        mol = rdMolStandardize.Normalize(mol)\n\n    if reionize:\n        reionizer = rdMolStandardize.Reionizer()\n        mol = reionizer.reionize(mol)\n\n    if uncharge:\n        uncharger = rdMolStandardize.Uncharger()\n        mol = uncharger.uncharge(mol)\n\n    if stereo:\n        rdmolops.AssignStereochemistry(mol, force=False, cleanIt=True)\n\n    return mol\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.standardize_smiles","title":"<code>standardize_smiles(smiles, tautomer=False)</code>","text":"<p>Apply smile standardization procedure. This is a convenient function wrapped arrounf RDKit smiles standardizer and tautomeric canonicalization.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>str</code> <p>Smiles to standardize</p> required <code>tautomer</code> <code>bool</code> <p>Whether to canonicalize tautomers</p> <code>False</code> <p>Returns:</p> Name Type Description <code>standard_smiles</code> <code>str</code> <p>the standardized smiles</p> Source code in <code>datamol/mol.py</code> <pre><code>def standardize_smiles(smiles: str, tautomer: bool = False) -&gt; str:\nr\"\"\"\n    Apply smile standardization procedure. This is a convenient function wrapped arrounf RDKit\n    smiles standardizer and tautomeric canonicalization.\n\n    Args:\n        smiles: Smiles to standardize\n        tautomer: Whether to canonicalize tautomers\n\n    Returns:\n        standard_smiles: the standardized smiles\n    \"\"\"\n\n    smiles = rdMolStandardize.StandardizeSmiles(smiles)\n    if tautomer:\n        smiles = canonicalize_tautomer_smiles(smiles)\n    return smiles\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.strip_mol_to_core","title":"<code>strip_mol_to_core(mol, bond_cutter=None)</code>","text":"<p>Strip a molecule to its core, i.e. remove all atoms not in the core. This method 'guess' the molecular core, by finding the ring system.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <code>bond_cutter</code> <code>Mol</code> <p>A molecule used to cut the bonds.</p> <code>None</code> Source code in <code>datamol/mol.py</code> <pre><code>def strip_mol_to_core(mol: Mol, bond_cutter: Mol = None):\n\"\"\"Strip a molecule to its core, i.e. remove all atoms not in the core.\n    This method 'guess' the molecular core, by finding the ring system.\n\n    Args:\n        mol: A molecule.\n        bond_cutter: A molecule used to cut the bonds.\n    \"\"\"\n\n    if bond_cutter is None:\n        bond_cutter = from_smarts(\"[R;!$(*=,#[!#6])]!@!=!#[*;$([A;!R][A;!R])]\")\n\n    with without_rdkit_log():\n        scaffold = MurckoScaffold.GetScaffoldForMol(mol)\n        out = mol.GetSubstructMatches(bond_cutter)\n        bond_inds = [mol.GetBondBetweenAtoms(i, j).GetIdx() for i, j in out]\n\n        if len(bond_inds) &gt; 0:\n            fragmented = rdmolops.FragmentOnBonds(mol, bond_inds)\n            fragmented = remove_dummies(fragmented)\n            fragmented = to_scaffold_murcko(fragmented)\n            scaffold = keep_largest_fragment(fragmented)\n\n    return scaffold\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.substructure_matching_bonds","title":"<code>substructure_matching_bonds(mol, query, **kwargs)</code>","text":"<p>Perform a substructure match using <code>GetSubstructMatches</code> but instead of returning only the atom indices also return the bond indices.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <code>query</code> <code>Mol</code> <p>A molecule used as a query to match against.</p> required <code>**kwargs</code> <code>Any</code> <p>Any other arguments to pass to <code>mol.GetSubstructMatches()</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>atom_matches</code> <code>list</code> <p>A list of lists of atom indices.</p> <code>bond_matches</code> <code>list</code> <p>A list of lists of bond indices.</p> Source code in <code>datamol/mol.py</code> <pre><code>def substructure_matching_bonds(mol: Mol, query: Mol, **kwargs: Any) -&gt; Tuple[list, list]:\n\"\"\"Perform a substructure match using `GetSubstructMatches` but instead\n    of returning only the atom indices also return the bond indices.\n\n    Args:\n        mol: A molecule.\n        query: A molecule used as a query to match against.\n        **kwargs: Any other arguments to pass to `mol.GetSubstructMatches()`.\n\n    Returns:\n        atom_matches: A list of lists of atom indices.\n        bond_matches: A list of lists of bond indices.\n    \"\"\"\n\n    # NOTE(hadim): If more substructure functions are added here, consider moving it to\n    # a dedicated `substructure` module.\n\n    # Set default arguments\n    kwargs.setdefault(\"uniquify\", True)\n\n    # Get the matching atom indices\n    atom_matches = list(mol.GetSubstructMatches(query, **kwargs))\n\n    # Get the bond to highligh from the query\n    query_bond_indices = [\n        (bond.GetBeginAtomIdx(), bond.GetEndAtomIdx()) for bond in query.GetBonds()\n    ]\n\n    # Retrieve the atom indices\n    query_atom_indices = [atom.GetIdx() for i, atom in enumerate(query.GetAtoms())]\n\n    bond_matches = []\n\n    for match in atom_matches:\n        # Map the atom of the query to the atom of the mol matching the query\n        atom_map = dict(zip(query_atom_indices, match))\n\n        # For this match atoms we now, we use the map to retrieve the matching bonds\n        # in the mol.\n        mol_bond_indices = [(atom_map[a1], atom_map[a2]) for a1, a2 in query_bond_indices]\n\n        # Convert the bond atom indices to bond indices\n        mol_bond_indices = [mol.GetBondBetweenAtoms(a1, a2).GetIdx() for a1, a2 in mol_bond_indices]\n\n        bond_matches.append(mol_bond_indices)\n\n    return atom_matches, bond_matches\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.to_mol","title":"<code>to_mol(mol, add_hs=False, explicit_only=False, ordered=False, kekulize=False, sanitize=True, allow_cxsmiles=True, parse_name=True, remove_hs=True, strict_cxsmiles=True)</code>","text":"<p>Convert an input molecule (smiles representation) into a <code>Mol</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[str, Mol]</code> <p>A SMILES or a molecule.</p> required <code>add_hs</code> <code>bool</code> <p>Whether hydrogens should be added the molecule after the SMILES has been parsed.</p> <code>False</code> <code>explicit_only</code> <code>bool</code> <p>Whether to only add explicit hydrogen or both (implicit and explicit). when <code>add_hs</code> is set to True.</p> <code>False</code> <code>ordered</code> <code>bool</code> <p>Whether the atom should be ordered. This option is important if you want to ensure that the features returned will always maintain a single atom order for the same molecule, regardless of its original SMILES representation.</p> <code>False</code> <code>kekulize</code> <code>bool</code> <p>Whether to perform kekulization of the input molecules.</p> <code>False</code> <code>sanitize</code> <code>bool</code> <p>Whether to apply rdkit sanitization when input is a SMILES.</p> <code>True</code> <code>allow_cxsmiles</code> <code>bool</code> <p>Recognize and parse CXSMILES.</p> <code>True</code> <code>parse_name</code> <code>bool</code> <p>Parse (and set) the molecule name as well.</p> <code>True</code> <code>remove_hs</code> <code>bool</code> <p>Wether to remove the hydrogens from the input SMILES.</p> <code>True</code> <code>strict_cxsmiles</code> <code>bool</code> <p>Throw an exception if the CXSMILES parsing fails.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>mol</code> <code>Optional[Mol]</code> <p>the molecule if some conversion have been made. If the conversion fails</p> <code>Optional[Mol]</code> <p>None is returned so make sure that you handle this case on your own.</p> Source code in <code>datamol/mol.py</code> <pre><code>def to_mol(\n    mol: Union[str, Mol],\n    add_hs: bool = False,\n    explicit_only: bool = False,\n    ordered: bool = False,\n    kekulize: bool = False,\n    sanitize: bool = True,\n    allow_cxsmiles: bool = True,\n    parse_name: bool = True,\n    remove_hs: bool = True,\n    strict_cxsmiles: bool = True,\n) -&gt; Optional[Mol]:\n\"\"\"Convert an input molecule (smiles representation) into a `Mol`.\n\n    Args:\n        mol: A SMILES or a molecule.\n        add_hs: Whether hydrogens should be added the molecule after the SMILES has been parsed.\n        explicit_only: Whether to only add explicit hydrogen or both\n            (implicit and explicit). when `add_hs` is set to True.\n        ordered: Whether the atom should be ordered. This option is\n            important if you want to ensure that the features returned will always maintain\n            a single atom order for the same molecule, regardless of its original SMILES representation.\n        kekulize: Whether to perform kekulization of the input molecules.\n        sanitize: Whether to apply rdkit sanitization when input is a SMILES.\n        allow_cxsmiles: Recognize and parse CXSMILES.\n        parse_name: Parse (and set) the molecule name as well.\n        remove_hs: Wether to remove the hydrogens from the input SMILES.\n        strict_cxsmiles: Throw an exception if the CXSMILES parsing fails.\n\n    Returns:\n        mol: the molecule if some conversion have been made. If the conversion fails\n        None is returned so make sure that you handle this case on your own.\n    \"\"\"\n\n    if not isinstance(mol, (str, Mol)):\n        raise ValueError(f\"Input should be a Mol or a string instead of '{type(mol)}'\")\n\n    if isinstance(mol, str):\n        smiles_params = rdmolfiles.SmilesParserParams()\n        smiles_params.sanitize = sanitize\n        smiles_params.allowCXSMILES = allow_cxsmiles\n        smiles_params.parseName = parse_name\n        smiles_params.removeHs = remove_hs\n        smiles_params.strictCXSMILES = strict_cxsmiles\n\n        _mol = rdmolfiles.MolFromSmiles(mol, params=smiles_params)\n\n        if not sanitize and _mol is not None:\n            _mol.UpdatePropertyCache(False)\n    else:\n        _mol = mol\n\n    # Add hydrogens\n    if _mol is not None and add_hs:\n        _mol = rdmolops.AddHs(_mol, explicitOnly=explicit_only, addCoords=True)\n\n    # Reorder atoms\n    if _mol is not None and ordered:\n        _mol = reorder_atoms(_mol)\n\n    if _mol is not None and kekulize:\n        rdmolops.Kekulize(_mol, clearAromaticFlags=False)\n\n    return _mol\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.to_neutral","title":"<code>to_neutral(mol)</code>","text":"<p>Neutralize the charge of a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Optional[Mol]</code> <p>a molecule.</p> required <p>Returns:</p> Name Type Description <code>mol</code> <code>Optional[Mol]</code> <p>a molecule.</p> Source code in <code>datamol/mol.py</code> <pre><code>def to_neutral(mol: Optional[Mol]) -&gt; Optional[Mol]:\n\"\"\"Neutralize the charge of a molecule.\n\n    Args:\n        mol: a molecule.\n\n    Returns:\n        mol: a molecule.\n    \"\"\"\n    if mol is None:\n        return mol\n\n    for a in mol.GetAtoms():\n        if a.GetFormalCharge() &lt; 0 or (\n            a.GetExplicitValence() &gt;= PERIODIC_TABLE.GetDefaultValence(a.GetSymbol())\n            and a.GetFormalCharge() &gt; 0\n        ):\n            a.SetFormalCharge(0)\n            a.UpdatePropertyCache(False)\n    return mol\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.to_scaffold_murcko","title":"<code>to_scaffold_murcko(mol, make_generic=False)</code>","text":"<p>Extract the Murcko scaffold from a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required <code>make_generic</code> <code>bool</code> <p>Whether to make the scaffold generic.</p> <code>False</code> Source code in <code>datamol/mol.py</code> <pre><code>def to_scaffold_murcko(mol: Mol, make_generic: bool = False):\n\"\"\"Extract the Murcko scaffold from a molecule.\n\n    Args:\n        mol: A molecule.\n        make_generic: Whether to make the scaffold generic.\n    \"\"\"\n    scf = MurckoScaffold.GetScaffoldForMol(mol)\n\n    # NOTE(hadim): this is already done in `GetScaffoldForMol`\n    # Note sure we need it here.\n    scf.UpdatePropertyCache()\n    Chem.GetSymmSSSR(scf)  # type: ignore\n\n    if make_generic:\n        scf = make_scaffold_generic(scf)\n        scf = to_mol(scf)\n\n    return scf\n</code></pre>"},{"location":"api/datamol.mol.html#datamol.mol.unique_id","title":"<code>unique_id(mol)</code>","text":"<p>A datamol unique molecule ID.</p> <p>The ID is an MD5 hash of the non-standard InChiKey provided by <code>dm.to_inchikey_non_standard()</code>. It guarantees uniqueness for different tautomeric forms of the same molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>A molecule.</p> required Source code in <code>datamol/mol.py</code> <pre><code>def unique_id(mol: Mol) -&gt; Optional[str]:\n\"\"\"A datamol unique molecule ID.\n\n    The ID is an MD5 hash of the non-standard InChiKey provided\n    by `dm.to_inchikey_non_standard()`. It guarantees uniqueness for\n    different tautomeric forms of the same molecule.\n\n    Args:\n        mol: A molecule.\n    \"\"\"\n    ik = to_inchikey_non_standard(mol)\n\n    if ik is None:\n        return None\n\n    return hashlib.md5(ik.encode(\"utf-8\")).hexdigest()\n</code></pre>"},{"location":"api/datamol.molar.html","title":"<code>datamol.molar</code>","text":"<p>A set of utility functions to convert between various units and formats used in drug discovery.</p>"},{"location":"api/datamol.molar.html#datamol.molar.log_to_molar","title":"<code>log_to_molar(values, unit)</code>","text":"<p>Convert a log-scaled molar concentration (pXC50 for example) to its unscaled value (XC50).</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Union[float, Iterable[float], np.ndarray]</code> <p>A log-scaled molar concentration (can be a scalar, a list or an array).</p> required <code>unit</code> <code>str</code> <p>The unit of the input concentration. Choose from: <code>{'M', 'fM', 'mM', 'nM', 'pM', 'uM'}</code>.</p> required Source code in <code>datamol/molar.py</code> <pre><code>def log_to_molar(\n    values: Union[float, Iterable[float], np.ndarray],\n    unit: str,\n) -&gt; Union[float, Iterable[float], np.ndarray]:\n\"\"\"Convert a log-scaled molar concentration (pXC50 for example) to its unscaled value (XC50).\n\n    Args:\n        values: A log-scaled molar concentration (can be a scalar, a list or an array).\n        unit: The unit of the input concentration. Choose from:\n            `{'M', 'fM', 'mM', 'nM', 'pM', 'uM'}`.\n    \"\"\"\n\n    if unit not in _MOLAR_SCALES:\n        raise ValueError(\n            f\"The unit '{unit}' is not supported. Choose from {set(_MOLAR_SCALES.keys())}.\"\n        )\n\n    return 10 ** (-1 * np.array(values, dtype=\"float\")) / _MOLAR_SCALES[unit]\n</code></pre>"},{"location":"api/datamol.molar.html#datamol.molar.molar_to_log","title":"<code>molar_to_log(values, unit)</code>","text":"<p>Convert a molar concentration (XC50 for example) to its log scaled value (pXC50).</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Union[float, Iterable[float], np.ndarray]</code> <p>A molar concentration (can be a scalar, a list or an array).</p> required <code>unit</code> <code>str</code> <p>The unit of the input concentration. Choose from: <code>{'M', 'fM', 'mM', 'nM', 'pM', 'uM'}</code>.</p> required Source code in <code>datamol/molar.py</code> <pre><code>def molar_to_log(\n    values: Union[float, Iterable[float], np.ndarray],\n    unit: str,\n) -&gt; Union[float, Iterable[float], np.ndarray]:\n\"\"\"Convert a molar concentration (XC50 for example) to its log scaled value (pXC50).\n\n    Args:\n        values: A molar concentration (can be a scalar, a list or an array).\n        unit: The unit of the input concentration. Choose from:\n            `{'M', 'fM', 'mM', 'nM', 'pM', 'uM'}`.\n    \"\"\"\n\n    if unit not in _MOLAR_SCALES:\n        raise ValueError(\n            f\"The unit '{unit}' is not supported. Choose from {set(_MOLAR_SCALES.keys())}.\"\n        )\n\n    return -1 * np.log10(np.array(values) * _MOLAR_SCALES[unit])\n</code></pre>"},{"location":"api/datamol.reactions.html","title":"<code>datamol.reactions</code>","text":""},{"location":"api/datamol.reactions.html#datamol.reactions._reactions.apply_reaction","title":"<code>apply_reaction(rxn, reactants, product_index=None, single_product_group=False, as_smiles=False, rm_attach=False, disable_logs=True, sanitize=True)</code>","text":"<p>Apply a chemical reaction on a molecule</p> <p>Parameters:</p> Name Type Description Default <code>rxn</code> <code>dm.ChemicalReaction</code> <p>Reaction object.</p> required <code>reactants</code> <code>tuple</code> <p>A tuple of reactants.</p> required <code>product_index</code> <code>Optional[Union[int, list]]</code> <p>The index of the product of interest.</p> <code>None</code> <code>single_product_group</code> <code>bool</code> <p>Whether return one product group from all possible product groups.</p> <code>False</code> <code>as_smiles</code> <code>bool</code> <p>Whether return products in SMILES.</p> <code>False</code> <code>rm_attach</code> <code>bool</code> <p>Whether remove the attachment point from products.</p> <code>False</code> <code>disable_logs</code> <code>bool</code> <p>Whether disable rdkit logs.</p> <code>True</code> <code>sanitize</code> <code>bool</code> <p>Whether sanitize the products.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[list, str, dm.Mol]</code> <p>Reaction products.</p> Source code in <code>datamol/reactions/_reactions.py</code> <pre><code>def apply_reaction(\n    rxn: dm.ChemicalReaction,\n    reactants: tuple,\n    product_index: Optional[Union[int, list]] = None,\n    single_product_group: bool = False,\n    as_smiles: bool = False,\n    rm_attach: bool = False,\n    disable_logs: bool = True,\n    sanitize: bool = True,\n) -&gt; Union[list, str, dm.Mol]:\n\"\"\"\n    Apply a chemical reaction on a molecule\n\n    Args:\n       rxn: Reaction object.\n       reactants: A tuple of reactants.\n       product_index: The index of the product of interest.\n       single_product_group: Whether return one product group from all possible product groups.\n       as_smiles: Whether return products in SMILES.\n       rm_attach: Whether remove the attachment point from products.\n       disable_logs: Whether disable rdkit logs.\n       sanitize: Whether sanitize the products.\n\n    Returns:\n       Reaction products.\n    \"\"\"\n    with dm.without_rdkit_log(enable=disable_logs):\n        if not rxn.IsInitialized():\n            rxn.Initialize()  # pragma: no cover\n\n        product = rxn.RunReactants(reactants)\n        outputs = select_reaction_output(\n            product=product,\n            product_index=product_index,\n            single_product_group=single_product_group,\n            as_smiles=as_smiles,\n            rm_attach=rm_attach,\n            sanitize=sanitize,\n        )\n\n    return outputs\n</code></pre>"},{"location":"api/datamol.reactions.html#datamol.reactions._reactions.can_react","title":"<code>can_react(rxn, mol)</code>","text":"<p>Check if a molecule is a reactant to a chemical reaction.</p> <p>Parameters:</p> Name Type Description Default <code>rxn</code> <code>dm.ChemicalReaction</code> <p>Reaction to check.</p> required <code>mol</code> <code>dm.Mol</code> <p>Molecule to check if it is a reactant.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>mol</code> is a reactant of rxn.</p> Source code in <code>datamol/reactions/_reactions.py</code> <pre><code>def can_react(rxn: dm.ChemicalReaction, mol: dm.Mol) -&gt; bool:\n\"\"\"Check if a molecule is a reactant to a chemical reaction.\n\n    Args:\n        rxn: Reaction to check.\n        mol: Molecule to check if it is a reactant.\n\n    Returns:\n        True if `mol` is a reactant of rxn.\n    \"\"\"\n    if not rxn.IsInitialized():\n        rxn.Initialize()  # pragma: no cover\n    if rxn.IsMoleculeReactant(mol):\n        return find_reactant_position(rxn, mol) != -1\n    return False\n</code></pre>"},{"location":"api/datamol.reactions.html#datamol.reactions._reactions.find_reactant_position","title":"<code>find_reactant_position(rxn, mol)</code>","text":"<p>Find the position of a reactant in a reaction.</p> <p>Parameters:</p> Name Type Description Default <code>rxn</code> <code>dm.ChemicalReaction</code> <p>Reaction</p> required <code>mol</code> <code>dm.Mol</code> <p>Molecule</p> required <p>Returns:</p> Type Description <code>int</code> <p>Reactant position or -1 if <code>mol</code> is not a reactant.</p> Source code in <code>datamol/reactions/_reactions.py</code> <pre><code>def find_reactant_position(rxn: dm.ChemicalReaction, mol: dm.Mol) -&gt; int:\n\"\"\"Find the position of a reactant in a reaction.\n\n    Args:\n        rxn: Reaction\n        mol: Molecule\n\n    Returns:\n        Reactant position or -1 if `mol` is not a reactant.\n    \"\"\"\n\n    if not rxn.IsInitialized():\n        rxn.Initialize()  # pragma: no cover\n\n    react_pos = -1\n    for pos, rct in enumerate(rxn.GetReactants()):\n        if mol.HasSubstructMatch(rct):\n            react_pos = pos\n    return react_pos\n</code></pre>"},{"location":"api/datamol.reactions.html#datamol.reactions._reactions.inverse_reaction","title":"<code>inverse_reaction(rxn)</code>","text":"<p>Get the reverse reaction of the input reaction</p> <p>Parameters:</p> Name Type Description Default <code>rxn</code> <code>dm.ChemicalReaction</code> <p>Reaction to inverse.</p> required <p>Returns:</p> Type Description <code>dm.ChemicalReaction</code> <p>Inversed reaction.</p> Source code in <code>datamol/reactions/_reactions.py</code> <pre><code>def inverse_reaction(rxn: dm.ChemicalReaction) -&gt; dm.ChemicalReaction:\n\"\"\"\n    Get the reverse reaction of the input reaction\n\n    Args:\n        rxn: Reaction to inverse.\n\n    Returns:\n        Inversed reaction.\n    \"\"\"\n    rxn2 = rdChemReactions.ChemicalReaction()\n    for i in range(rxn.GetNumReactantTemplates()):\n        rxn2.AddProductTemplate(rxn.GetReactantTemplate(i))\n    for i in range(rxn.GetNumProductTemplates()):\n        rxn2.AddReactantTemplate(rxn.GetProductTemplate(i))\n    rxn2.Initialize()\n    return rxn2\n</code></pre>"},{"location":"api/datamol.reactions.html#datamol.reactions._reactions.is_reaction_ok","title":"<code>is_reaction_ok(rxn, enable_logs=False)</code>","text":"<p>Check if the given reaction is synthetically valid.</p> <p>Parameters:</p> Name Type Description Default <code>rxn</code> <code>dm.ChemicalReaction</code> <p>dm.ChemicalReaction object</p> required <code>enable_logs</code> <code>bool</code> <p>Whether to enable logs.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean whether reaction is valid</p> Source code in <code>datamol/reactions/_reactions.py</code> <pre><code>def is_reaction_ok(rxn: dm.ChemicalReaction, enable_logs: bool = False) -&gt; bool:\n\"\"\"Check if the given reaction is synthetically valid.\n\n    Args:\n        rxn: dm.ChemicalReaction object\n        enable_logs: Whether to enable logs.\n\n    Returns:\n        Boolean whether reaction is valid\n    \"\"\"\n    nWarn, nError, nReactants, nProducts, labels = rdChemReactions.PreprocessReaction(rxn)\n\n    if enable_logs:\n        logger.info(f\"Number of warnings:{nWarn}\")\n        logger.info(f\"Number of preprocessing errors: {nError}\")\n        logger.info(f\"Number of reactants in reaction: {nReactants}\")\n        logger.info(f\"Number of products in reaction: {nProducts}\")\n        logger.info(f\"Preprocess labels added:{labels}\")\n\n    return rdChemReactions.SanitizeRxn(rxn) in [\n        rdChemReactions.SanitizeFlags.SANITIZE_NONE,\n        None,\n    ]\n</code></pre>"},{"location":"api/datamol.reactions.html#datamol.reactions._reactions.rxn_from_block","title":"<code>rxn_from_block(rxn_block, sanitize=False)</code>","text":"<p>Create a reaction from a block.</p> <p>Parameters:</p> Name Type Description Default <code>rxn_block</code> <code>str</code> <p>A reaction block.</p> required <code>sanitize</code> <code>bool</code> <p>Whether to sanitize the reaction.</p> <code>False</code> <p>Returns:</p> Type Description <code>dm.ChemicalReaction</code> <p>Initialized reaction.</p> Source code in <code>datamol/reactions/_reactions.py</code> <pre><code>def rxn_from_block(\n    rxn_block: str,\n    sanitize: bool = False,\n) -&gt; dm.ChemicalReaction:\n\"\"\"Create a reaction from a block.\n\n    Args:\n        rxn_block: A reaction block.\n        sanitize: Whether to sanitize the reaction.\n\n    Returns:\n        Initialized reaction.\n\n    \"\"\"\n    rxn = rdChemReactions.ReactionFromRxnBlock(rxnblock=rxn_block, sanitize=sanitize)\n    rxn.Initialize()\n    return rxn\n</code></pre>"},{"location":"api/datamol.reactions.html#datamol.reactions._reactions.rxn_from_block_file","title":"<code>rxn_from_block_file(rxn_block_path, sanitize=False)</code>","text":"<p>Create a reaction from a block file.</p> <p>Parameters:</p> Name Type Description Default <code>rxn_block_path</code> <code>Union[str, os.PathLike]</code> <p>Filepath to a reaction block file.</p> required <code>sanitize</code> <code>bool</code> <p>Whether to sanitize the reaction.</p> <code>False</code> <p>Returns:</p> Type Description <code>dm.ChemicalReaction</code> <p>Initialized reaction.</p> Source code in <code>datamol/reactions/_reactions.py</code> <pre><code>def rxn_from_block_file(\n    rxn_block_path: Union[str, os.PathLike],\n    sanitize: bool = False,\n) -&gt; dm.ChemicalReaction:\n\"\"\"Create a reaction from a block file.\n\n    Args:\n        rxn_block_path: Filepath to a reaction block file.\n        sanitize: Whether to sanitize the reaction.\n\n    Returns:\n        Initialized reaction.\n    \"\"\"\n    with fsspec.open(rxn_block_path) as f:\n        rxn_block = f.read()  # type: ignore\n        rxn = rxn_from_block(rxn_block=rxn_block, sanitize=sanitize)\n    return rxn\n</code></pre>"},{"location":"api/datamol.reactions.html#datamol.reactions._reactions.rxn_from_smarts","title":"<code>rxn_from_smarts(rxn_smarts)</code>","text":"<p>Create a reaction from smarts</p> <p>Parameters:</p> Name Type Description Default <code>rxn_smarts</code> <code>str</code> <p>Reaction SMARTS string</p> required <p>Returns:</p> Type Description <code>dm.ChemicalReaction</code> <p>Initilized reaction.</p> Source code in <code>datamol/reactions/_reactions.py</code> <pre><code>def rxn_from_smarts(rxn_smarts: str) -&gt; dm.ChemicalReaction:\n\"\"\"\n    Create a reaction from smarts\n\n    Args:\n        rxn_smarts:  Reaction SMARTS string\n\n    Returns:\n        Initilized reaction.\n    \"\"\"\n    rxn = rdChemReactions.ReactionFromSmarts(SMARTS=rxn_smarts)\n    rxn.Initialize()\n    return rxn\n</code></pre>"},{"location":"api/datamol.reactions.html#datamol.reactions._reactions.rxn_to_block","title":"<code>rxn_to_block(rxn, separate_agents=False, force_V3000=False)</code>","text":"<p>Create a block from a reaction object.</p> <p>Parameters:</p> Name Type Description Default <code>rxn</code> <code>dm.ChemicalReaction</code> <p>A reaction object.</p> required <code>separate_agents</code> <code>bool</code> <p>Whether to separate agents from the reactants block. Not supported if <code>force_V3000=True</code>.</p> <code>False</code> <code>force_V3000</code> <code>bool</code> <p>Write the block in a V3000 format.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Reaction block as string</p> Source code in <code>datamol/reactions/_reactions.py</code> <pre><code>def rxn_to_block(\n    rxn: dm.ChemicalReaction,\n    separate_agents: bool = False,\n    force_V3000: bool = False,\n) -&gt; str:\n\"\"\"Create a block from a reaction object.\n\n    Args:\n        rxn: A reaction object.\n        separate_agents: Whether to separate agents from the reactants block. Not supported\n            if `force_V3000=True`.\n        force_V3000: Write the block in a V3000 format.\n\n    Returns:\n        Reaction block as string\n    \"\"\"\n\n    args = {}\n    if dm.is_lower_than_current_rdkit_version(\"2022\"):\n        logger.warning(\"RDKit version prior to 2022.* does not support the `force_V3000` flag.\")\n    else:\n        args[\"forceV3000\"] = force_V3000\n\n    return rdChemReactions.ReactionToRxnBlock(reaction=rxn, separateAgents=separate_agents, **args)\n</code></pre>"},{"location":"api/datamol.reactions.html#datamol.reactions._reactions.rxn_to_block_file","title":"<code>rxn_to_block_file(rxn, output_block_path, separate_agents=False, force_V3000=False)</code>","text":"<p>Create a block from a reaction object.</p> <p>Parameters:</p> Name Type Description Default <code>rxn</code> <code>dm.ChemicalReaction</code> <p>A reaction object.</p> required <code>output_block_path</code> <code>Union[str, os.PathLike]</code> <p>Filepath to a reaction block file.</p> required <code>separate_agents</code> <code>bool</code> <p>Whether to separate agents from the reactants block. Not supported if <code>force_V3000=True</code>.</p> <code>False</code> <code>force_V3000</code> <code>bool</code> <p>Write the block in a V3000 format.</p> <code>False</code> Source code in <code>datamol/reactions/_reactions.py</code> <pre><code>def rxn_to_block_file(\n    rxn: dm.ChemicalReaction,\n    output_block_path: Union[str, os.PathLike],\n    separate_agents: bool = False,\n    force_V3000: bool = False,\n):\n\"\"\"Create a block from a reaction object.\n\n    Args:\n        rxn: A reaction object.\n        output_block_path: Filepath to a reaction block file.\n        separate_agents: Whether to separate agents from the reactants block. Not supported\n            if `force_V3000=True`.\n        force_V3000: Write the block in a V3000 format.\n    \"\"\"\n    block = rxn_to_block(\n        rxn=rxn,\n        separate_agents=separate_agents,\n        force_V3000=force_V3000,\n    )\n\n    with fsspec.open(output_block_path, \"w\") as f:\n        f = cast(io.TextIOWrapper, f)\n        f.write(block)\n</code></pre>"},{"location":"api/datamol.reactions.html#datamol.reactions._reactions.rxn_to_smarts","title":"<code>rxn_to_smarts(rxn)</code>","text":"<p>Create a SMARTS from a reaction.</p> <p>Parameters:</p> Name Type Description Default <code>rxn</code> <code>dm.ChemicalReaction</code> <p>dm.ChemicalReaction object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>SMARTS as string.</p> Source code in <code>datamol/reactions/_reactions.py</code> <pre><code>def rxn_to_smarts(rxn: dm.ChemicalReaction) -&gt; str:\n\"\"\"Create a SMARTS from a reaction.\n\n    Args:\n        rxn: dm.ChemicalReaction object.\n\n    Returns:\n        SMARTS as string.\n    \"\"\"\n    return rdChemReactions.ReactionToSmarts(reaction=rxn)\n</code></pre>"},{"location":"api/datamol.reactions.html#datamol.reactions._reactions.select_reaction_output","title":"<code>select_reaction_output(product, product_index=None, single_product_group=True, rm_attach=False, as_smiles=False, sanitize=True)</code>","text":"<p>Compute the products from a reaction. It only takes the first product of the</p> <p>Parameters:</p> Name Type Description Default <code>product</code> <code>Sequence[Sequence[dm.Mol]]</code> <p>All the products from a reaction. A sequence of the list of products.</p> required <code>product_index</code> <code>Optional[Union[int, list]]</code> <p>Index of the product to select. Examples: A.B -&gt; C.D. The indices of products are 0 and 1. Both C and D will be returned if index is None or product indices are to [0, 1].</p> <code>None</code> <code>single_product_group</code> <code>bool</code> <p>Whether return a single group of products from a reaction.</p> <code>True</code> <code>rm_attach</code> <code>bool</code> <p>Whether remove the attachment point from the products.</p> <code>False</code> <code>as_smiles</code> <code>bool</code> <p>Whether return the result in smiles.</p> <code>False</code> <code>sanitize</code> <code>bool</code> <p>Whether sanitize the products to return.</p> <code>True</code> <p>Returns:</p> Type Description <code>Union[list, str, dm.Mol]</code> <p>Processed products from reaction.</p> Source code in <code>datamol/reactions/_reactions.py</code> <pre><code>def select_reaction_output(\n    product: Sequence[Sequence[dm.Mol]],\n    product_index: Optional[Union[int, list]] = None,\n    single_product_group: bool = True,\n    rm_attach: bool = False,\n    as_smiles: bool = False,\n    sanitize: bool = True,\n) -&gt; Union[list, str, dm.Mol]:\n\"\"\"\n    Compute the products from a reaction. It only takes the first product of the\n\n    Args:\n        product: All the products from a reaction. A sequence of the list of products.\n        product_index: Index of the product to select.\n            Examples: A.B -&gt; C.D. The indices of products are 0 and 1.\n            Both C and D will be returned if index is None or product indices are to [0, 1].\n        single_product_group: Whether return a single group of products from a reaction.\n        rm_attach: Whether remove the attachment point from the products.\n        as_smiles: Whether return the result in smiles.\n        sanitize: Whether sanitize the products to return.\n\n    Returns:\n        Processed products from reaction.\n    \"\"\"\n    if len(product) == 0:\n        return list(product)\n    product = np.array(product)\n    if product_index is not None:\n        product = product[:, product_index]\n    if single_product_group:\n        index = np.random.randint(product.shape[0], size=1)\n        product = product[index]\n    if sanitize:\n        product = np.vectorize(dm.sanitize_mol)(product)\n    if rm_attach:\n        fn = lambda x: dm.remove_dummies(x) if x is not None else x\n        product = np.vectorize(fn)(product)\n    if as_smiles:\n        fn = lambda x: dm.to_smiles(x, allow_to_fail=True) if x is not None else x\n        product = np.vectorize(fn)(product)\n    product = product.tolist()\n    if single_product_group:\n        return product[0]\n    return product\n</code></pre>"},{"location":"api/datamol.reactions.html#datamol.reactions._attachments.add_brackets_to_attachment_points","title":"<code>add_brackets_to_attachment_points(smiles)</code>","text":"<p>Adds brackets to the attachment points (if they don't have them). Example: \"CC(C)CO\" to \"CC(C)CO[]\"</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>str</code> <p>A smiles string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A smiles string with brackets.</p> Source code in <code>datamol/reactions/_attachments.py</code> <pre><code>def add_brackets_to_attachment_points(smiles: str) -&gt; str:\n\"\"\"\n    Adds brackets to the attachment points (if they don't have them).\n    Example: \"CC(C)CO*\" to \"CC(C)CO[*]\"\n\n    Args:\n        smiles: A smiles string.\n\n    Returns:\n        A smiles string with brackets.\n    \"\"\"\n    return re.sub(\n        ATTACHMENT_POINT_NO_BRACKETS_REGEXP,\n        \"[{}]\".format(ATTACHMENT_POINT_TOKEN),\n        smiles,\n    )\n</code></pre>"},{"location":"api/datamol.reactions.html#datamol.reactions._attachments.convert_attach_to_isotope","title":"<code>convert_attach_to_isotope(mol_or_smiles, same_isotope=False, as_smiles=False)</code>","text":"<p>Convert attachment to isotope mapping.</p> <p>\"O=C(NCc1cnc([*])c1)[*]\" to  \"O=C(NCc1cnc([1*])c1)[2*]\"</p> <p>Parameters:</p> Name Type Description Default <code>mol_or_smiles</code> <code>Union[dm.Mol, str]</code> <p>A Mol object or a smiles to be converted</p> required <code>same_isotope</code> <code>bool</code> <p>Whether convert to the same isotope. Example: \"O=C(NCc1cnc([])c1)[]\" to  \"O=C(NCc1cnc([1])c1)[1]\"</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[dm.Mol, str]</code> <p>Converted Mol object or SMILES.</p> Source code in <code>datamol/reactions/_attachments.py</code> <pre><code>def convert_attach_to_isotope(\n    mol_or_smiles: Union[dm.Mol, str],\n    same_isotope: bool = False,\n    as_smiles: bool = False,\n) -&gt; Union[dm.Mol, str]:\n\"\"\"Convert attachment to isotope mapping.\n\n    Examples: \"O=C(NCc1cnc([*])c1)[*]\" to  \"O=C(NCc1cnc([1*])c1)[2*]\"\n\n    Args:\n        mol_or_smiles: A Mol object or a smiles to be converted\n        same_isotope: Whether convert to the same isotope.\n            Example: \"O=C(NCc1cnc([*])c1)[*]\" to  \"O=C(NCc1cnc([1*])c1)[1*]\"\n\n    Returns:\n        Converted Mol object or SMILES.\n    \"\"\"\n    mol = dm.to_mol(mol_or_smiles)\n    smiles = dm.to_smiles(mol)\n    smiles = cast(str, smiles)\n\n    smiles = add_brackets_to_attachment_points(smiles)\n\n    # reg matching seems to be the most effective\n    subs_reg = r\"[\\g&lt;1&gt;{}]\"\n    if same_isotope:\n        subs_reg = \"[1{}]\"\n\n    smiles = re.sub(ATTACHMENT_POINT_NUM_REGEXP, subs_reg.format(ATTACHMENT_POINT_TOKEN), smiles)\n\n    if as_smiles:\n        return smiles\n    return dm.to_mol(smiles)\n</code></pre>"},{"location":"api/datamol.reactions.html#datamol.reactions._attachments.num_attachment_points","title":"<code>num_attachment_points(mol_or_smiles)</code>","text":"<p>Get the number of attachment point in the</p> <p>Parameters:</p> Name Type Description Default <code>mol_or_smiles</code> <code>Union[dm.Mol, str]</code> <p>A Mol object or a smiles to be converted</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of attachment points of the given molecule.</p> Source code in <code>datamol/reactions/_attachments.py</code> <pre><code>def num_attachment_points(mol_or_smiles: Union[dm.Mol, str]) -&gt; int:\n\"\"\"\n    Get the number of attachment point in the\n\n    Args:\n        mol_or_smiles: A Mol object or a smiles to be converted\n\n    Returns:\n        Number of attachment points of the given molecule.\n    \"\"\"\n    if isinstance(mol_or_smiles, dm.Mol):\n        mol = cast(dm.Mol, mol_or_smiles)\n        n_points = len(\n            [atom for atom in mol.GetAtoms() if atom.GetSymbol() == ATTACHMENT_POINT_TOKEN]\n        )\n    else:\n        n_points = len(re.findall(ATTACHMENT_POINT_REGEXP, mol_or_smiles))\n\n    return n_points\n</code></pre>"},{"location":"api/datamol.reactions.html#datamol.reactions._attachments.open_attach_points","title":"<code>open_attach_points(mol, fix_atom_map=False, bond_type=dm.SINGLE_BOND)</code>","text":"<p>Compute attachment points on a molecule. This will highlight all valid attachment point on the current molecule instead.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>A Mol object to be processed.</p> required <code>fix_atom_map</code> <code>bool</code> <p>Whether fix the atom mapping of the molecule.</p> <code>False</code> <code>bond_type</code> <code>dm.BondType</code> <p>The bond type to be opened.</p> <code>dm.SINGLE_BOND</code> <p>Returns:</p> Type Description <code>dm.Mol</code> <p>Molecule with open attachment points</p> Source code in <code>datamol/reactions/_attachments.py</code> <pre><code>def open_attach_points(\n    mol: dm.Mol,\n    fix_atom_map: bool = False,\n    bond_type: dm.BondType = dm.SINGLE_BOND,\n) -&gt; dm.Mol:\n\"\"\"Compute attachment points on a molecule.\n    This will highlight all valid attachment point on the current molecule instead.\n\n    Args:\n        mol: A Mol object to be processed.\n        fix_atom_map: Whether fix the atom mapping of the molecule.\n        bond_type: The bond type to be opened.\n\n    Returns:\n        Molecule with open attachment points\n    \"\"\"\n\n    emol = Chem.rdchem.RWMol(dm.to_mol(mol))\n    with dm.log.without_rdkit_log():\n        atoms = [\n            (a.GetIdx(), a)\n            for a in emol.GetAtoms()\n            if a.GetSymbol() != ATTACHMENT_POINT_TOKEN\n            and a.GetImplicitValence() &gt; 0\n            and (not a.HasProp(\"_protected\") or a.GetProp(\"_protected\") != \"1\")\n        ]\n        atoms.sort(reverse=True, key=operator.itemgetter(0))\n\n        for atom in atoms:\n            new_atom = Chem.rdchem.Atom(ATTACHMENT_POINT_TOKEN)\n            new_atom.SetAtomMapNum(1 if fix_atom_map else atom[0])\n            new_index = emol.AddAtom(new_atom)\n            emol.UpdatePropertyCache(strict=False)\n            if bond_type is not None:\n                emol.AddBond(atom[0], new_index, bond_type)\n            else:\n                emol.AddBond(atom[0], new_index)\n\n    mol = dm.sanitize_mol(emol)\n    return mol\n</code></pre>"},{"location":"api/datamol.scaffold.html","title":"<code>datamol.scaffold</code>","text":""},{"location":"api/datamol.scaffold.html#datamol.scaffold._fuzzy.fuzzy_scaffolding","title":"<code>fuzzy_scaffolding(mols, enforce_subs=None, n_atom_cuttoff=8, additional_templates=None, ignore_non_ring=False, mcs_params=None)</code>","text":"<p>Generate fuzzy scaffold with enforceable group that needs to appear in the core, forcing to keep the full side chain if required</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>List[Chem.rdchem.Mol]</code> <p>List of all molecules</p> required <code>enforce_subs</code> <code>Optional[List[str]]</code> <p>List of substructure to enforce on the scaffold.</p> <code>None</code> <code>n_atom_cuttoff</code> <code>int</code> <p>Minimum number of atom a core should have.</p> <code>8</code> <code>additional_templates</code> <code>Optional[List[Mol]]</code> <p>Additional template to use to generate scaffolds.</p> <code>None</code> <code>ignore_non_ring</code> <code>bool</code> <p>Whether to ignore atom no in murcko ring system, even if they are in the framework.</p> <code>False</code> <code>mcs_params</code> <code>Optional[Dict[Any, Any]]</code> <p>Arguments of MCS algorithm.</p> <code>None</code> <p>Returns:</p> Type Description <code>set</code> <ul> <li><code>set</code> - <code>scaffolds</code> - All found scaffolds in the molecules as valid smiles.</li> </ul> <code>Dict[str, dict]</code> <ul> <li><code>Dict[Dict]</code> - <code>scaffold_infos</code> - Infos on the scaffold mapping, ignoring any side chain that had     to be enforced. Key corresponds to generic scaffold smiles     Values at ['smarts'] corresponds to smarts representation of the true scaffold (from MCS)     Values at ['mols'] corresponds to list of molecules matching the scaffold</li> </ul> <code>Dict[str, list]</code> <ul> <li><code>Dict[List]</code> - <code>scaffold_to_group</code> - Map between each generic scaffold and the R-groups decomposition row.</li> </ul> Source code in <code>datamol/scaffold/_fuzzy.py</code> <pre><code>def fuzzy_scaffolding(\n    mols: List[Chem.rdchem.Mol],\n    enforce_subs: Optional[List[str]] = None,\n    n_atom_cuttoff: int = 8,\n    additional_templates: Optional[List[Mol]] = None,\n    ignore_non_ring: bool = False,\n    mcs_params: Optional[Dict[Any, Any]] = None,\n) -&gt; Tuple[set, Dict[str, dict], Dict[str, list]]:\n\"\"\"Generate fuzzy scaffold with enforceable group that needs to appear\n    in the core, forcing to keep the full side chain if required\n\n    Args:\n        mols: List of all molecules\n        enforce_subs: List of substructure to enforce on the scaffold.\n        n_atom_cuttoff: Minimum number of atom a core should have.\n        additional_templates: Additional template to use to generate scaffolds.\n        ignore_non_ring: Whether to ignore atom no in murcko ring system, even if they are in the framework.\n        mcs_params: Arguments of MCS algorithm.\n\n    Returns:\n        - `set` - `scaffolds` - All found scaffolds in the molecules as valid smiles.\n        - `Dict[Dict]` - `scaffold_infos` - Infos on the scaffold mapping, ignoring any side chain that had\n                to be enforced. Key corresponds to generic scaffold smiles\n                Values at ['smarts'] corresponds to smarts representation of the true scaffold (from MCS)\n                Values at ['mols'] corresponds to list of molecules matching the scaffold\n        - `Dict[List]` - `scaffold_to_group` - Map between each generic scaffold and the R-groups decomposition row.\n    \"\"\"\n\n    # NOTE(hadim): consider parallelize this (if possible).\n    # NOTE(hadim): consider refactoring this function in smaller reusable functions.\n\n    if enforce_subs is None:\n        enforce_subs = []\n\n    if additional_templates is None:\n        additional_templates = []\n\n    if mcs_params is None:\n        mcs_params = {}\n\n    rg_params = rdRGroupDecomposition.RGroupDecompositionParameters()\n    rg_params.removeAllHydrogenRGroups = True\n    rg_params.removeHydrogensPostMatch = True\n    rg_params.alignment = rdRGroupDecomposition.RGroupCoreAlignment.MCS\n    rg_params.matchingStrategy = rdRGroupDecomposition.RGroupMatching.Exhaustive\n    rg_params.rgroupLabelling = rdRGroupDecomposition.RGroupLabelling.AtomMap\n    rg_params.labels = rdRGroupDecomposition.RGroupLabels.AtomIndexLabels\n\n    core_query_param = AdjustQueryParameters()\n    core_query_param.makeDummiesQueries = True\n    core_query_param.adjustDegree = False\n    core_query_param.makeBondsGeneric = True\n\n    # group molecules by they generic Murcko scaffold, allowing\n    # side chain that contains cycle (might be a bad idea)\n    scf2infos = collections.defaultdict(dict)\n    scf2groups = {}\n    all_scaffolds = set([])\n\n    for m in mols:\n        generic_m = MurckoScaffold.MakeScaffoldGeneric(m)\n        scf = MurckoScaffold.GetScaffoldForMol(m)\n        try:\n            scf = MurckoScaffold.MakeScaffoldGeneric(scf)\n        except:\n            pass\n\n        if ignore_non_ring:\n            rw_scf = Chem.RWMol(scf)\n            atms = [a.GetIdx() for a in rw_scf.GetAtoms() if not a.IsInRing()]\n            atms.sort(reverse=True)\n            for a in atms:\n                rw_scf.RemoveAtom(a)\n            scfs = list(rdmolops.GetMolFrags(rw_scf, asMols=False))\n        else:\n            scfs = [to_smiles(scf)]\n\n        # add templates mols if exists:\n        for tmp in additional_templates:\n            tmp = to_mol(tmp)\n            tmp_scf = MurckoScaffold.MakeScaffoldGeneric(tmp)\n            if generic_m.HasSubstructMatch(tmp_scf):\n                scfs.append(to_smiles(tmp_scf))\n\n        for scf in scfs:\n            if scf2infos[scf].get(\"mols\"):\n                scf2infos[scf][\"mols\"].append(m)\n            else:\n                scf2infos[scf][\"mols\"] = [m]\n\n    for scf in scf2infos:\n        # cheat by adding murcko as last mol always\n        popout = False\n        mols = scf2infos[scf][\"mols\"]\n        if len(mols) &lt; 2:\n            mols = mols + [MurckoScaffold.GetScaffoldForMol(mols[0])]\n            popout = True\n\n        # compute the MCS of the cluster\n        mcs = rdFMCS.FindMCS(\n            mols,\n            atomCompare=rdFMCS.AtomCompare.CompareAny,\n            bondCompare=rdFMCS.BondCompare.CompareAny,\n            completeRingsOnly=True,\n            **mcs_params,\n        )\n\n        mcsM = from_smarts(mcs.smartsString)\n        mcsM.UpdatePropertyCache(False)\n        Chem.SetHybridization(mcsM)\n\n        if mcsM.GetNumAtoms() &lt; n_atom_cuttoff:\n            continue\n\n        scf2infos[scf][\"smarts\"] = to_smarts(mcsM)\n        if popout:\n            mols = mols[:-1]\n\n        core_groups = []\n        # generate rgroups based on the mcs core\n        success_mols = []\n        try:\n            rg = rdRGroupDecomposition.RGroupDecomposition(mcsM, rg_params)\n            for i, analog in enumerate(mols):\n                analog.RemoveAllConformers()\n                res = rg.Add(analog)\n                if not (res &lt; 0):\n                    success_mols.append(i)\n            rg.Process()\n            core_groups = rg.GetRGroupsAsRows()\n        except Exception:\n            pass\n\n        mols = [mols[i] for i in success_mols]\n        scf2groups[scf] = core_groups\n        for mol, gp in zip(mols, core_groups):\n            core = gp[\"Core\"]\n            acceptable_groups = [\n                a.GetAtomMapNum()\n                for a in core.GetAtoms()\n                if (a.GetAtomMapNum() and not a.IsInRing())\n            ]\n\n            rgroups = [gp[f\"R{k}\"] for k in acceptable_groups if f\"R{k}\" in gp.keys()]\n            if enforce_subs is not None:\n                rgroups = [\n                    rgp\n                    for rgp in rgroups\n                    if not any([len(rgp.GetSubstructMatch(frag)) &gt; 0 for frag in enforce_subs])\n                ]\n            try:\n                scaff = trim_side_chain(mol, AdjustQueryProperties(core, core_query_param), rgroups)\n            except:\n                continue\n            all_scaffolds.add(to_smiles(scaff))\n\n    return all_scaffolds, scf2infos, scf2groups\n</code></pre>"},{"location":"api/datamol.scaffold.html#datamol.scaffold._fuzzy.trim_side_chain","title":"<code>trim_side_chain(mol, core, unwanted_side_chains)</code>","text":"<p>Trim list of side chain from a molecule.</p> Source code in <code>datamol/scaffold/_fuzzy.py</code> <pre><code>def trim_side_chain(mol: Chem.rdchem.Mol, core, unwanted_side_chains):\n\"\"\"Trim list of side chain from a molecule.\"\"\"\n\n    mol = add_hs(mol)\n\n    match = mol.GetSubstructMatch(core)\n    map2idx = {}\n    map2nei = {}\n    unwanted2map = {}\n    for patt in unwanted_side_chains:\n        unwanted2map[patt] = [a.GetAtomMapNum() for a in patt.GetAtoms() if a.GetAtomMapNum()]\n    unwanted_mapping = list(itertools.chain.from_iterable(unwanted2map.values()))\n\n    for atom in core.GetAtoms():\n        num = atom.GetAtomMapNum()\n        if num and num in unwanted_mapping:\n            mol_atom_idx = match[atom.GetIdx()]\n            map2idx[mol_atom_idx] = num\n            nei_atoms = mol.GetAtomWithIdx(mol_atom_idx).GetNeighbors()\n            map2nei[mol_atom_idx] = [n.GetIdx() for n in nei_atoms if n.GetIdx() in match]\n\n    emol = Chem.EditableMol(mol)\n    for atom_idx, atom_map in map2idx.items():\n        dummy = Chem.rdchem.Atom(\"*\")\n        dummy.SetAtomMapNum(atom_map)\n        nei_idx = map2nei.get(atom_idx, [None])[0]\n        if nei_idx:\n            bond = mol.GetBondBetweenAtoms(atom_idx, nei_idx)\n            emol.RemoveBond(atom_idx, nei_idx)\n            new_ind = emol.AddAtom(dummy)\n            emol.AddBond(nei_idx, new_ind, bond.GetBondType())\n\n    mol = emol.GetMol()\n    mol = remove_hs(mol)\n    query_param = AdjustQueryParameters()\n    query_param.makeDummiesQueries = False\n    query_param.adjustDegree = False\n    query_param.aromatizeIfPossible = True\n    for patt, _ in unwanted2map.items():\n        cur_frag = fix_mol(patt)\n        mol = Chem.DeleteSubstructs(mol, cur_frag, onlyFrags=True)\n\n    return keep_largest_fragment(mol)\n</code></pre>"},{"location":"api/datamol.similarity.html","title":"<code>datamol.similarity</code>","text":""},{"location":"api/datamol.similarity.html#datamol.similarity.cdist","title":"<code>cdist(mols1, mols2, n_jobs=1, distances_chunk=False, distances_chunk_memory=1024, distances_n_jobs=-1, **fp_args)</code>","text":"<p>Compute the tanimoto distance between the fingerprints of each pair of molecules of the two collections of inputs.</p> <p>Parameters:</p> Name Type Description Default <code>mols1</code> <code>List[Union[str, dm.Mol]]</code> <p>list of molecules.</p> required <code>mols2</code> <code>List[Union[str, dm.Mol]]</code> <p>list of molecules.</p> required <code>n_jobs</code> <code>Optional[int]</code> <p>Number of jobs for fingerprint computation. Let to 1 for no parallelization. Set to -1 to use all available cores.</p> <code>1</code> <code>distances_chunk</code> <code>bool</code> <p>Whether to use chunked computation.</p> <code>False</code> <code>distances_chunk_memory</code> <code>int</code> <p>Memory size in MB to use for chunked computation.</p> <code>1024</code> <code>distances_n_jobs</code> <code>int</code> <p>Number of jobs for parallelization.</p> <code>-1</code> <code>**fp_args</code> <code>Any</code> <p>list of args to pass to <code>to_fp()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>distmat</p> Source code in <code>datamol/similarity.py</code> <pre><code>def cdist(\n    mols1: List[Union[str, dm.Mol]],\n    mols2: List[Union[str, dm.Mol]],\n    n_jobs: Optional[int] = 1,\n    distances_chunk: bool = False,\n    distances_chunk_memory: int = 1024,\n    distances_n_jobs: int = -1,\n    **fp_args: Any,\n) -&gt; np.ndarray:\n\"\"\"Compute the tanimoto distance between the fingerprints of each pair of\n    molecules of the two collections of inputs.\n\n    Args:\n        mols1: list of molecules.\n        mols2: list of molecules.\n        n_jobs: Number of jobs for fingerprint computation. Let to 1 for no\n            parallelization. Set to -1 to use all available cores.\n        distances_chunk: Whether to use chunked computation.\n        distances_chunk_memory: Memory size in MB to use for chunked computation.\n        distances_n_jobs: Number of jobs for parallelization.\n        **fp_args: list of args to pass to `to_fp()`.\n\n    Returns:\n        distmat\n    \"\"\"\n\n    fps1 = dm.parallelized(\n        functools.partial(dm.to_fp, as_array=True, **fp_args),\n        mols1,\n        n_jobs=n_jobs,\n    )\n\n    fps2 = dm.parallelized(\n        functools.partial(dm.to_fp, as_array=True, **fp_args),\n        mols2,\n        n_jobs=n_jobs,\n    )\n\n    fps1 = np.array(fps1).astype(bool)\n    fps2 = np.array(fps2).astype(bool)\n\n    if distances_chunk:\n        distances = pairwise_distances_chunked(\n            fps1,\n            fps2,\n            metric=\"jaccard\",\n            n_jobs=distances_n_jobs,\n            working_memory=distances_chunk_memory,\n        )\n        distances = [i for i in distances]\n        distances = np.vstack(distances)\n    else:\n        distances = distance.cdist(fps1, fps2, metric=\"jaccard\")\n\n    return distances\n</code></pre>"},{"location":"api/datamol.similarity.html#datamol.similarity.pdist","title":"<code>pdist(mols, n_jobs=1, squareform=True, **fp_args)</code>","text":"<p>Compute the pairwise tanimoto distance between the fingerprints of all the molecules in the input set.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>List[Union[str, dm.Mol]]</code> <p>list of molecules</p> required <code>n_jobs</code> <code>Optional[int]</code> <p>Number of jobs for parallelization. Let to 1 for no parallelization. Set to -1 to use all available cores.</p> <code>1</code> <code>squareform</code> <code>bool</code> <p>Whether to return in square form (matrix) or in a condensed form (1D vector).</p> <code>True</code> <code>**fp_args</code> <code>Any</code> <p>list of args to pass to <code>to_fp()</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>dist_mat</p> Source code in <code>datamol/similarity.py</code> <pre><code>def pdist(\n    mols: List[Union[str, dm.Mol]],\n    n_jobs: Optional[int] = 1,\n    squareform: bool = True,\n    **fp_args: Any,\n) -&gt; np.ndarray:\n\"\"\"Compute the pairwise tanimoto distance between the fingerprints of all the\n    molecules in the input set.\n\n    Args:\n        mols: list of molecules\n        n_jobs: Number of jobs for parallelization. Let to 1 for no\n            parallelization. Set to -1 to use all available cores.\n        squareform: Whether to return in square form (matrix) or in a condensed\n            form (1D vector).\n        **fp_args: list of args to pass to `to_fp()`.\n\n    Returns:\n        dist_mat\n    \"\"\"\n\n    fps = dm.parallelized(\n        functools.partial(dm.to_fp, as_array=True, **fp_args),\n        mols,\n        n_jobs=n_jobs,\n    )\n\n    fps = np.array(fps)\n\n    dist_mat = distance.pdist(fps, metric=\"jaccard\")\n\n    if squareform:\n        dist_mat = distance.squareform(dist_mat, force=\"tomatrix\")\n\n    return dist_mat\n</code></pre>"},{"location":"api/datamol.utils.html","title":"<code>datamol.utils</code>","text":"<p>The <code>fs</code> module makes it easier to work with all type of path (the ones supported by <code>fsspec</code>).</p>"},{"location":"api/datamol.utils.html#datamol.utils.decorators.disable_on_os","title":"<code>disable_on_os(os_names)</code>","text":"<p>A decorator to disable a function raising an error if the OS detected is not supported.</p> <p>Parameters:</p> Name Type Description Default <code>os_names</code> <code>Union[str, List[str]]</code> <p>OS names to disable this function. Valid OS names are: <code>[\"linux\", \"osx\", \"win\"]</code>.</p> required Source code in <code>datamol/utils/decorators.py</code> <pre><code>def disable_on_os(os_names: Union[str, List[str]]):\n\"\"\"A decorator to disable a function raising an error if the OS detected is not supported.\n\n    Args:\n        os_names: OS names to disable this function. Valid OS names are: `[\"linux\", \"osx\", \"win\"]`.\n    \"\"\"\n\n    if isinstance(os_names, str):\n        os_names = [os_names]\n\n    valid_os_names = []\n    for os_name in os_names:\n        if os_name == \"linux\":\n            valid_os_names.append(\"Linux\")\n        elif os_name == \"win\":\n            valid_os_names.append(\"Windows\")\n        elif os_name == \"osx\":\n            valid_os_names.append(\"Darwin\")\n        else:\n            valid_os_names.append(os_name)\n\n    def real_decorator(function: Callable):\n        @wraps(function)\n        def wrapper(*args, **kwargs):\n            if platform.system() not in valid_os_names:\n                retval = function(*args, **kwargs)\n                return retval\n            else:\n                raise NotImplementedError(\n                    f\"The function {function.__name__} is not supported\"\n                    f\" for the platform '{platform.system()}'.\"\n                )\n\n        return wrapper\n\n    return real_decorator\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.fs.copy_dir","title":"<code>copy_dir(source, destination, force=False, progress=False, leave_progress=True, file_progress=False, file_leave_progress=False, chunk_size=None)</code>","text":"<p>Copy one directory to another location across different filesystem (local, S3, GCS, etc).</p> <p>Note that if both FS from source and destination are the same, progress won't be shown.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, pathlib.Path]</code> <p>Path to the source directory.</p> required <code>destination</code> <code>Union[str, pathlib.Path]</code> <p>Path to the destination directory.</p> required <code>chunk_size</code> <code>Optional[int]</code> <p>the chunk size to use. If progress is enabled the chunk size is <code>None</code>, it is set to 2048.</p> <code>None</code> <code>force</code> <code>bool</code> <p>whether to overwrite the destination directory if it exists.</p> <code>False</code> <code>progress</code> <code>bool</code> <p>Whether to display a progress bar.</p> <code>False</code> <code>leave_progress</code> <code>bool</code> <p>Whether to hide the progress bar once the copy is done.</p> <code>True</code> <code>file_progress</code> <code>bool</code> <p>Whether to display a progress bar for each file.</p> <code>False</code> <code>file_leave_progress</code> <code>bool</code> <p>Whether to hide the progress bar once a file copy is done.</p> <code>False</code> <code>chunk_size</code> <code>Optional[int]</code> <p>See <code>dm.utils.fs.copy_file</code>.</p> <code>None</code> Source code in <code>datamol/utils/fs.py</code> <pre><code>def copy_dir(\n    source: Union[str, pathlib.Path],\n    destination: Union[str, pathlib.Path],\n    force: bool = False,\n    progress: bool = False,\n    leave_progress: bool = True,\n    file_progress: bool = False,\n    file_leave_progress: bool = False,\n    chunk_size: Optional[int] = None,\n):\n\"\"\"Copy one directory to another location across different filesystem (local, S3, GCS, etc).\n\n    Note that if both FS from source and destination are the same, progress won't be shown.\n\n    Args:\n        source: Path to the source directory.\n        destination: Path to the destination directory.\n        chunk_size: the chunk size to use. If progress is enabled the chunk\n            size is `None`, it is set to 2048.\n        force: whether to overwrite the destination directory if it exists.\n        progress: Whether to display a progress bar.\n        leave_progress: Whether to hide the progress bar once the copy is done.\n        file_progress: Whether to display a progress bar for each file.\n        file_leave_progress: Whether to hide the progress bar once a file copy is done.\n        chunk_size: See `dm.utils.fs.copy_file`.\n    \"\"\"\n\n    source = str(source)\n    destination = str(destination)\n\n    source_fs = get_mapper(source).fs\n    destination_fs = get_mapper(destination).fs\n\n    # Sanity check\n    if not is_dir(source):\n        raise ValueError(\n            f\"The directory being copied does not exist or is not a directory: {source}\"\n        )\n\n    if not force and is_dir(destination):\n        raise ValueError(f\"The destination folder to copy already exists: {destination}\")\n\n    # If both fs are the same then we just rely on the internal `copy` method\n    # which is much faster.\n    if destination_fs.__class__ == source_fs.__class__:\n        source_fs.copy(source, destination, recursive=True)\n        return\n\n    # Get all input paths with details\n    # NOTE(hadim): we could have use `.glob(..., detail=True)` here but that API is inconsistent\n    # between the backends resulting in different object types being returned (dict, list, etc).\n    detailed_paths = source_fs.find(source, withdirs=True, detail=True)\n    detailed_paths = list(detailed_paths.values())\n\n    # Get list of input types\n    input_types = [d[\"type\"] for d in detailed_paths]\n\n    # Get list of input path + add protocol if needed\n    input_paths = [d[\"name\"] for d in detailed_paths]\n    input_paths = [fsspec.utils._unstrip_protocol(p, source_fs) for p in input_paths]\n\n    # Build all the output paths\n    output_paths: List[str] = fsspec.utils.other_paths(input_paths, destination)  # type: ignore\n\n    def _copy_source_to_destination(input_path, input_type, output_path):\n        # A directory\n        if input_type == \"directory\":\n            destination_fs.mkdir(output_path)\n\n        # A file\n        else:\n            copy_file(\n                input_path,\n                output_path,\n                force=force,\n                progress=file_progress,\n                leave_progress=file_leave_progress,\n                chunk_size=chunk_size,\n            )\n\n    # Copy source files/directories to destination in parallel\n    parallelized(\n        _copy_source_to_destination,\n        inputs_list=list(zip(input_paths, input_types, output_paths)),\n        arg_type=\"args\",\n        progress=progress,\n        tqdm_kwargs=dict(leave=leave_progress),\n        scheduler=\"threads\",\n    )\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.fs.copy_file","title":"<code>copy_file(source, destination, chunk_size=None, force=False, progress=False, leave_progress=True)</code>","text":"<p>Copy one file to another location across different filesystem (local, S3, GCS, etc).</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, pathlib.Path, io.IOBase, fsspec.core.OpenFile]</code> <p>path or file-like object to copy from.</p> required <code>destination</code> <code>Union[str, pathlib.Path, io.IOBase, fsspec.core.OpenFile]</code> <p>path or file-like object to copy to.</p> required <code>chunk_size</code> <code>Optional[int]</code> <p>the chunk size to use. If progress is enabled the chunk size is <code>None</code>, it is set to 1MB (1024 * 1024).</p> <code>None</code> <code>force</code> <code>bool</code> <p>whether to overwrite the destination file if it exists.</p> <code>False</code> <code>progress</code> <code>bool</code> <p>whether to display a progress bar.</p> <code>False</code> <code>leave_progress</code> <code>bool</code> <p>whether to hide the progress bar once the copy is done.</p> <code>True</code> Source code in <code>datamol/utils/fs.py</code> <pre><code>def copy_file(\n    source: Union[str, pathlib.Path, io.IOBase, fsspec.core.OpenFile],\n    destination: Union[str, pathlib.Path, io.IOBase, fsspec.core.OpenFile],\n    chunk_size: Optional[int] = None,\n    force: bool = False,\n    progress: bool = False,\n    leave_progress: bool = True,\n):\n\"\"\"Copy one file to another location across different filesystem (local, S3, GCS, etc).\n\n    Args:\n        source: path or file-like object to copy from.\n        destination: path or file-like object to copy to.\n        chunk_size: the chunk size to use. If progress is enabled the chunk\n            size is `None`, it is set to 1MB (1024 * 1024).\n        force: whether to overwrite the destination file if it exists.\n        progress: whether to display a progress bar.\n        leave_progress: whether to hide the progress bar once the copy is done.\n    \"\"\"\n\n    if progress and chunk_size is None:\n        chunk_size = 1024 * 1024\n\n    if isinstance(source, (str, os.PathLike)):\n        source_file = fsspec.open(str(source), \"rb\")\n    else:\n        source_file = source\n\n    if isinstance(destination, (str, os.PathLike)):\n        # adapt the file mode of the destination depending on the source file.\n        destination_mode = \"wb\"\n        if hasattr(source_file, \"mode\"):\n            destination_mode = \"wb\" if \"b\" in getattr(source_file, \"mode\") else \"w\"\n        elif isinstance(source_file, io.BytesIO):\n            destination_mode = \"wb\"\n        elif isinstance(source_file, io.StringIO):\n            destination_mode = \"w\"\n\n        destination_file = fsspec.open(str(destination), destination_mode)\n    else:\n        destination_file = destination\n\n    if not is_file(source_file):  # type: ignore\n        raise ValueError(f\"The file being copied does not exist or is not a file: {source}\")\n\n    if not force and is_file(destination_file):  # type: ignore\n        raise ValueError(f\"The destination file to copy already exists: {destination}\")\n\n    with source_file as source_stream:\n        with destination_file as destination_stream:\n            if chunk_size is None:\n                # copy without chunks\n                destination_stream.write(source_stream.read())  # type: ignore\n\n            else:\n                # copy with chunks\n\n                # determine the size of the source file\n                source_size = None\n                if progress:\n                    source_size = get_size(source)\n\n                pbar = None\n                if progress:\n                    tqdm = _import_tqdm()\n\n                    if tqdm is None:\n                        raise ImportError(\n                            \"If the progress bar is enabled, you must have `tqdm` \"\n                            \"installed: `conda install tqdm`.\"\n                        )\n                    else:\n                        # init progress bar\n                        pbar = tqdm(\n                            total=source_size,\n                            leave=leave_progress,\n                            disable=not progress,\n                            unit=\"B\",\n                            unit_divisor=1024,\n                            unit_scale=True,\n                        )\n\n                # start the loop\n                while True:\n                    data = source_stream.read(chunk_size)  # type: ignore\n                    if not data:\n                        break\n                    destination_stream.write(data)  # type: ignore\n\n                    if pbar is not None:\n                        pbar.update(chunk_size)\n\n                if pbar is not None:\n                    pbar.close()\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.fs.exists","title":"<code>exists(path)</code>","text":"<p>Check whether a file or a directory exists.</p> <p>Important: File-like object always exists.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, os.PathLike, fsspec.core.OpenFile, io.IOBase]</code> <p>a path supported by <code>fsspec</code> such as local, s3, gcs, etc.</p> required Source code in <code>datamol/utils/fs.py</code> <pre><code>def exists(path: Union[str, os.PathLike, fsspec.core.OpenFile, io.IOBase]):\n\"\"\"Check whether a file or a directory exists.\n\n    Important: File-like object always exists.\n\n    Args:\n        path: a path supported by `fsspec` such as local, s3, gcs, etc.\n    \"\"\"\n    return is_file(path) or is_dir(path)\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.fs.get_basename","title":"<code>get_basename(path)</code>","text":"<p>Get the basename of a file or a folder.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, os.PathLike]</code> <p>a path supported by <code>fsspec</code> such as local, s3, gcs, etc.</p> required Source code in <code>datamol/utils/fs.py</code> <pre><code>def get_basename(path: Union[str, os.PathLike]):\n\"\"\"Get the basename of a file or a folder.\n\n    Args:\n        path: a path supported by `fsspec` such as local, s3, gcs, etc.\n    \"\"\"\n    path = str(path)\n    mapper = get_mapper(path)\n    clean_path = path.rstrip(mapper.fs.sep)\n    return str(clean_path).split(mapper.fs.sep)[-1]\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.fs.get_cache_dir","title":"<code>get_cache_dir(app_name, suffix=None, create=True)</code>","text":"<p>Get a local cache directory for a given application name.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>The name of the application.</p> required <code>suffix</code> <code>Optional[str]</code> <p>A subdirectory appended to the cache dir.</p> <code>None</code> <code>create</code> <code>bool</code> <p>Whether to create the directory and its parents if it does not already exist.</p> <code>True</code> Source code in <code>datamol/utils/fs.py</code> <pre><code>def get_cache_dir(app_name: str, suffix: Optional[str] = None, create: bool = True):\n\"\"\"Get a local cache directory for a given application name.\n\n    Args:\n        app_name: The name of the application.\n        suffix: A subdirectory appended to the cache dir.\n        create: Whether to create the directory and its parents if it does not\n            already exist.\n    \"\"\"\n\n    cache_dir = pathlib.Path(platformdirs.user_cache_dir(appname=app_name))\n\n    if suffix is not None:\n        cache_dir /= suffix\n\n    if create:\n        cache_dir.mkdir(exist_ok=True, parents=True)\n\n    return cache_dir\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.fs.get_extension","title":"<code>get_extension(path)</code>","text":"<p>Get the extension of a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, os.PathLike]</code> <p>a path supported by <code>fsspec</code> such as local, s3, gcs, etc.</p> required Source code in <code>datamol/utils/fs.py</code> <pre><code>def get_extension(path: Union[str, os.PathLike]):\n\"\"\"Get the extension of a file.\n\n    Args:\n        path: a path supported by `fsspec` such as local, s3, gcs, etc.\n    \"\"\"\n    basename = get_basename(path)\n    return basename.split(\".\")[-1]\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.fs.get_mapper","title":"<code>get_mapper(path)</code>","text":"<p>Get the fsspec mapper.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, os.PathLike]</code> <p>a path supported by <code>fsspec</code> such as local, s3, gcs, etc.</p> required Source code in <code>datamol/utils/fs.py</code> <pre><code>def get_mapper(path: Union[str, os.PathLike]):\n\"\"\"Get the fsspec mapper.\n\n    Args:\n        path: a path supported by `fsspec` such as local, s3, gcs, etc.\n    \"\"\"\n    return fsspec.get_mapper(str(path))\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.fs.get_protocol","title":"<code>get_protocol(path, fs=None)</code>","text":"<p>Return the name of the path protocol.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, os.PathLike]</code> <p>a path supported by <code>fsspec</code> such as local, s3, gcs, etc.</p> required Source code in <code>datamol/utils/fs.py</code> <pre><code>def get_protocol(path: Union[str, os.PathLike], fs: Optional[fsspec.AbstractFileSystem] = None):\n\"\"\"Return the name of the path protocol.\n\n    Args:\n        path: a path supported by `fsspec` such as local, s3, gcs, etc.\n    \"\"\"\n\n    if fs is None:\n        fs = get_mapper(path).fs\n\n    protocol = fs.protocol  # type: ignore\n\n    if \"s3\" in protocol:\n        return \"s3\"\n    elif \"gs\" in protocol:\n        return \"gs\"\n    elif isinstance(protocol, (tuple, list)):\n        return protocol[0]\n    return protocol\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.fs.get_size","title":"<code>get_size(file)</code>","text":"<p>Get the size of a file given its path. Return None if the size can't be retrieved.</p> Source code in <code>datamol/utils/fs.py</code> <pre><code>def get_size(file: Union[str, os.PathLike, io.IOBase, fsspec.core.OpenFile]) -&gt; Optional[int]:\n\"\"\"Get the size of a file given its path. Return None if the\n    size can't be retrieved.\n    \"\"\"\n\n    if isinstance(file, io.IOBase) and hasattr(file, \"name\"):\n        fs_local = fsspec.filesystem(\"file\")\n        file_size = fs_local.size(getattr(file, \"name\"))\n\n    elif isinstance(file, (str, os.PathLike)):\n        fs = get_mapper(str(file)).fs\n        file_size = fs.size(str(file))\n\n    elif isinstance(file, fsspec.core.OpenFile):\n        file_size = file.fs.size(file.path)\n\n    else:\n        file_size = None\n\n    return file_size\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.fs.glob","title":"<code>glob(path, detail=False, **kwargs)</code>","text":"<p>Find files by glob-matching.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>A glob-style path.</p> required Source code in <code>datamol/utils/fs.py</code> <pre><code>def glob(path: str, detail: bool = False, **kwargs) -&gt; List[str]:\n\"\"\"Find files by glob-matching.\n\n    Args:\n        path: A glob-style path.\n    \"\"\"\n    # Get the list of paths\n    fs = get_mapper(path).fs\n    paths = fs.glob(path, detail=detail, **kwargs)\n    paths = [fsspec.utils._unstrip_protocol(d, fs) for d in paths]\n    return paths\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.fs.is_dir","title":"<code>is_dir(path)</code>","text":"<p>Check whether a file exists.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, os.PathLike, fsspec.core.OpenFile, io.IOBase]</code> <p>a path supported by <code>fsspec</code> such as local, s3, gcs, etc.</p> required Source code in <code>datamol/utils/fs.py</code> <pre><code>def is_dir(path: Union[str, os.PathLike, fsspec.core.OpenFile, io.IOBase]):\n\"\"\"Check whether a file exists.\n\n    Args:\n        path: a path supported by `fsspec` such as local, s3, gcs, etc.\n    \"\"\"\n    if isinstance(path, fsspec.core.OpenFile):\n        return path.fs.isdir(path.path)\n\n    elif isinstance(path, (str, os.PathLike)):\n        mapper = get_mapper(str(path))\n        return mapper.fs.isdir(str(path))\n\n    else:\n        return False\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.fs.is_file","title":"<code>is_file(path)</code>","text":"<p>Check whether a file exists.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, os.PathLike, fsspec.core.OpenFile, io.IOBase]</code> <p>a path supported by <code>fsspec</code> such as local, s3, gcs, etc.</p> required Source code in <code>datamol/utils/fs.py</code> <pre><code>def is_file(path: Union[str, os.PathLike, fsspec.core.OpenFile, io.IOBase]):\n\"\"\"Check whether a file exists.\n\n    Args:\n        path: a path supported by `fsspec` such as local, s3, gcs, etc.\n    \"\"\"\n    if isinstance(path, fsspec.core.OpenFile):\n        return path.fs.isfile(path.path)\n\n    elif isinstance(path, (str, os.PathLike)):\n        mapper = get_mapper(str(path))\n        return mapper.fs.isfile(str(path))\n\n    else:\n        return False\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.fs.is_local_path","title":"<code>is_local_path(path)</code>","text":"<p>Check whether a path is local.</p> Source code in <code>datamol/utils/fs.py</code> <pre><code>def is_local_path(path: Union[str, os.PathLike]):\n\"\"\"Check whether a path is local.\"\"\"\n    return get_protocol(str(path)) == \"file\"\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.fs.join","title":"<code>join(*paths)</code>","text":"<p>Join paths together. The first element determine the filesystem to use (and so the separator.</p> <p>Parameters:</p> Name Type Description Default <code>*paths</code> <code>str</code> <p>a list of paths supported by <code>fsspec</code> such as local, s3, gcs, etc.</p> <code>()</code> Source code in <code>datamol/utils/fs.py</code> <pre><code>def join(*paths: str):\n\"\"\"Join paths together. The first element determine the\n    filesystem to use (and so the separator.\n\n    Args:\n        *paths: a list of paths supported by `fsspec` such as local, s3, gcs, etc.\n    \"\"\"\n    _paths = [str(path).rstrip(\"/\") for path in paths]\n    source_path = _paths[0]\n    fs = get_mapper(source_path).fs\n    full_path = fs.sep.join(_paths)\n    return full_path\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.fs.md5","title":"<code>md5(filepath)</code>","text":"<p>Return the md5 hash of a file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, os.PathLike]</code> <p>The path to the file to compute the MD5 hash on.</p> required Source code in <code>datamol/utils/fs.py</code> <pre><code>def md5(filepath: Union[str, os.PathLike]):\n\"\"\"Return the md5 hash of a file.\n\n    Args:\n        filepath: The path to the file to compute the MD5 hash on.\n    \"\"\"\n    with fsspec.open(filepath) as f:\n        file_hash = hashlib.md5()\n        file_hash.update(f.read())  # type: ignore\n        file_hash = file_hash.hexdigest()\n    return file_hash\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.fs.mkdir","title":"<code>mkdir(dir_path, exist_ok=False)</code>","text":"<p>Create a directory.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>Union[str, os.PathLike]</code> <p>The path of the directory to create.</p> required <code>exist_ok</code> <code>bool</code> <p>Whether to ignore the error if the directory already exists.</p> <code>False</code> Source code in <code>datamol/utils/fs.py</code> <pre><code>def mkdir(dir_path: Union[str, os.PathLike], exist_ok: bool = False):\n\"\"\"Create a directory.\n\n    Args:\n        dir_path: The path of the directory to create.\n        exist_ok: Whether to ignore the error if the directory\n            already exists.\n    \"\"\"\n    fs = get_mapper(str(dir_path)).fs\n    fs.mkdirs(str(dir_path), exist_ok=exist_ok)\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.jobs.JobRunner","title":"<code>JobRunner</code>","text":"Source code in <code>datamol/utils/jobs.py</code> <pre><code>class JobRunner:\n    def __init__(\n        self,\n        n_jobs: Optional[int] = -1,\n        batch_size: Union[int, str] = \"auto\",\n        prefer: Optional[str] = None,\n        progress: bool = False,\n        total: Optional[int] = None,\n        tqdm_kwargs: Optional[dict] = None,\n        **job_kwargs: Any,\n    ):\n\"\"\"\n        JobRunner with sequential/parallel regimes. The multiprocessing backend use joblib which\n        allows taking advantage of its features, while the progress bar use tqdm\n\n        Args:\n            n_jobs: Number of process. Use 0 or None to force sequential.\n                Use -1 to use all the available processors. For details see\n                https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation\n            batch_size: Whether to  batch `inputs_list`. You can specify batch_size when the length\n                of `inputs_list` is very large (&gt;100k elements). By default, the auto batching of joblib is used.\n            prefer: Choose from ['processes', 'threads'] or None. Default to None.\n                Soft hint to choose the default backend if no specific backend\n                was selected with the parallel_backend context manager. The\n                default process-based backend is 'loky' and the default\n                thread-based backend is 'threading'. Ignored if the ``backend``\n                parameter is specified.\n            progress: whether to display progress bar\n            total: The number of elements in the iterator. Only used when `progress` is True.\n            tqdm_kwargs: Any additional arguments supported by the `tqdm` progress bar.\n            **job_kwargs: Any additional arguments supported by `joblib.Parallel`.\n\n        Example:\n\n        ```python\n        import datamol as dm\n        runner = dm.JobRunner(n_jobs=4, progress=True, prefer=\"threads\")\n        results = runner(lambda x: x**2, [1, 2, 3, 4])\n        ```\n        \"\"\"\n\n        self.n_jobs = n_jobs\n        self.batch_size = batch_size\n        self.prefer = prefer\n        self.job_kwargs = job_kwargs\n        self.job_kwargs.update(n_jobs=self.n_jobs, prefer=self.prefer, batch_size=self.batch_size)\n        self.no_progress = not progress\n        self.total = total\n        self.tqdm_kwargs = tqdm_kwargs or {}\n\n    @property\n    def is_sequential(self):\n\"\"\"Check whether the job is sequential or parallel\"\"\"\n        return (self.n_jobs is None) or (self.n_jobs in [0, 1])\n\n    @staticmethod\n    def wrap_fn(fn: Callable, arg_type: Optional[str] = None, **fn_kwargs):\n\"\"\"Small wrapper around a callable to properly format it's argument\"\"\"\n\n        def _run(args: Any):\n            if arg_type == \"kwargs\":\n                fn_kwargs.update(**args)\n                return fn(**fn_kwargs)\n            elif arg_type == \"args\":\n                return fn(*args, **fn_kwargs)\n            return fn(args, **fn_kwargs)\n\n        return _run\n\n    def sequential(\n        self,\n        callable_fn: Callable,\n        data: Iterable[Any],\n        arg_type: Optional[str] = None,\n        **fn_kwargs,\n    ):\n\"\"\"\n        Run job in sequential version\n\n        Args:\n            callable_fn (callable): function to call\n            data (iterable): input data\n            arg_type (str, optional): function argument type ('arg'/None or 'args' or 'kwargs')\n            **fn_kwargs (dict, optional): optional keyword argument to pass to the callable funciton\n        \"\"\"\n        total_length = JobRunner.get_iterator_length(data)\n\n        if self.total is not None:\n            self.tqdm_kwargs[\"total\"] = self.total\n        elif \"total\" not in self.tqdm_kwargs:\n            self.tqdm_kwargs[\"total\"] = total_length\n\n        if \"disable\" not in self.tqdm_kwargs:\n            self.tqdm_kwargs[\"disable\"] = self.no_progress\n\n        results = [\n            JobRunner.wrap_fn(callable_fn, arg_type, **fn_kwargs)(dt)\n            for dt in tqdm(data, **self.tqdm_kwargs)\n        ]\n        return results\n\n    def parallel(\n        self,\n        callable_fn: Callable,\n        data: Iterable[Any],\n        arg_type: Optional[str] = None,\n        **fn_kwargs,\n    ):\n\"\"\"\n        Run job in parallel\n\n        Args:\n            callable_fn (callable): function to call\n            data (iterable): input data\n            arg_type (str, optional): function argument type ('arg'/None or 'args' or 'kwargs')\n            **fn_kwargs (dict, optional): optional keyword argument to pass to the callable funciton\n        \"\"\"\n\n        total_length = JobRunner.get_iterator_length(data)\n\n        if self.total is not None:\n            self.tqdm_kwargs[\"total\"] = self.total\n        elif \"total\" not in self.tqdm_kwargs:\n            self.tqdm_kwargs[\"total\"] = total_length\n\n        if \"disable\" not in self.tqdm_kwargs:\n            self.tqdm_kwargs[\"disable\"] = self.no_progress\n\n        runner = JobRunner._parallel_helper(**self.job_kwargs)\n        results = runner(**self.tqdm_kwargs)(\n            delayed(JobRunner.wrap_fn(callable_fn, arg_type, **fn_kwargs))(dt) for dt in data\n        )\n\n        return results\n\n    def __call__(self, *args, **kwargs):\n\"\"\"\n        Run job using the n_jobs attribute to determine regime\n        \"\"\"\n        if self.is_sequential:\n            return self.sequential(*args, **kwargs)\n        return self.parallel(*args, **kwargs)\n\n    @staticmethod\n    def _parallel_helper(**joblib_args):\nr\"\"\"\n        Parallel helper function for joblib with tqdm support\n        \"\"\"\n\n        def run(**tq_args):\n            def tmp(op_iter):\n                with _tqdm_callback(tqdm(**tq_args)):\n                    return Parallel(**joblib_args)(op_iter)\n\n            return tmp\n\n        return run\n\n    @staticmethod\n    def get_iterator_length(data):\n\"\"\"Attempt to get the length of an iterator\"\"\"\n        total_length = None\n        try:\n            total_length = len(data)\n        except TypeError:\n            # most likely a generator, ignore\n            pass\n        return total_length\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.jobs.JobRunner.is_sequential","title":"<code>is_sequential</code>  <code>property</code>","text":"<p>Check whether the job is sequential or parallel</p>"},{"location":"api/datamol.utils.html#datamol.utils.jobs.JobRunner.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Run job using the n_jobs attribute to determine regime</p> Source code in <code>datamol/utils/jobs.py</code> <pre><code>def __call__(self, *args, **kwargs):\n\"\"\"\n    Run job using the n_jobs attribute to determine regime\n    \"\"\"\n    if self.is_sequential:\n        return self.sequential(*args, **kwargs)\n    return self.parallel(*args, **kwargs)\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.jobs.JobRunner.__init__","title":"<code>__init__(n_jobs=-1, batch_size='auto', prefer=None, progress=False, total=None, tqdm_kwargs=None, **job_kwargs)</code>","text":"<p>JobRunner with sequential/parallel regimes. The multiprocessing backend use joblib which allows taking advantage of its features, while the progress bar use tqdm</p> <p>Parameters:</p> Name Type Description Default <code>n_jobs</code> <code>Optional[int]</code> <p>Number of process. Use 0 or None to force sequential. Use -1 to use all the available processors. For details see https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation</p> <code>-1</code> <code>batch_size</code> <code>Union[int, str]</code> <p>Whether to  batch <code>inputs_list</code>. You can specify batch_size when the length of <code>inputs_list</code> is very large (&gt;100k elements). By default, the auto batching of joblib is used.</p> <code>'auto'</code> <code>prefer</code> <code>Optional[str]</code> <p>Choose from ['processes', 'threads'] or None. Default to None. Soft hint to choose the default backend if no specific backend was selected with the parallel_backend context manager. The default process-based backend is 'loky' and the default thread-based backend is 'threading'. Ignored if the <code>backend</code> parameter is specified.</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to display progress bar</p> <code>False</code> <code>total</code> <code>Optional[int]</code> <p>The number of elements in the iterator. Only used when <code>progress</code> is True.</p> <code>None</code> <code>tqdm_kwargs</code> <code>Optional[dict]</code> <p>Any additional arguments supported by the <code>tqdm</code> progress bar.</p> <code>None</code> <code>**job_kwargs</code> <code>Any</code> <p>Any additional arguments supported by <code>joblib.Parallel</code>.</p> <code>{}</code> <p>Example:</p> <pre><code>import datamol as dm\nrunner = dm.JobRunner(n_jobs=4, progress=True, prefer=\"threads\")\nresults = runner(lambda x: x**2, [1, 2, 3, 4])\n</code></pre> Source code in <code>datamol/utils/jobs.py</code> <pre><code>def __init__(\n    self,\n    n_jobs: Optional[int] = -1,\n    batch_size: Union[int, str] = \"auto\",\n    prefer: Optional[str] = None,\n    progress: bool = False,\n    total: Optional[int] = None,\n    tqdm_kwargs: Optional[dict] = None,\n    **job_kwargs: Any,\n):\n\"\"\"\n    JobRunner with sequential/parallel regimes. The multiprocessing backend use joblib which\n    allows taking advantage of its features, while the progress bar use tqdm\n\n    Args:\n        n_jobs: Number of process. Use 0 or None to force sequential.\n            Use -1 to use all the available processors. For details see\n            https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation\n        batch_size: Whether to  batch `inputs_list`. You can specify batch_size when the length\n            of `inputs_list` is very large (&gt;100k elements). By default, the auto batching of joblib is used.\n        prefer: Choose from ['processes', 'threads'] or None. Default to None.\n            Soft hint to choose the default backend if no specific backend\n            was selected with the parallel_backend context manager. The\n            default process-based backend is 'loky' and the default\n            thread-based backend is 'threading'. Ignored if the ``backend``\n            parameter is specified.\n        progress: whether to display progress bar\n        total: The number of elements in the iterator. Only used when `progress` is True.\n        tqdm_kwargs: Any additional arguments supported by the `tqdm` progress bar.\n        **job_kwargs: Any additional arguments supported by `joblib.Parallel`.\n\n    Example:\n\n    ```python\n    import datamol as dm\n    runner = dm.JobRunner(n_jobs=4, progress=True, prefer=\"threads\")\n    results = runner(lambda x: x**2, [1, 2, 3, 4])\n    ```\n    \"\"\"\n\n    self.n_jobs = n_jobs\n    self.batch_size = batch_size\n    self.prefer = prefer\n    self.job_kwargs = job_kwargs\n    self.job_kwargs.update(n_jobs=self.n_jobs, prefer=self.prefer, batch_size=self.batch_size)\n    self.no_progress = not progress\n    self.total = total\n    self.tqdm_kwargs = tqdm_kwargs or {}\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.jobs.JobRunner.get_iterator_length","title":"<code>get_iterator_length(data)</code>  <code>staticmethod</code>","text":"<p>Attempt to get the length of an iterator</p> Source code in <code>datamol/utils/jobs.py</code> <pre><code>@staticmethod\ndef get_iterator_length(data):\n\"\"\"Attempt to get the length of an iterator\"\"\"\n    total_length = None\n    try:\n        total_length = len(data)\n    except TypeError:\n        # most likely a generator, ignore\n        pass\n    return total_length\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.jobs.JobRunner.parallel","title":"<code>parallel(callable_fn, data, arg_type=None, **fn_kwargs)</code>","text":"<p>Run job in parallel</p> <p>Parameters:</p> Name Type Description Default <code>callable_fn</code> <code>callable</code> <p>function to call</p> required <code>data</code> <code>iterable</code> <p>input data</p> required <code>arg_type</code> <code>str</code> <p>function argument type ('arg'/None or 'args' or 'kwargs')</p> <code>None</code> <code>**fn_kwargs</code> <code>dict</code> <p>optional keyword argument to pass to the callable funciton</p> <code>{}</code> Source code in <code>datamol/utils/jobs.py</code> <pre><code>def parallel(\n    self,\n    callable_fn: Callable,\n    data: Iterable[Any],\n    arg_type: Optional[str] = None,\n    **fn_kwargs,\n):\n\"\"\"\n    Run job in parallel\n\n    Args:\n        callable_fn (callable): function to call\n        data (iterable): input data\n        arg_type (str, optional): function argument type ('arg'/None or 'args' or 'kwargs')\n        **fn_kwargs (dict, optional): optional keyword argument to pass to the callable funciton\n    \"\"\"\n\n    total_length = JobRunner.get_iterator_length(data)\n\n    if self.total is not None:\n        self.tqdm_kwargs[\"total\"] = self.total\n    elif \"total\" not in self.tqdm_kwargs:\n        self.tqdm_kwargs[\"total\"] = total_length\n\n    if \"disable\" not in self.tqdm_kwargs:\n        self.tqdm_kwargs[\"disable\"] = self.no_progress\n\n    runner = JobRunner._parallel_helper(**self.job_kwargs)\n    results = runner(**self.tqdm_kwargs)(\n        delayed(JobRunner.wrap_fn(callable_fn, arg_type, **fn_kwargs))(dt) for dt in data\n    )\n\n    return results\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.jobs.JobRunner.sequential","title":"<code>sequential(callable_fn, data, arg_type=None, **fn_kwargs)</code>","text":"<p>Run job in sequential version</p> <p>Parameters:</p> Name Type Description Default <code>callable_fn</code> <code>callable</code> <p>function to call</p> required <code>data</code> <code>iterable</code> <p>input data</p> required <code>arg_type</code> <code>str</code> <p>function argument type ('arg'/None or 'args' or 'kwargs')</p> <code>None</code> <code>**fn_kwargs</code> <code>dict</code> <p>optional keyword argument to pass to the callable funciton</p> <code>{}</code> Source code in <code>datamol/utils/jobs.py</code> <pre><code>def sequential(\n    self,\n    callable_fn: Callable,\n    data: Iterable[Any],\n    arg_type: Optional[str] = None,\n    **fn_kwargs,\n):\n\"\"\"\n    Run job in sequential version\n\n    Args:\n        callable_fn (callable): function to call\n        data (iterable): input data\n        arg_type (str, optional): function argument type ('arg'/None or 'args' or 'kwargs')\n        **fn_kwargs (dict, optional): optional keyword argument to pass to the callable funciton\n    \"\"\"\n    total_length = JobRunner.get_iterator_length(data)\n\n    if self.total is not None:\n        self.tqdm_kwargs[\"total\"] = self.total\n    elif \"total\" not in self.tqdm_kwargs:\n        self.tqdm_kwargs[\"total\"] = total_length\n\n    if \"disable\" not in self.tqdm_kwargs:\n        self.tqdm_kwargs[\"disable\"] = self.no_progress\n\n    results = [\n        JobRunner.wrap_fn(callable_fn, arg_type, **fn_kwargs)(dt)\n        for dt in tqdm(data, **self.tqdm_kwargs)\n    ]\n    return results\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.jobs.JobRunner.wrap_fn","title":"<code>wrap_fn(fn, arg_type=None, **fn_kwargs)</code>  <code>staticmethod</code>","text":"<p>Small wrapper around a callable to properly format it's argument</p> Source code in <code>datamol/utils/jobs.py</code> <pre><code>@staticmethod\ndef wrap_fn(fn: Callable, arg_type: Optional[str] = None, **fn_kwargs):\n\"\"\"Small wrapper around a callable to properly format it's argument\"\"\"\n\n    def _run(args: Any):\n        if arg_type == \"kwargs\":\n            fn_kwargs.update(**args)\n            return fn(**fn_kwargs)\n        elif arg_type == \"args\":\n            return fn(*args, **fn_kwargs)\n        return fn(args, **fn_kwargs)\n\n    return _run\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.jobs.parallelized","title":"<code>parallelized(fn, inputs_list, scheduler='processes', n_jobs=-1, batch_size='auto', progress=False, arg_type='arg', total=None, tqdm_kwargs=None, **job_kwargs)</code>","text":"<p>Run a function in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable</code> <p>The function to run in parallel.</p> required <code>inputs_list</code> <code>Iterable[Any]</code> <p>List of inputs to pass to <code>fn</code>.</p> required <code>scheduler</code> <code>str</code> <p>Choose between [\"processes\", \"threads\"]. Defaults to None which uses the default joblib \"loky\" scheduler.</p> <code>'processes'</code> <code>n_jobs</code> <code>Optional[int]</code> <p>Number of process. Use 0 or None to force sequential.     Use -1 to use all the available processors. For details see     https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation</p> <code>-1</code> <code>batch_size</code> <code>Union[int, str]</code> <p>Whether to automatically batch <code>inputs_list</code>. You should only use it when the length of <code>inputs_list</code> is very large (&gt;100k elements). The length of <code>inputs_list</code> must also be defined.</p> <code>'auto'</code> <code>progress</code> <code>bool</code> <p>Display a progress bar. Defaults to False.</p> <code>False</code> <code>arg_type</code> <code>str</code> <p>One of [\"arg\", \"args\", \"kwargs]: - \"arg\": the input is passed as an argument: <code>fn(arg)</code> (default). - \"args\": the input is passed as a list: <code>fn(*args)</code>. - \"kwargs\": the input is passed as a map: <code>fn(**kwargs)</code>.</p> <code>'arg'</code> <code>total</code> <code>Optional[int]</code> <p>The number of elements in the iterator. Only used when <code>progress</code> is True.</p> <code>None</code> <code>tqdm_kwargs</code> <code>Optional[dict]</code> <p>Any additional arguments supported by the <code>tqdm</code> progress bar.</p> <code>None</code> <code>**job_kwargs</code> <code>Any</code> <p>Any additional arguments supported by <code>joblib.Parallel</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Sequence[Optional[Any]]</code> <p>The results of the execution as a list.</p> Source code in <code>datamol/utils/jobs.py</code> <pre><code>def parallelized(\n    fn: Callable,\n    inputs_list: Iterable[Any],\n    scheduler: str = \"processes\",\n    n_jobs: Optional[int] = -1,\n    batch_size: Union[int, str] = \"auto\",\n    progress: bool = False,\n    arg_type: str = \"arg\",\n    total: Optional[int] = None,\n    tqdm_kwargs: Optional[dict] = None,\n    **job_kwargs: Any,\n) -&gt; Sequence[Optional[Any]]:\n\"\"\"Run a function in parallel.\n\n    Args:\n        fn: The function to run in parallel.\n        inputs_list: List of inputs to pass to `fn`.\n        scheduler: Choose between [\"processes\", \"threads\"]. Defaults\n            to None which uses the default joblib \"loky\" scheduler.\n        n_jobs: Number of process. Use 0 or None to force sequential.\n                Use -1 to use all the available processors. For details see\n                https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation\n        batch_size: Whether to automatically batch `inputs_list`. You should only use it when the length\n            of `inputs_list` is very large (&gt;100k elements). The length of `inputs_list` must also be\n            defined.\n        progress: Display a progress bar. Defaults to False.\n        arg_type: One of [\"arg\", \"args\", \"kwargs]:\n            - \"arg\": the input is passed as an argument: `fn(arg)` (default).\n            - \"args\": the input is passed as a list: `fn(*args)`.\n            - \"kwargs\": the input is passed as a map: `fn(**kwargs)`.\n        total: The number of elements in the iterator. Only used when `progress` is True.\n        tqdm_kwargs: Any additional arguments supported by the `tqdm` progress bar.\n        **job_kwargs: Any additional arguments supported by `joblib.Parallel`.\n\n    Returns:\n        The results of the execution as a list.\n    \"\"\"\n\n    runner = JobRunner(\n        n_jobs=n_jobs,\n        batch_size=batch_size,\n        progress=progress,\n        prefer=scheduler,\n        total=total,\n        tqdm_kwargs=tqdm_kwargs,\n        **job_kwargs,\n    )\n    return runner(fn, inputs_list, arg_type=arg_type)\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.jobs.parallelized_with_batches","title":"<code>parallelized_with_batches(fn, inputs_list, batch_size, scheduler='processes', n_jobs=-1, progress=False, arg_type='arg', total=None, tqdm_kwargs=None, flatten_results=True, joblib_batch_size='auto', **job_kwargs)</code>","text":"<p>Run a function in parallel using batches.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable</code> <p>The function to run in parallel. It must accept a batch of <code>inputs_list</code>.</p> required <code>inputs_list</code> <code>Iterable[Any]</code> <p>List of inputs to pass to <code>fn</code>.</p> required <code>batch_size</code> <code>int</code> <p>Batch size on which to run <code>fn</code>.</p> required <code>scheduler</code> <code>str</code> <p>Choose between [\"processes\", \"threads\"]. Defaults to None which uses the default joblib \"loky\" scheduler.</p> <code>'processes'</code> <code>n_jobs</code> <code>Optional[int]</code> <p>Number of process. Use 0 or None to force sequential.     Use -1 to use all the available processors. For details see     https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation</p> <code>-1</code> <code>progress</code> <code>bool</code> <p>Display a progress bar. Defaults to False.</p> <code>False</code> <code>arg_type</code> <code>str</code> <p>One of [\"arg\", \"args\", \"kwargs]: - \"arg\": the input is passed as an argument: <code>fn(arg)</code> (default). - \"args\": the input is passed as a list: <code>fn(*args)</code>. - \"kwargs\": the input is passed as a map: <code>fn(**kwargs)</code>.</p> <code>'arg'</code> <code>total</code> <code>Optional[int]</code> <p>The number of elements in the iterator. Only used when <code>progress</code> is True.</p> <code>None</code> <code>tqdm_kwargs</code> <code>Optional[dict]</code> <p>Any additional arguments supported by the <code>tqdm</code> progress bar.</p> <code>None</code> <code>flatten_results</code> <code>bool</code> <p>Whether to flatten the results.</p> <code>True</code> <code>joblib_batch_size</code> <code>Union[int, str]</code> <p>It corresponds to the <code>batch_size</code> argument of <code>dm.parallelized</code> that is forwarded to <code>joblib.Parallel</code> under the hood.</p> <code>'auto'</code> <code>**job_kwargs</code> <code>Any</code> <p>Any additional arguments supported by <code>joblib.Parallel</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Sequence[Optional[Any]]</code> <p>The results of the execution as a list.</p> Source code in <code>datamol/utils/jobs.py</code> <pre><code>def parallelized_with_batches(\n    fn: Callable,\n    inputs_list: Iterable[Any],\n    batch_size: int,\n    scheduler: str = \"processes\",\n    n_jobs: Optional[int] = -1,\n    progress: bool = False,\n    arg_type: str = \"arg\",\n    total: Optional[int] = None,\n    tqdm_kwargs: Optional[dict] = None,\n    flatten_results: bool = True,\n    joblib_batch_size: Union[int, str] = \"auto\",\n    **job_kwargs: Any,\n) -&gt; Sequence[Optional[Any]]:\n\"\"\"Run a function in parallel using batches.\n\n    Args:\n        fn: The function to run in parallel. It must accept a batch of `inputs_list`.\n        inputs_list: List of inputs to pass to `fn`.\n        batch_size: Batch size on which to run `fn`.\n        scheduler: Choose between [\"processes\", \"threads\"]. Defaults\n            to None which uses the default joblib \"loky\" scheduler.\n        n_jobs: Number of process. Use 0 or None to force sequential.\n                Use -1 to use all the available processors. For details see\n                https://joblib.readthedocs.io/en/latest/parallel.html#parallel-reference-documentation\n        progress: Display a progress bar. Defaults to False.\n        arg_type: One of [\"arg\", \"args\", \"kwargs]:\n            - \"arg\": the input is passed as an argument: `fn(arg)` (default).\n            - \"args\": the input is passed as a list: `fn(*args)`.\n            - \"kwargs\": the input is passed as a map: `fn(**kwargs)`.\n        total: The number of elements in the iterator. Only used when `progress` is True.\n        tqdm_kwargs: Any additional arguments supported by the `tqdm` progress bar.\n        flatten_results: Whether to flatten the results.\n        joblib_batch_size: It corresponds to the `batch_size` argument of `dm.parallelized` that\n            is forwarded to `joblib.Parallel` under the hood.\n        **job_kwargs: Any additional arguments supported by `joblib.Parallel`.\n\n    Returns:\n        The results of the execution as a list.\n    \"\"\"\n\n    def _batch_iterator(n: int, iterable: Iterable):\n        it = iter(iterable)\n        while True:\n            chunk_it = itertools.islice(it, n)\n            try:\n                first_el = next(chunk_it)\n            except StopIteration:\n                return\n            yield list(itertools.chain((first_el,), chunk_it))\n\n    # Compute the total number of batches of possible\n    if total is not None:\n        n_batches = total // batch_size\n        n_batches = max(n_batches, 1)\n    elif isinstance(inputs_list, collections.abc.Sized):\n        n_batches = len(inputs_list) // batch_size\n        n_batches = max(n_batches, 1)\n    else:\n        n_batches = None\n\n    # Make an iterator over batches so it works even with Iterator without a defined length\n    input_chunks = _batch_iterator(batch_size, inputs_list)\n\n    runner = JobRunner(\n        n_jobs=n_jobs,\n        batch_size=joblib_batch_size,\n        progress=progress,\n        prefer=scheduler,\n        total=n_batches,\n        tqdm_kwargs=tqdm_kwargs,\n        **job_kwargs,\n    )\n    results = runner(fn, input_chunks, arg_type=arg_type)\n\n    # Flatten the results\n    if flatten_results:\n        results = [item for sublist in results for item in sublist]\n\n    return results\n</code></pre>"},{"location":"api/datamol.utils.html#datamol.utils.perf.watch_duration","title":"<code>watch_duration</code>","text":"<p>A Python decorator to measure execution time with logging capability.</p> <p>Parameters:</p> Name Type Description Default <code>log</code> <code>bool</code> <p>Whether to log the measured duration.</p> <code>True</code> <code>log_human_duration</code> <code>bool</code> <p>Whether to log duration in a human way depending on the amount.</p> <code>True</code> <p>Example:</p> <pre><code>def fn(n):\n    for i in range(n):\n        print(i)\n        time.sleep(0.2)\n\nwith dm.utils.perf.watch_duration(log=True) as w:\n    fn(5)\n\nprint(w.duration)\n</code></pre> Source code in <code>datamol/utils/perf.py</code> <pre><code>class watch_duration:\n\"\"\"A Python decorator to measure execution time with logging capability.\n\n    Args:\n        log: Whether to log the measured duration.\n        log_human_duration: Whether to log duration in a human way\n            depending on the amount.\n\n    Example:\n\n    ```python\n    def fn(n):\n        for i in range(n):\n            print(i)\n            time.sleep(0.2)\n\n    with dm.utils.perf.watch_duration(log=True) as w:\n        fn(5)\n\n    print(w.duration)\n    ```\n    \"\"\"\n\n    def __init__(self, log: bool = True, log_human_duration: bool = True):\n        self.log = log\n        self.log_human_duration = log_human_duration\n\n        self.start = None\n        self.end = None\n        self.duration = None\n        self.duration_minutes = None\n\n    def __enter__(self):\n        self.start = time.time()\n        return self\n\n    def __exit__(self, *_):\n        assert self.start is not None\n\n        self.end = time.time()\n        self.duration = self.end - self.start\n        self.duration_minutes = self.duration / 60\n\n        if self.log:\n            if self.log_human_duration:\n                logger.info(f\"Duration {human_duration(self.duration)}.\")\n            else:\n                logger.info(f\"Duration {self.duration_minutes:.2f} minutes\")\n</code></pre>"},{"location":"api/datamol.viz.html","title":"<code>datamol.viz</code>","text":""},{"location":"api/datamol.viz.html#vizualize-molecule-in-2d-or-3d","title":"Vizualize molecule in 2D or 3D","text":"<p>Generate an image out of a molecule or a list of molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Union[List[dm.Mol], dm.Mol]</code> <p>One or a list of molecules.</p> required <code>legends</code> <code>Union[List[Union[str, None]], str, None]</code> <p>A string or a list of string as legend for every molecules.</p> <code>None</code> <code>n_cols</code> <code>int</code> <p>Number of molecules per column.</p> <code>4</code> <code>use_svg</code> <code>bool</code> <p>Whether to ouput an SVG (or a PNG).</p> <code>True</code> <code>mol_size</code> <code>Union[Tuple[int, int], int]</code> <p>A int or a tuple of int defining the size per molecule.</p> <code>(300, 300)</code> <code>highlight_atom</code> <code>Optional[List[List[int]]]</code> <p>the atoms to highlight.</p> <code>None</code> <code>highlight_bond</code> <code>Optional[List[List[int]]]</code> <p>The bonds to highlight.</p> <code>None</code> <code>outfile</code> <code>Optional[str]</code> <p>Path where to save the image (local or remote path).</p> <code>None</code> <code>max_mols</code> <code>int</code> <p>The maximum number of molecules to display.</p> <code>32</code> <code>copy</code> <code>bool</code> <p>Whether to copy the molecules or not.</p> <code>True</code> <code>indices</code> <code>bool</code> <p>Whether to draw the atom indices.</p> <code>False</code> <code>bond_indices</code> <code>bool</code> <p>Whether to draw the bond indices.</p> <code>False</code> <code>bond_line_width</code> <code>int</code> <p>The width of the bond lines.</p> <code>2</code> <code>legend_fontsize</code> <code>int</code> <p>Font size for the legend.</p> <code>16</code> <code>kekulize</code> <code>bool</code> <p>Run kekulization routine on molecules. Skipped if fails.</p> <code>True</code> <code>align</code> <code>Union[dm.Mol, str, bool]</code> <p>Whether to align the 2D coordinates of the molecules. - If set to True, align all molecules with <code>dm.align.auto_align_many()</code>. - If set to a molecule, it is used as a template for alignment with <code>dm.align.template_align()</code>. - If set to False, no alignment is performed. For a more custom alignment, we suggest using directly the module <code>dm.align</code> instead.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to the drawing function. See RDKit documentation related to <code>MolDrawOptions</code> for more details at https://www.rdkit.org/docs/source/rdkit.Chem.Draw.rdMolDraw2D.html.</p> <code>{}</code> Source code in <code>datamol/viz/_viz.py</code> <pre><code>def to_image(\n    mols: Union[List[dm.Mol], dm.Mol],\n    legends: Union[List[Union[str, None]], str, None] = None,\n    n_cols: int = 4,\n    use_svg: bool = True,\n    mol_size: Union[Tuple[int, int], int] = (300, 300),\n    highlight_atom: Optional[List[List[int]]] = None,\n    highlight_bond: Optional[List[List[int]]] = None,\n    outfile: Optional[str] = None,\n    max_mols: int = 32,\n    copy: bool = True,\n    indices: bool = False,\n    bond_indices: bool = False,\n    bond_line_width: int = 2,\n    stereo_annotations: bool = True,\n    legend_fontsize: int = 16,\n    kekulize: bool = True,\n    align: Union[dm.Mol, str, bool] = False,\n    **kwargs: Any,\n):\n\"\"\"Generate an image out of a molecule or a list of molecules.\n\n    Args:\n        mols: One or a list of molecules.\n        legends: A string or a list of string as legend for every molecules.\n        n_cols: Number of molecules per column.\n        use_svg: Whether to ouput an SVG (or a PNG).\n        mol_size: A int or a tuple of int defining the size per molecule.\n        highlight_atom: the atoms to highlight.\n        highlight_bond: The bonds to highlight.\n        outfile: Path where to save the image (local or remote path).\n        max_mols: The maximum number of molecules to display.\n        copy: Whether to copy the molecules or not.\n        indices: Whether to draw the atom indices.\n        bond_indices: Whether to draw the bond indices.\n        bond_line_width: The width of the bond lines.\n        legend_fontsize: Font size for the legend.\n        kekulize: Run kekulization routine on molecules. Skipped if fails.\n        align: Whether to align the 2D coordinates of the molecules.\n            - If set to True, align all molecules with `dm.align.auto_align_many()`.\n            - If set to a molecule, it is used as a template for alignment with `dm.align.template_align()`.\n            - If set to False, no alignment is performed.\n            For a more custom alignment, we suggest using directly the module `dm.align` instead.\n        **kwargs: Additional arguments to pass to the drawing function. See RDKit\n            documentation related to `MolDrawOptions` for more details at\n            https://www.rdkit.org/docs/source/rdkit.Chem.Draw.rdMolDraw2D.html.\n    \"\"\"\n\n    if isinstance(mol_size, int):\n        mol_size = (mol_size, mol_size)\n\n    if isinstance(mols, dm.Mol):\n        mols = [mols]\n\n    if isinstance(legends, str):\n        legends = [legends]\n\n    if copy:\n        mols = [dm.copy_mol(mol) for mol in mols]\n\n    if max_mols is not None:\n        mols = mols[:max_mols]\n\n        if legends is not None:\n            legends = legends[:max_mols]\n\n    # Whether to align the molecules\n    if isinstance(align, (dm.Mol, str)):\n        mols = [dm.align.template_align(mol, template=align) for mol in mols]\n    elif align is True:\n        mols = dm.align.auto_align_many(mols)\n\n    # Prepare molecules before drawing\n    mols = [prepare_mol_for_drawing(mol, kekulize=kekulize) for mol in mols]\n\n    _highlight_atom = highlight_atom\n    if highlight_atom is not None and isinstance(highlight_atom[0], int):\n        _highlight_atom = [highlight_atom]\n\n    _highlight_bond = highlight_bond\n    if highlight_bond is not None and isinstance(highlight_bond[0], int):\n        _highlight_bond = [highlight_bond]\n\n    # Don't make the image bigger than it\n    if len(mols) &lt; n_cols:\n        n_cols = len(mols)\n\n    draw_options = Draw.rdMolDraw2D.MolDrawOptions()\n    draw_options.legendFontSize = legend_fontsize\n    draw_options.addAtomIndices = indices\n    draw_options.addBondIndices = bond_indices\n    draw_options.addStereoAnnotation = stereo_annotations\n    draw_options.bondLineWidth = bond_line_width\n\n    # Add the custom drawing options.\n    _kwargs = {}\n    for k, v in kwargs.items():\n        if hasattr(draw_options, k):\n            setattr(draw_options, k, v)\n        else:\n            _kwargs[k] = v\n\n    image = Draw.MolsToGridImage(\n        mols,\n        legends=legends,\n        molsPerRow=n_cols,\n        useSVG=use_svg,\n        subImgSize=mol_size,\n        highlightAtomLists=_highlight_atom,\n        highlightBondLists=_highlight_bond,\n        drawOptions=draw_options,\n        **_kwargs,\n    )\n\n    if outfile is not None:\n        with fsspec.open(outfile, \"wb\") as f:\n            if use_svg:\n                if isinstance(image, str):\n                    # in a terminal process\n                    f.write(image.encode())  # type: ignore\n                else:\n                    # in a jupyter kernel process\n                    f.write(image.data.encode())  # type: ignore\n            else:\n                if isinstance(image, PIL.PngImagePlugin.PngImageFile):  # type: ignore\n                    # in a terminal process\n                    image.save(f)\n                else:\n                    # in a jupyter kernel process\n                    f.write(image.data)  # type: ignore\n\n    return image\n</code></pre> <p>Visualize the conformer(s) of a molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Chem.rdchem.Mol</code> <p>a molecule.</p> required <code>conf_id</code> <code>int</code> <p>The ID of the conformer to show. -1 shows the first conformer. Only works if <code>n_confs</code> is None.</p> <code>-1</code> <code>n_confs</code> <code>Union[int, List[int]]</code> <p>Can be a number of conformers to shows or a list of conformer indices. When None, only the first conformer is displayed. When -1, show all conformers.</p> <code>None</code> <code>align_conf</code> <code>bool</code> <p>Whether to align conformers together.</p> <code>True</code> <code>n_cols</code> <code>int</code> <p>Number of columns. Defaults to 3.</p> <code>3</code> <code>sync_views</code> <code>bool</code> <p>Wether to sync the multiple views.</p> <code>True</code> <code>remove_hs</code> <code>bool</code> <p>Wether to remove the hydrogens of the conformers.</p> <code>True</code> <code>width</code> <code>str</code> <p>The width of the returned view. Defaults to \"auto\".</p> <code>'auto'</code> Source code in <code>datamol/viz/_conformers.py</code> <pre><code>def conformers(\n    mol: Chem.rdchem.Mol,\n    conf_id: int = -1,\n    n_confs: Union[int, List[int]] = None,\n    align_conf: bool = True,\n    n_cols: int = 3,\n    sync_views: bool = True,\n    remove_hs: bool = True,\n    width: str = \"auto\",\n):\n\"\"\"Visualize the conformer(s) of a molecule.\n\n    Args:\n        mol: a molecule.\n        conf_id: The ID of the conformer to show. -1 shows\n            the first conformer. Only works if `n_confs` is None.\n        n_confs: Can be a number of conformers\n            to shows or a list of conformer indices. When None, only the first\n            conformer is displayed. When -1, show all conformers.\n        align_conf: Whether to align conformers together.\n        n_cols: Number of columns. Defaults to 3.\n        sync_views: Wether to sync the multiple views.\n        remove_hs: Wether to remove the hydrogens of the conformers.\n        width: The width of the returned view. Defaults to \"auto\".\n    \"\"\"\n\n    widgets = _get_ipywidgets()\n    nv = _get_nglview()\n\n    if mol.GetNumConformers() == 0:\n        raise ValueError(\n            \"The molecule has 0 conformers. You can generate conformers with `dm.conformers.generate(mol)`.\"\n        )\n\n    # Clone the molecule\n    mol = copy.deepcopy(mol)\n\n    if remove_hs:\n        mol = Chem.RemoveHs(mol)  # type: ignore\n    else:\n        mol = Chem.AddHs(mol)  # type: ignore\n\n    if n_confs is None:\n        return nv.show_rdkit(mol, conf_id=conf_id)\n\n    # If n_confs is int, convert to list of conformer IDs\n    if n_confs == -1:\n        n_confs = [conf.GetId() for conf in mol.GetConformers()]\n    elif isinstance(n_confs, int):\n        if n_confs &gt; mol.GetNumConformers():\n            n_confs = mol.GetNumConformers()\n        n_confs = list(range(n_confs))  # type: ignore\n\n    if align_conf:\n        rdMolAlign.AlignMolConformers(mol, confIds=n_confs)\n\n    # Get number of rows\n    n_rows = len(n_confs) // n_cols\n    n_rows += 1 if (len(n_confs) % n_cols) &gt; 0 else 0\n\n    # Create a grid\n    grid = widgets.GridspecLayout(n_rows, n_cols)  # type: ignore\n\n    # Create and add views to the grid.\n    widget_coords = itertools.product(range(n_rows), range(n_cols))\n    views = []\n    for i, (conf_id, (x, y)) in enumerate(zip(n_confs, widget_coords)):\n        view = nv.show_rdkit(mol, conf_id=conf_id)\n        view.layout.width = width\n        view.layout.align_self = \"stretch\"\n        grid[x, y] = view\n        views.append(view)\n\n    # Sync views\n    if sync_views:\n        for view in views:\n            view._set_sync_camera(views)\n\n    return grid\n</code></pre>"},{"location":"api/datamol.viz.html#specific-plotting-functions","title":"Specific plotting functions","text":"Source code in <code>datamol/viz/_circle_grid.py</code> <pre><code>class MolsCircleGrid:\n    def __init__(\n        self,\n        center_mol: Chem.rdchem.Mol,\n        circle_mols: List[List[Chem.rdchem.Mol]],\n        legend: Optional[str] = None,\n        mol_size: Tuple[int, int] = (200, 200),\n        circle_margin: int = 50,\n        act_mapper: Optional[dict] = None,\n    ):\n\"\"\"Show molecules in concentric rings, with one molecule at the center\n\n        Args:\n            center_mol: Molecule at center\n            circle_mols: List of molecule for each concentric circle around the center mol\n            mol_size: Tuple of width and height for each molecule\n            circle_margin: Margin between the circle layers\n            act_mapper: Map each molecule to a dictionary of activity\n        \"\"\"\n        self.circle_mols = circle_mols\n        self.circle_count = len(self.circle_mols)\n        self.legend = legend or \"\"\n        self.margin = circle_margin\n        self.center_mol = center_mol\n        self.mol_size = mol_size\n        size = (max(mol_size) + self.margin) * (self.circle_count + 1)\n        self.size = size\n        self.image = Image.new(mode=\"RGBA\", size=(size, size), color=(255, 255, 255, 0))\n        self.midpoint = size // 2\n        self.draw = None\n        self.act_mapper = act_mapper or {}\n        self._draw()\n\n    def show(self, crop=False):\n        if crop:\n            crop_img = ImageOps.crop(self.image, border=1)\n        else:\n            crop_img = self.image\n        return crop_img.show()\n\n    def save(self, filename):\n        self.image.save(filename)\n\n    def _draw(self):\n\"\"\"Create circles and slices in-memory\"\"\"\n        draw = ImageDraw.Draw(self.image)\n        self.draw = draw\n        all_radius = self._draw_circles(draw)\n        self._draw_center_mol()\n        self._draw_ring_mols(all_radius)\n        font = None\n        w, h = draw.textsize(self.legend)\n        try:\n            fn = FontManager()\n            fontpath = fn.findfont(\"Droid sans\")\n            font = ImageFont.truetype(fontpath, 12 * self.size // 800)\n            w, h = font.getsize(self.legend)\n        except:\n            pass\n        draw.text(\n            ((self.size // 2 - w) - 2, self.size - 2 * h),\n            self.legend,\n            fill=\"black\",\n            font=font,\n        )\n        del draw\n        self.draw = None\n\n    def _repr_png_(self):\n        bio = io.BytesIO()\n        self.image.save(bio, format=\"PNG\")\n        return bio.getvalue()\n\n    def _draw_circles(self, draw):\n        if self.circle_count &lt;= 0:\n            return []\n        radius_step = int(self.midpoint / (self.circle_count + 1))\n        radius_list = []\n        full_range = range(0, self.size // 2, radius_step)\n\n        for i, radius in enumerate(full_range):\n            radius += self.margin // 2\n            bounding_box = [\n                (self.midpoint - radius, self.midpoint - radius),\n                (self.midpoint + radius, self.midpoint + radius),\n            ]\n            if radius &gt; self.margin:\n                transp = int(255 - (200 * (i - 1) / len(full_range)))\n                draw.arc(bounding_box, 0, 360, fill=(190, 190, 190, transp))\n            radius_list.append(radius + radius_step)\n        return radius_list\n\n    def _draw_mol_at(\n        self,\n        mol,\n        center_x,\n        center_y,\n        mol_size=None,\n        act_dict={},\n        center=False,\n        **kwargs: Any,\n    ):\n        img = mol\n        if mol_size is None:\n            mol_size = self.mol_size\n\n        if isinstance(mol, Chem.Mol):\n            img = Draw.MolToImage(mol, mol_size, kekulize=True, fitImage=True, **kwargs)\n\n        width, height = img.size\n        self.image.paste(img, (int(center_x - width / 2), int(center_y - height / 2)))\n        txt = []\n        for prop, propval in act_dict.items():\n            if not isinstance(propval, str):\n                propval = \"{:.2f}\".format(propval)\n            txt.append(f\"{prop}: {propval}\")\n        if txt and self.draw is not None:\n            txt = \"\\n\".join(txt)\n            font = None\n            w, h = self.draw.multiline_textsize(txt)\n            try:\n                fn = FontManager()\n                fontpath = fn.findfont(\"Droid sans\")\n                font = ImageFont.truetype(fontpath, 18 + center * 8)\n                w, h = self.draw.multiline_textsize(txt, font=font)\n            except:\n                pass\n\n    def _draw_center_mol(self):\n        self._draw_mol_at(\n            self.center_mol,\n            self.midpoint,\n            self.midpoint,\n            mol_size=[x + self.margin for x in self.mol_size],\n            act_dict=self.act_mapper.get(self.center_mol, {}),\n            center=True,\n        )\n\n    def _draw_ring_mols(self, radius_list):\n        for i, mols in enumerate(self.circle_mols):\n            radius = radius_list[i]\n            ni = len(mols)\n            rand_unit = random.random() * 2 * math.pi\n            for k, mol in enumerate(mols):\n                center_x = radius * math.cos(2 * k * math.pi / ni + rand_unit) + self.midpoint\n                center_y = radius * math.sin(2 * k * math.pi / ni + rand_unit) + self.midpoint\n                self._draw_mol_at(mol, center_x, center_y, act_dict=self.act_mapper.get(mol, {}))\n</code></pre> <p>Show molecules in concentric rings, with one molecule at the center</p> <p>Parameters:</p> Name Type Description Default <code>center_mol</code> <code>Chem.Mol</code> <p>Molecule at center</p> required <code>circle_mols</code> <code>list of list of &lt;Chem.Mol&gt;</code> <p>List of molecule for each concentric circle around the center mol</p> required <code>mol_size</code> <code>tuple</code> <p>Tuple of width and height for each molecule</p> <code>(200, 200)</code> <code>circle_margin</code> <code>int</code> <p>Margin between the circle layers</p> <code>50</code> <code>act_mapper</code> <code>dict</code> <p>Map each molecule to a dictionary of activity</p> <code>None</code> Source code in <code>datamol/viz/_circle_grid.py</code> <pre><code>def circle_grid(\n    center_mol: Chem.rdchem.Mol,\n    circle_mols: List[List[Chem.rdchem.Mol]],\n    legend: Optional[str] = None,\n    mol_size: Tuple[int, int] = (200, 200),\n    circle_margin: int = 50,\n    act_mapper: Optional[dict] = None,\n):\n\"\"\"Show molecules in concentric rings, with one molecule at the center\n\n    Args:\n        center_mol (Chem.Mol): Molecule at center\n        circle_mols (list of list of &lt;Chem.Mol&gt;): List of molecule for each concentric circle around the center mol\n        mol_size (tuple, optional): Tuple of width and height for each molecule\n        circle_margin (int, optional): Margin between the circle layers\n        act_mapper (dict): Map each molecule to a dictionary of activity\n    \"\"\"\n    return MolsCircleGrid(center_mol, circle_mols, legend, mol_size, circle_margin, act_mapper)\n</code></pre>"},{"location":"api/datamol.viz.html#datamol.viz._circle_grid.MolsCircleGrid.__init__","title":"<code>__init__(center_mol, circle_mols, legend=None, mol_size=(200, 200), circle_margin=50, act_mapper=None)</code>","text":"<p>Show molecules in concentric rings, with one molecule at the center</p> <p>Parameters:</p> Name Type Description Default <code>center_mol</code> <code>Chem.rdchem.Mol</code> <p>Molecule at center</p> required <code>circle_mols</code> <code>List[List[Chem.rdchem.Mol]]</code> <p>List of molecule for each concentric circle around the center mol</p> required <code>mol_size</code> <code>Tuple[int, int]</code> <p>Tuple of width and height for each molecule</p> <code>(200, 200)</code> <code>circle_margin</code> <code>int</code> <p>Margin between the circle layers</p> <code>50</code> <code>act_mapper</code> <code>Optional[dict]</code> <p>Map each molecule to a dictionary of activity</p> <code>None</code> Source code in <code>datamol/viz/_circle_grid.py</code> <pre><code>def __init__(\n    self,\n    center_mol: Chem.rdchem.Mol,\n    circle_mols: List[List[Chem.rdchem.Mol]],\n    legend: Optional[str] = None,\n    mol_size: Tuple[int, int] = (200, 200),\n    circle_margin: int = 50,\n    act_mapper: Optional[dict] = None,\n):\n\"\"\"Show molecules in concentric rings, with one molecule at the center\n\n    Args:\n        center_mol: Molecule at center\n        circle_mols: List of molecule for each concentric circle around the center mol\n        mol_size: Tuple of width and height for each molecule\n        circle_margin: Margin between the circle layers\n        act_mapper: Map each molecule to a dictionary of activity\n    \"\"\"\n    self.circle_mols = circle_mols\n    self.circle_count = len(self.circle_mols)\n    self.legend = legend or \"\"\n    self.margin = circle_margin\n    self.center_mol = center_mol\n    self.mol_size = mol_size\n    size = (max(mol_size) + self.margin) * (self.circle_count + 1)\n    self.size = size\n    self.image = Image.new(mode=\"RGBA\", size=(size, size), color=(255, 255, 255, 0))\n    self.midpoint = size // 2\n    self.draw = None\n    self.act_mapper = act_mapper or {}\n    self._draw()\n</code></pre>"},{"location":"tutorials/Aligning.html","title":"Aligning Molecules","text":"In\u00a0[10]: Copied! <pre>import datamol as dm\n\ndata = dm.data.cdk2()[13:15]\nsmiles = data[\"smiles\"].iloc[:].tolist()\nmols = [dm.to_mol(s) for s in smiles]\n\ndm.to_image(mols, use_svg=False)\n</pre> import datamol as dm  data = dm.data.cdk2()[13:15] smiles = data[\"smiles\"].iloc[:].tolist() mols = [dm.to_mol(s) for s in smiles]  dm.to_image(mols, use_svg=False) Out[10]: In\u00a0[9]: Copied! <pre>aligned_list = dm.align.auto_align_many(mols)\ndm.to_image(aligned_list, use_svg=False)\n</pre> aligned_list = dm.align.auto_align_many(mols) dm.to_image(aligned_list, use_svg=False) Out[9]: In\u00a0[11]: Copied! <pre># Align the compounds within each cluster in a set of compounds\ndata = dm.data.cdk2()[0:24]\nsmiles = data[\"smiles\"].iloc[:].tolist()\nmols = [dm.to_mol(s) for s in smiles]\n\naligned_list = dm.align.auto_align_many(mols, partition_method=\"cluster\")\ndm.to_image(aligned_list, mol_size=(200, 150), use_svg=False)\n</pre> # Align the compounds within each cluster in a set of compounds data = dm.data.cdk2()[0:24] smiles = data[\"smiles\"].iloc[:].tolist() mols = [dm.to_mol(s) for s in smiles]  aligned_list = dm.align.auto_align_many(mols, partition_method=\"cluster\") dm.to_image(aligned_list, mol_size=(200, 150), use_svg=False) Out[11]: In\u00a0[12]: Copied! <pre># You can also align a compound to a template compound\n# In this example, we want to align the compound mols[0] with the compound mols[7]\nmols[0]\n</pre> # You can also align a compound to a template compound # In this example, we want to align the compound mols[0] with the compound mols[7] mols[0] Out[12]: In\u00a0[13]: Copied! <pre>mols[7]\n</pre> mols[7] Out[13]: In\u00a0[14]: Copied! <pre>mol_aligned = dm.align.template_align(mols[0], template=mols[7])\nmol_aligned\n</pre> mol_aligned = dm.align.template_align(mols[0], template=mols[7]) mol_aligned Out[14]:"},{"location":"tutorials/Aligning.html#Aligning-Molecules","title":"Aligning Molecules\u00b6","text":"<p>One of the most important things enabling us to have success in drug discovery is understanding structure-activity relationship (SAR). This is a foundation that explains how the structure of a molecule relates to its biological activity. Here is an excerpt from CDDVault that explains the importance of SAR in drug discovery:</p> <p>\u201dSAR depends on the recognition of which structural characteristics correlate with chemical and biological reactivity. Thus the ability to draw conclusions about an unknown compound depends upon both the structural features that can be characterized as well as the database of molecules against which they are compared. When combined with appropriate professional judgment, SAR can be a powerful tool for understanding functional implications when similarities are found. For example, in the case of risk assessment of uncharacterized compounds, data from the most sensitive toxicological endpoints should be included in the analysis, such as carcinogenicity or cardiotoxicity.\u201d</p> <p>This is where aligning molecules can be useful. Given the importance of structure, aligning molecules is generally useful for a few things:</p> <ol> <li>Aligning molecules makes it easier to visualize and highlight substructures</li> <li>It can help you identify and understand any shared structures between drug candidates</li> <li>It can help you identify any potential activity patterns<ol> <li>For example, when analyzing activity cliffs - \u201cdefined as pairs or groups of structurally similar compounds that are active against the same target but have large differences in potency. Activity cliffs capture chemical modifications that strongly influence biological activity\u201d. An example of some compounds with activity cliffs and their structural differences highlighted are shown below:</li> </ol> </li> </ol> <p></p> <p>Source</p> <p>Note: The concept of an activity cliff seems simple in this example, however, in practice it is extremely complicated to represent them computationally and derive a systematic approach for identification. Read more about the evolving concept of activity cliffs here.</p> <p>As an example to show you how alignment makes visualization easier, please see the image below. The alignment of this sample dataset makes it extremely easy to identify the core structure of 3 rings which are common in all compounds.</p> <p></p> <p>Source</p>"},{"location":"tutorials/Aligning.html#Tutorial","title":"Tutorial\u00b6","text":"<p>This tutorial will show you how to:</p> <ol> <li>Partition a list of molecules into clusters sharing a common scaffold of a common core, then align the molecules to that common core.<ol> <li>Note: this function will compute the list of smiles/smarts representative of each cluster first.</li> </ol> </li> <li>Aligning molecules according to a template molecule</li> </ol>"},{"location":"tutorials/Aligning.html#Datamol-example","title":"Datamol example\u00b6","text":""},{"location":"tutorials/Aligning.html#References","title":"References\u00b6","text":"<ul> <li>TeachOpenCADD</li> <li>RDKit Cookbook</li> </ul>"},{"location":"tutorials/Clustering.html","title":"Clustering Molecules","text":"In\u00a0[1]: Copied! <pre>import operator\n\nimport datamol as dm\nimport numpy as np\n\nfrom rdkit import Chem\nfrom rdkit.Chem import DataStructs\nfrom rdkit.ML.Cluster import Butina\nfrom rdkit.SimDivFilters.rdSimDivPickers import MaxMinPicker\n\n### Clustering compounds\n\n# Get some mols\ndata = dm.data.freesolv()\nsmiles = data[\"smiles\"].iloc[:].tolist()\nmols = [Chem.MolFromSmiles(s) for s in smiles]\n\n# Create fingerprints\nfps = [Chem.RDKFingerprint(x) for x in mols]\n\n# Calculate distance matrix\ndists = []\nn_mols = len(mols)\n\nfor i in range(1, n_mols):\n    dist = DataStructs.cDataStructs.BulkTanimotoSimilarity(fps[i], fps[:i], returnDistance=True)\n    dists.extend([x for x in dist])\n\ncutoff = 0.2\n\n# now cluster the data\ncluster_indices = Butina.ClusterData(dists, n_mols, cutoff, isDistData=True)\ncluster_mols = [operator.itemgetter(*cluster)(mols) for cluster in cluster_indices]\n\n# Make single mol cluster a list\ncluster_mols = [[c] if isinstance(c, Chem.rdchem.Mol) else c for c in cluster_mols]\n\n### Pick diverse compounds\n\n# Get some mols\ndata = dm.data.freesolv()\nsmiles = data[\"smiles\"].iloc[:].tolist()\nmols = [Chem.MolFromSmiles(s) for s in smiles]\n\n# Calculate fingerprints\nfps = [Chem.RDKFingerprint(x) for x in mols]\n\n\ndef distij(i, j, features=fps):\n    return 1.0 - DataStructs.cDataStructs.TanimotoSimilarity(fps[i], fps[j])\n\n\nnpick = 10\nseed = 0\n\npicker = MaxMinPicker()\ninitial_picks = []\npicked_inds = picker.LazyPick(distij, len(mols), npick, firstPicks=initial_picks, seed=seed)\npicked_inds = np.array(picked_inds)\npicked_mols = [mols[x] for x in picked_inds]\n\npicked_inds, picked_mols\n</pre> import operator  import datamol as dm import numpy as np  from rdkit import Chem from rdkit.Chem import DataStructs from rdkit.ML.Cluster import Butina from rdkit.SimDivFilters.rdSimDivPickers import MaxMinPicker  ### Clustering compounds  # Get some mols data = dm.data.freesolv() smiles = data[\"smiles\"].iloc[:].tolist() mols = [Chem.MolFromSmiles(s) for s in smiles]  # Create fingerprints fps = [Chem.RDKFingerprint(x) for x in mols]  # Calculate distance matrix dists = [] n_mols = len(mols)  for i in range(1, n_mols):     dist = DataStructs.cDataStructs.BulkTanimotoSimilarity(fps[i], fps[:i], returnDistance=True)     dists.extend([x for x in dist])  cutoff = 0.2  # now cluster the data cluster_indices = Butina.ClusterData(dists, n_mols, cutoff, isDistData=True) cluster_mols = [operator.itemgetter(*cluster)(mols) for cluster in cluster_indices]  # Make single mol cluster a list cluster_mols = [[c] if isinstance(c, Chem.rdchem.Mol) else c for c in cluster_mols]  ### Pick diverse compounds  # Get some mols data = dm.data.freesolv() smiles = data[\"smiles\"].iloc[:].tolist() mols = [Chem.MolFromSmiles(s) for s in smiles]  # Calculate fingerprints fps = [Chem.RDKFingerprint(x) for x in mols]   def distij(i, j, features=fps):     return 1.0 - DataStructs.cDataStructs.TanimotoSimilarity(fps[i], fps[j])   npick = 10 seed = 0  picker = MaxMinPicker() initial_picks = [] picked_inds = picker.LazyPick(distij, len(mols), npick, firstPicks=initial_picks, seed=seed) picked_inds = np.array(picked_inds) picked_mols = [mols[x] for x in picked_inds]  picked_inds, picked_mols Out[1]: <pre>(array([352,   2,  10,  56,  61,  85,  92, 176, 262, 408]),\n [&lt;rdkit.Chem.rdchem.Mol at 0x7f7b9e6530a0&gt;,\n  &lt;rdkit.Chem.rdchem.Mol at 0x7f7b9e60f520&gt;,\n  &lt;rdkit.Chem.rdchem.Mol at 0x7f7b9e60f820&gt;,\n  &lt;rdkit.Chem.rdchem.Mol at 0x7f7b9e60e920&gt;,\n  &lt;rdkit.Chem.rdchem.Mol at 0x7f7b9e60e740&gt;,\n  &lt;rdkit.Chem.rdchem.Mol at 0x7f7b9e658940&gt;,\n  &lt;rdkit.Chem.rdchem.Mol at 0x7f7b9df20ca0&gt;,\n  &lt;rdkit.Chem.rdchem.Mol at 0x7f7b9df21240&gt;,\n  &lt;rdkit.Chem.rdchem.Mol at 0x7f7b9e650ee0&gt;,\n  &lt;rdkit.Chem.rdchem.Mol at 0x7f7b9df145e0&gt;])</pre> In\u00a0[2]: Copied! <pre>dm.to_image(picked_mols, mol_size=(150, 100), use_svg=False)\n</pre> dm.to_image(picked_mols, mol_size=(150, 100), use_svg=False) Out[2]: In\u00a0[3]: Copied! <pre>import datamol as dm\n\n# Load example dataset\ndata = dm.data.freesolv()\nsmiles = data[\"smiles\"].iloc[:].tolist()\nmols = [dm.to_mol(s) for s in smiles]\n\n# Cluster the mols\nclusters, mol_clusters = dm.cluster_mols(mols, cutoff=0.7)\n\n# Cluster #1\ndm.to_image(mol_clusters[0], mol_size=(150, 100), n_cols=6, max_mols=18, use_svg=False)\n</pre> import datamol as dm  # Load example dataset data = dm.data.freesolv() smiles = data[\"smiles\"].iloc[:].tolist() mols = [dm.to_mol(s) for s in smiles]  # Cluster the mols clusters, mol_clusters = dm.cluster_mols(mols, cutoff=0.7)  # Cluster #1 dm.to_image(mol_clusters[0], mol_size=(150, 100), n_cols=6, max_mols=18, use_svg=False) Out[3]: In\u00a0[4]: Copied! <pre># Cluster #2\ndm.to_image(mol_clusters[1], mol_size=(150, 100), n_cols=6, max_mols=18, use_svg=False)\n</pre> # Cluster #2 dm.to_image(mol_clusters[1], mol_size=(150, 100), n_cols=6, max_mols=18, use_svg=False) Out[4]: In\u00a0[5]: Copied! <pre># Pick a diverse set of molecules\nindices, picks = dm.pick_diverse(mols, npick=10)\ndm.to_image(picks, mol_size=(150, 100), use_svg=False)\n</pre> # Pick a diverse set of molecules indices, picks = dm.pick_diverse(mols, npick=10) dm.to_image(picks, mol_size=(150, 100), use_svg=False) Out[5]: In\u00a0[6]: Copied! <pre># Pick centroids from a set of molecules\nindices, centroids = dm.pick_centroids(mols, npick=18, threshold=0.7, method=\"sphere\", n_jobs=-1)\ndm.to_image(centroids, mol_size=(150, 100), n_cols=6, use_svg=False)\n</pre> # Pick centroids from a set of molecules indices, centroids = dm.pick_centroids(mols, npick=18, threshold=0.7, method=\"sphere\", n_jobs=-1) dm.to_image(centroids, mol_size=(150, 100), n_cols=6, use_svg=False) Out[6]: <p>Note: Datamol provides one method (Butina using Tanimoto/ECFP for distances computations) for clustering molecules. In practice, an infinite number of methods exist and the user should build them as needed. Please feel free to contribute to Datamol if you wish to add any specific methods that are useful!</p>"},{"location":"tutorials/Clustering.html#Clustering-Molecules","title":"Clustering Molecules\u00b6","text":"<p>\ud83d\udca1 Clustering - the act of grouping a set of objects in such a way that objects in the same group (called a\u00a0cluster) are more similar (in some sense) to each other than to those in other groups (clusters).</p> <p>One of the largest challenges in early-stage drug discovery is narrowing down the massive chemical space of approximately 10 to the power of 60 molecules (10^60) to a list of molecules that have the desired properties for a specific target of interest. This is where computational approaches come in, taking a large library of small molecules and reducing its size by filtering in/out molecules based on similarity, patterns, predicted physicochemical properties, specific rules, etc. This selection process allows scientists to focus on compounds with the highest chance of success before experimental testing in a lab, saving time and money.</p> <p>Clustering molecules is an extremely useful process where you can easily manipulate and subdivide large datasets to group compounds into smaller clusters with similar properties. Comparing molecules and their similarities can then be used to discover new molecules with optimal properties and desired biological activity.</p>"},{"location":"tutorials/Clustering.html#How-are-compounds-clustered?","title":"How are compounds clustered?\u00b6","text":"<p>Compounds can be clustered via multiple clustering algorithms. There are also multiple ways to measure similarity between compounds, and theoretically, any molecular descriptor can be used. *The current common approach for structural clustering is the Butina algorithm which can use multiple similarity measures. In Datamol, the measure set as the default is the Tanimoto similarity index, measured on a scale between 0 (not similar) to 1 (most similar). After clustering molecules, you can also identify centroids. These are essentially the molecules in the middle of the cluster and are frequently used to represent* the cluster as a whole.</p> <p>For a more detailed breakdown of clustering methods and their uses in computational chemistry, read here.</p> <p>Note: centroids are highlighted here only as an example. Centroid identification is not linked to clustering itself, and there are algorithms commonly utilized that have nothing to do with centroids (i.e. hierarchical clustering).</p>"},{"location":"tutorials/Clustering.html#Molecular-Fingerprints","title":"Molecular Fingerprints\u00b6","text":"<p>In order for us to perform machine learning techniques or statistical analyses on molecules, we must represent molecules as mathematical objects (i.e vectors). Molecular fingerprints essentially encode the structural characteristics of molecules in the form of vectors enabling us to subsequently leverage statistical techniques to uncover new insights.</p> <p>The most common fingerprint used today is ECFP4 (extended connectivity fingerprints), also known as the Morgan fingerprint. Here is a practical blog that explains what and how to use ECFP4.</p>"},{"location":"tutorials/Clustering.html#Tutorial","title":"Tutorial\u00b6","text":"<p>This tutorial will walk you through the following:</p> <ol> <li>Loading an example dataset</li> <li>Calculate fingerprints</li> <li>Then generate distance matrix</li> <li>Cluster with the Butina algorithm</li> <li>Pick diverse molecules from a list<ol> <li>Why is this useful?<ol> <li>Resource limitations generally prevent you from experimentally testing as many compounds as you want/are available. Therefore, you want to be able to collect as much information as possible through diversity. By selecting diverse molecules (i.e. one representative example from each chemical series in a list), you can quickly gain information about the effect of structural changes on in vitro activity while exploring a larger chemical space in fewer \u201cshots\u201d.</li> </ol> </li> </ol> </li> <li>Pick centroids from a set of molecules</li> </ol> <p>First, let\u2019s see what this process would look like on RDKit:</p>"},{"location":"tutorials/Clustering.html#RDKit-Example","title":"RDKit Example\u00b6","text":""},{"location":"tutorials/Clustering.html#Datamol-Example","title":"Datamol Example\u00b6","text":"<p>Note: Datamol abstracts away the explicit steps 2 (calculating fingerprints) and 3 (generating a distance matrix) of the tutorial</p>"},{"location":"tutorials/Clustering.html#Understanding-key-parameters","title":"Understanding key parameters\u00b6","text":"<ul> <li>Determining an appropriate threshold for cutoff<ul> <li>Butina uses distances (which is 1 - distance) and the cutoff is dependent on the distance metric used. As mentioned earlier, Datamol uses Tanimoto with ECFP fingerprint. Therefore the distance cutoff is 1 - Tanimoto.</li> <li>Generally speaking, if you have a very small distance cutoff, compounds must be extremely similar (i.e. high Tanimoto score) in order to be grouped into one cluster. Therefore, with a small distance cutoff, you\u2019ll get more clusters with fewer compounds per cluster. Vice versa is true.</li> </ul> </li> </ul> <p>Note: This is an extremely general overview, in reality, the output greatly depends on both the size and diversity of the dataset being used. There is no \u201cdefault\u201d cutoff that is set in Datamol and instead, each user should set cutoffs according to their specific dataset and use case.</p> <p>You can also see a more detailed definition of the methods, arguments and their returns, here.</p>"},{"location":"tutorials/Clustering.html#References","title":"References\u00b6","text":"<ul> <li>Macs in Chemistry - https://www.macinchem.org/reviews/clustering/clustering.php</li> <li>TeachOpenCADD - https://projects.volkamerlab.org/teachopencadd/talktorials/T005_compound_clustering.html#Picking-diverse-compounds</li> <li>https://jcheminf.biomedcentral.com/articles/10.1186/s13321-020-00445-4</li> <li>https://towardsdatascience.com/a-practical-introduction-to-the-use-of-molecular-fingerprints-in-drug-discovery-7f15021be2b1</li> </ul>"},{"location":"tutorials/Conformers.html","title":"Generating Conformers","text":"In\u00a0[1]: Copied! <pre>from rdkit import Chem\nfrom rdkit.Chem import AllChem\nfrom rdkit.Chem import rdDistGeom\nfrom rdkit.Chem import rdMolAlign\nfrom rdkit.Chem import rdMolDescriptors\nfrom rdkit.Chem import rdMolTransforms\nfrom rdkit.Chem import rdForceFieldHelpers\n\nfrom rdkit.Chem import PyMol\nimport copy\nimport numpy as np\n</pre> from rdkit import Chem from rdkit.Chem import AllChem from rdkit.Chem import rdDistGeom from rdkit.Chem import rdMolAlign from rdkit.Chem import rdMolDescriptors from rdkit.Chem import rdMolTransforms from rdkit.Chem import rdForceFieldHelpers  from rdkit.Chem import PyMol import copy import numpy as np In\u00a0[2]: Copied! <pre>m = Chem.MolFromSmiles(\"O=C(C)Oc1ccccc1C(=O)O\")\nm\n</pre> m = Chem.MolFromSmiles(\"O=C(C)Oc1ccccc1C(=O)O\") m Out[2]: In\u00a0[3]: Copied! <pre>m2 = Chem.AddHs(m)\nm2\n</pre> m2 = Chem.AddHs(m) m2 Out[3]: In\u00a0[4]: Copied! <pre>AllChem.EmbedMolecule(m2)\n</pre> AllChem.EmbedMolecule(m2) Out[4]: <pre>0</pre> In\u00a0[5]: Copied! <pre>m2\n</pre> m2 Out[5]: In\u00a0[6]: Copied! <pre>rotatable_bonds = Chem.rdMolDescriptors.CalcNumRotatableBonds(m2)\nrotatable_bonds\n</pre> rotatable_bonds = Chem.rdMolDescriptors.CalcNumRotatableBonds(m2) rotatable_bonds Out[6]: <pre>3</pre> In\u00a0[7]: Copied! <pre># Setup the parameters for the embedding\nparams = getattr(rdDistGeom, \"ETDG\")()\nparams.randomSeed = 0\nparams.enforceChirality = True\nparams.useRandomCoords = True\nparams.numThreads = 1\n</pre> # Setup the parameters for the embedding params = getattr(rdDistGeom, \"ETDG\")() params.randomSeed = 0 params.enforceChirality = True params.useRandomCoords = True params.numThreads = 1 In\u00a0[8]: Copied! <pre># EMbed conformers\nconfs = rdDistGeom.EmbedMultipleConfs(m2, numConfs=50, params=params)\n</pre> # EMbed conformers confs = rdDistGeom.EmbedMultipleConfs(m2, numConfs=50, params=params) In\u00a0[9]: Copied! <pre>len(confs)\n</pre> len(confs) Out[9]: <pre>50</pre> In\u00a0[10]: Copied! <pre># Minimize energy\nenergy_iterations = 200\nresults = rdForceFieldHelpers.UFFOptimizeMoleculeConfs(m2, maxIters=energy_iterations)\nenergies = [energy for _, energy in results]\nenergies = []\nfor conf in m2.GetConformers():\n    ff = rdForceFieldHelpers.UFFGetMoleculeForceField(m2, confId=conf.GetId())\n    energies.append(ff.CalcEnergy())\nenergies = np.array(energies)\n# Add the energy as a property to each conformers\n[conf.SetDoubleProp(\"rdkit_uff_energy\", energy) for energy, conf in zip(energies, m2.GetConformers())]\n\n# Now we reorder conformers according to their energies,\n# so the lowest energies conformers are first.\nmol_clone = copy.deepcopy(m2)\nordered_conformers = [\n    conf for _, conf in sorted(zip(energies, mol_clone.GetConformers()), key=lambda x: x[0])\n]\nm2.RemoveAllConformers()\n[m2.AddConformer(conf, assignId=True) for conf in ordered_conformers]\n</pre> # Minimize energy energy_iterations = 200 results = rdForceFieldHelpers.UFFOptimizeMoleculeConfs(m2, maxIters=energy_iterations) energies = [energy for _, energy in results] energies = [] for conf in m2.GetConformers():     ff = rdForceFieldHelpers.UFFGetMoleculeForceField(m2, confId=conf.GetId())     energies.append(ff.CalcEnergy()) energies = np.array(energies) # Add the energy as a property to each conformers [conf.SetDoubleProp(\"rdkit_uff_energy\", energy) for energy, conf in zip(energies, m2.GetConformers())]  # Now we reorder conformers according to their energies, # so the lowest energies conformers are first. mol_clone = copy.deepcopy(m2) ordered_conformers = [     conf for _, conf in sorted(zip(energies, mol_clone.GetConformers()), key=lambda x: x[0]) ] m2.RemoveAllConformers() [m2.AddConformer(conf, assignId=True) for conf in ordered_conformers] Out[10]: <pre>[0,\n 1,\n 2,\n 3,\n 4,\n 5,\n 6,\n 7,\n 8,\n 9,\n 10,\n 11,\n 12,\n 13,\n 14,\n 15,\n 16,\n 17,\n 18,\n 19,\n 20,\n 21,\n 22,\n 23,\n 24,\n 25,\n 26,\n 27,\n 28,\n 29,\n 30,\n 31,\n 32,\n 33,\n 34,\n 35,\n 36,\n 37,\n 38,\n 39,\n 40,\n 41,\n 42,\n 43,\n 44,\n 45,\n 46,\n 47,\n 48,\n 49]</pre> In\u00a0[11]: Copied! <pre># Align conformers to each other\nrdMolAlign.AlignMolConformers(m2)\nm2\n</pre> # Align conformers to each other rdMolAlign.AlignMolConformers(m2) m2 Out[11]: <p>As a beginner, this can be a bit overwhelming and complicated to get the hang of. Let\u2019s see how this would look in Datamol</p> In\u00a0[13]: Copied! <pre>import datamol as dm\n</pre> import datamol as dm In\u00a0[14]: Copied! <pre>smiles = \"O=C(C)Oc1ccccc1C(=O)O\"\nmol = dm.to_mol(smiles)\nmol\n</pre> smiles = \"O=C(C)Oc1ccccc1C(=O)O\" mol = dm.to_mol(smiles) mol Out[14]: In\u00a0[15]: Copied! <pre># generate conformers\nmol = dm.conformers.generate(mol, align_conformers=True)\nmol\n</pre> # generate conformers mol = dm.conformers.generate(mol, align_conformers=True) mol Out[15]: In\u00a0[16]: Copied! <pre># Get all conformers as a list\nconformers = mol.GetConformers()\n</pre> # Get all conformers as a list conformers = mol.GetConformers() In\u00a0[17]: Copied! <pre>len(conformers)\n</pre> len(conformers) Out[17]: <pre>50</pre> In\u00a0[18]: Copied! <pre># Get the 3D atom positions of the first conformer\npositions = mol.GetConformer(0).GetPositions()\npositions\n</pre> # Get the 3D atom positions of the first conformer positions = mol.GetConformer(0).GetPositions() positions Out[18]: <pre>array([[ 2.03936006, -1.45912965, -0.53172218],\n       [ 1.9925788 , -1.56446348,  0.71921383],\n       [ 3.17465024, -2.13438585,  1.41003403],\n       [ 0.83770987, -1.13908313,  1.35789793],\n       [-0.24737227, -0.60904676,  0.65495089],\n       [-0.31723469,  0.74706314,  0.41869327],\n       [-1.37632791,  1.30134851, -0.27275517],\n       [-2.40159499,  0.50563021, -0.74962797],\n       [-2.35444012, -0.85472732, -0.52586563],\n       [-1.27290921, -1.39633958,  0.17670332],\n       [-1.21424131, -2.82512313,  0.41699016],\n       [-0.25080752, -3.31946086,  1.04455633],\n       [-2.22014558, -3.68260765, -0.03978946]])</pre> In\u00a0[19]: Copied! <pre># If minimization has been enabled (default to True)\n# you can access the computed energy.\nconf = mol.GetConformer(0)\nprops = conf.GetPropsAsDict()\nprint(props)\n</pre> # If minimization has been enabled (default to True) # you can access the computed energy. conf = mol.GetConformer(0) props = conf.GetPropsAsDict() print(props) <pre>{'rdkit_UFF_energy': 35.39391759550579, 'rdkit_UFF_delta_energy': 0.0}\n</pre> In\u00a0[20]: Copied! <pre># Compute RMSD\nrmsd = dm.conformers.rmsd(mol)\nrmsd\n</pre> # Compute RMSD rmsd = dm.conformers.rmsd(mol) rmsd Out[20]: <pre>array([[6.61254163e-08, 1.01515980e+00, 1.01196417e+00, ...,\n        5.56023152e-02, 1.00244193e+00, 6.36410194e-02],\n       [1.01515980e+00, 4.67577303e-08, 3.61762165e-02, ...,\n        1.02178695e+00, 5.29240969e-02, 1.01919051e+00],\n       [1.01196417e+00, 3.61762165e-02, 4.67577303e-08, ...,\n        1.01924556e+00, 7.12401285e-02, 1.01739384e+00],\n       ...,\n       [5.56023152e-02, 1.02178695e+00, 1.01924556e+00, ...,\n        0.00000000e+00, 1.00778322e+00, 3.87585886e-02],\n       [1.00244193e+00, 5.29240969e-02, 7.12401285e-02, ...,\n        1.00778322e+00, 0.00000000e+00, 1.00438156e+00],\n       [6.36410194e-02, 1.01919051e+00, 1.01739384e+00, ...,\n        3.87585886e-02, 1.00438156e+00, 0.00000000e+00]])</pre> In\u00a0[21]: Copied! <pre>rmsd.shape\n</pre> rmsd.shape Out[21]: <pre>(50, 50)</pre> <p>In essentially one line of code, you can generate a list of conformers. What\u2019s important to understand are some of the key parameters that are factored into this process. In general, sticking with the defaults in Datamol will suffice in most cases, but if you want to make specific modifications, you can. If you\u2019re interested in learning more about all the algorithms underlying conformer generation, read this.</p> <p>A few parameters to highlight:</p> <ul> <li>n_confs - Specifying the number of conformers to generate. This is based on the number of rotatable bonds and, by default, this is set to 200 if there are more than 8 rotatable bonds and 50 if there are less than 8. Theoretically, there are an unlimited number of conformers that can be derived from a single rotatable bond, however, in practice, not all the conformer structures make sense since only \u201cstable\u201d conformers are relevant in this context. This is why the defaults are set in place. Hypothetically, if you only have 2 rotatable bonds and you set n_confs to 2,000,000, not only will this be computationally expensive but a lot of the conformers generated will start to have non-relevant structures that are not useful.</li> <li>add_hs - By default, hydrogen atoms are added before embedding because it is critical to generating high-quality 3D conformations.</li> <li>minimize_energy - Minimizing energy releases the strain of the generated conformation to the closest local minima enabling you to find a more relevant conformation. In other words, *finding the conformer that is most likely to exist*. There are multiple force fields that you can apply.</li> <li>method -  Within the ETKDG method, there are various versions that can be selected to generate conformers.</li> <li>energy_iterations -  This option allows you to specify how many iterations of conformer generation you want to go through if you have enabled energy minimization. In general, the more iterations you specify, the more accurate the conformers are. However, there is a trade-off between the number of iterations and computation speed. Running through 1000 iterations will be significantly more expensive computationally as opposed to 100 iterations.</li> <li>rms_cutoff is the max RMSD value for which two conformers are considered to be the same.</li> </ul>"},{"location":"tutorials/Conformers.html#Generating-Conformers","title":"Generating Conformers\u00b6","text":"<p>A drug-like molecule can exist in a variety of diverse 3D shapes depending on the number of rotatable bonds, bond order, torsion, and in general, its degree of freedom. Each individual 3D spatial arrangement of a molecule is defined as a *conformer* and each conformer may have  different properties (e.g. relative energy). This is why the sampling of the conformational space, often referred to as conformational search, is a key step to understand the 3D properties of a given compound. You must factor in all the possible conformers and their respective properties in order to achieve the best representation of a molecule. It is a necessary step in any virtual screening campaign.</p> <p>Note: You can see a good visualization of how the relative energy of conformers changes based on manual manipulation of bond angles here.</p> <p>A common term that you will see throughout this example is *RMSD* which stands for root-mean-square deviation. RMSD is widely used as a similarity measure when analyzing conformations: the smaller the RMSD between two conformers, the more similar in 3D spatial arrangement they are. Once conformers are generated, they are usually pruned on RMSD, meaning, structures that are redundant and essentially correspond to the same conformation are removed from the list.</p> <p>Note: RMSD is not the only measure of conformer similarity, and it does have its limitations. If you\u2019re interested in learning more about all the various ways in which chemical structural similarity can be measured, read more here.</p>"},{"location":"tutorials/Conformers.html#How-are-conformers-generated?","title":"How are conformers generated?\u00b6","text":"<p>The current default RDKit method used to generate conformers leverages various versions of experimental-torsion distance geometry with additional basic knowledge (ETKDG) created by Riniker and Landrum. From the RDKit book the default algorithm followed is:</p> <ol> <li>The molecule\u2019s distance bounds matrix is calculated based on the connection table and a set of rules.</li> <li>The bounds matrix is smoothed using a triangle-bounds smoothing algorithm.</li> <li>A random distance matrix that satisfies the bound's matrix is generated.</li> <li>This distance matrix is embedded in 3D dimensions (producing coordinates for each atom).</li> <li>The resulting coordinates are cleaned up somewhat using the \u201cdistance geometry force field\u201d, based on distance constraints from the bounds matrix.</li> </ol> <p>The first 5 steps describe the \u201cETDG\u201d approach. The additional \u201cK\u201d in ETKDG just defines further constraints from chemical knowledge such as \u201caromatic rings are to be flat or bonds connected to triple bonds are to be collinear\u201d. These additional constraints introduce a certain level of \u201cchemical awareness\u201d that helps generate correct conformers which are chemically and physically valid. Read more here, here and here.</p> <p></p> <p>*Source*</p>"},{"location":"tutorials/Conformers.html#Tutorial","title":"Tutorial\u00b6","text":"<p>Now let\u2019s start with a tutorial on how you would go about generating conformers via RDKit.</p>"},{"location":"tutorials/Conformers.html#RDKit-Example","title":"RDKit Example\u00b6","text":"<p>Below is an example of how you would go about generating conformers in RDKit.</p>"},{"location":"tutorials/Conformers.html#Datamol-Example","title":"Datamol Example\u00b6","text":""},{"location":"tutorials/Descriptors.html","title":"Descriptors","text":"In\u00a0[1]: Copied! <pre>import datamol as dm\n\n# Part 1: Obtain a list of molecules and visualize\n# Load sdf downloaded from Enamine with the flag as_df set to True\n# This will automatically create a 'smiles' column from the sdf file\ndata = dm.read_sdf(\"./data/Enamine_DNA_Libary_5530cmpds_20200831_SMALL.sdf\", as_df=True)\n\ndata[\"mol\"] = data[\"smiles\"].apply(dm.to_mol)\n\nmols = data[\"mol\"].tolist()\n\ndm.to_image(mols[:12], mol_size=(200, 150), use_svg=False)\n</pre> import datamol as dm  # Part 1: Obtain a list of molecules and visualize # Load sdf downloaded from Enamine with the flag as_df set to True # This will automatically create a 'smiles' column from the sdf file data = dm.read_sdf(\"./data/Enamine_DNA_Libary_5530cmpds_20200831_SMALL.sdf\", as_df=True)  data[\"mol\"] = data[\"smiles\"].apply(dm.to_mol)  mols = data[\"mol\"].tolist()  dm.to_image(mols[:12], mol_size=(200, 150), use_svg=False) Out[1]: In\u00a0[2]: Copied! <pre># Calculate a specific descriptor for a compound\nn_aromatic_atoms = dm.descriptors.n_aromatic_atoms(dm.copy_mol(mols[0]))\nprint(\"Number of aromatic atoms in the compound is\", n_aromatic_atoms)\n\nmols[0]\n</pre> # Calculate a specific descriptor for a compound n_aromatic_atoms = dm.descriptors.n_aromatic_atoms(dm.copy_mol(mols[0])) print(\"Number of aromatic atoms in the compound is\", n_aromatic_atoms)  mols[0] <pre>Number of aromatic atoms in the compound is 6\n</pre> Out[2]: In\u00a0[3]: Copied! <pre># Part 2: Calculate the relevant molecular properties for the Ro5 for the list\n\n# Calculate many descriptors for a compound\ndm.descriptors.compute_many_descriptors(mols[150])\n</pre> # Part 2: Calculate the relevant molecular properties for the Ro5 for the list  # Calculate many descriptors for a compound dm.descriptors.compute_many_descriptors(mols[150]) Out[3]: <pre>{'mw': 210.009913052,\n 'fsp3': 0.125,\n 'n_lipinski_hba': 5,\n 'n_lipinski_hbd': 1,\n 'n_rings': 2,\n 'n_hetero_atoms': 6,\n 'n_heavy_atoms': 14,\n 'n_rotatable_bonds': 1,\n 'n_radical_electrons': 0,\n 'tpsa': 71.66999999999999,\n 'qed': 0.7539078378657419,\n 'clogp': 0.7626199999999999,\n 'sas': 2.5248498164613675,\n 'n_aliphatic_carbocycles': 0,\n 'n_aliphatic_heterocyles': 0,\n 'n_aliphatic_rings': 0,\n 'n_aromatic_carbocycles': 0,\n 'n_aromatic_heterocyles': 2,\n 'n_aromatic_rings': 2,\n 'n_saturated_carbocycles': 0,\n 'n_saturated_heterocyles': 0,\n 'n_saturated_rings': 0}</pre> In\u00a0[4]: Copied! <pre># Batch compute many descriptors for a list of compounds\ndf = dm.descriptors.batch_compute_many_descriptors(mols)\ndf\n</pre> # Batch compute many descriptors for a list of compounds df = dm.descriptors.batch_compute_many_descriptors(mols) df Out[4]: mw fsp3 n_lipinski_hba n_lipinski_hbd n_rings n_hetero_atoms n_heavy_atoms n_rotatable_bonds n_radical_electrons tpsa ... sas n_aliphatic_carbocycles n_aliphatic_heterocyles n_aliphatic_rings n_aromatic_carbocycles n_aromatic_heterocyles n_aromatic_rings n_saturated_carbocycles n_saturated_heterocyles n_saturated_rings 0 122.048013 0.000000 3 2 1 3 9 1 0 55.98 ... 1.690816 0 0 0 0 1 1 0 0 0 1 133.063997 0.000000 3 3 2 3 10 0 0 54.70 ... 2.795444 0 0 0 1 1 2 0 0 0 2 169.040675 0.000000 3 3 2 4 11 0 0 54.70 ... 2.381662 0 0 0 1 1 2 0 0 0 3 152.004434 0.000000 3 1 2 4 10 0 0 45.75 ... 2.591944 0 0 0 0 2 2 0 0 0 4 133.063997 0.000000 3 3 2 3 10 0 0 54.70 ... 2.232651 0 0 0 1 1 2 0 0 0 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 876 337.092578 0.176471 4 1 2 7 24 5 0 55.40 ... 1.761027 0 0 0 2 0 2 0 0 0 877 335.109291 0.384615 7 5 1 10 23 7 0 113.68 ... 2.716945 0 0 0 1 0 1 0 0 0 878 426.216809 0.240000 7 1 5 7 32 5 0 65.77 ... 2.215072 0 1 1 2 2 4 0 1 1 879 460.087308 0.086957 7 0 5 9 32 6 0 82.52 ... 2.379198 0 0 0 2 3 5 0 0 0 880 312.163792 0.315789 3 1 3 4 23 5 0 32.34 ... 1.851829 0 1 1 2 0 2 0 0 0 <p>881 rows \u00d7 22 columns</p> In\u00a0[5]: Copied! <pre># Part 3: Investigate compliance with Ro5\n\ndf = df[df[\"mw\"] &lt;= 500]\ndf = df[df[\"n_lipinski_hba\"] &lt;= 10]\ndf = df[df[\"n_lipinski_hbd\"] &lt;= 5]\ndf = df[df[\"clogp\"] &lt;= 5]\ndf\n\n# 863 of the 881 compounds in the dataset satisfy all criteria in the rule of 5\n</pre> # Part 3: Investigate compliance with Ro5  df = df[df[\"mw\"] &lt;= 500] df = df[df[\"n_lipinski_hba\"] &lt;= 10] df = df[df[\"n_lipinski_hbd\"] &lt;= 5] df = df[df[\"clogp\"] &lt;= 5] df  # 863 of the 881 compounds in the dataset satisfy all criteria in the rule of 5 Out[5]: mw fsp3 n_lipinski_hba n_lipinski_hbd n_rings n_hetero_atoms n_heavy_atoms n_rotatable_bonds n_radical_electrons tpsa ... sas n_aliphatic_carbocycles n_aliphatic_heterocyles n_aliphatic_rings n_aromatic_carbocycles n_aromatic_heterocyles n_aromatic_rings n_saturated_carbocycles n_saturated_heterocyles n_saturated_rings 0 122.048013 0.000000 3 2 1 3 9 1 0 55.98 ... 1.690816 0 0 0 0 1 1 0 0 0 1 133.063997 0.000000 3 3 2 3 10 0 0 54.70 ... 2.795444 0 0 0 1 1 2 0 0 0 2 169.040675 0.000000 3 3 2 4 11 0 0 54.70 ... 2.381662 0 0 0 1 1 2 0 0 0 3 152.004434 0.000000 3 1 2 4 10 0 0 45.75 ... 2.591944 0 0 0 0 2 2 0 0 0 4 133.063997 0.000000 3 3 2 3 10 0 0 54.70 ... 2.232651 0 0 0 1 1 2 0 0 0 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 875 363.115381 0.157895 6 0 4 7 26 5 0 69.63 ... 2.148096 0 0 0 2 2 4 0 0 0 876 337.092578 0.176471 4 1 2 7 24 5 0 55.40 ... 1.761027 0 0 0 2 0 2 0 0 0 877 335.109291 0.384615 7 5 1 10 23 7 0 113.68 ... 2.716945 0 0 0 1 0 1 0 0 0 878 426.216809 0.240000 7 1 5 7 32 5 0 65.77 ... 2.215072 0 1 1 2 2 4 0 1 1 880 312.163792 0.315789 3 1 3 4 23 5 0 32.34 ... 1.851829 0 1 1 2 0 2 0 0 0 <p>863 rows \u00d7 22 columns</p> In\u00a0[10]: Copied! <pre>df[\"mw\"].isnull().sum()\n</pre> df[\"mw\"].isnull().sum() Out[10]: <pre>0</pre> In\u00a0[11]: Copied! <pre># Part 4: Reveal the statistics for the dataset of compounds using Ro5 as a filter. How many fulfill vs. violate Ro5?\n# Plotting the RO5 descriptors\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfig, axs = plt.subplots(ncols=4, figsize=(25, 4))\naxs = axs.flatten()\n\nsns.histplot(df, x=\"mw\", ax=axs[0])\nsns.histplot(df, x=\"n_lipinski_hba\", ax=axs[1])\nsns.histplot(df, x=\"n_lipinski_hbd\", ax=axs[2])\nsns.histplot(df, x=\"clogp\", ax=axs[3])\n</pre> # Part 4: Reveal the statistics for the dataset of compounds using Ro5 as a filter. How many fulfill vs. violate Ro5? # Plotting the RO5 descriptors  import matplotlib.pyplot as plt import seaborn as sns  fig, axs = plt.subplots(ncols=4, figsize=(25, 4)) axs = axs.flatten()  sns.histplot(df, x=\"mw\", ax=axs[0]) sns.histplot(df, x=\"n_lipinski_hba\", ax=axs[1]) sns.histplot(df, x=\"n_lipinski_hbd\", ax=axs[2]) sns.histplot(df, x=\"clogp\", ax=axs[3]) Out[11]: <pre>&lt;AxesSubplot: xlabel='clogp', ylabel='Count'&gt;</pre> <p>If you\u2019re curious to learn more about some of the other established rules in the drug discovery industry, feel free to run this list through a Google search:</p> <ul> <li>Rules of CNS</li> <li>BBB score</li> <li>Rule of Egan</li> <li>Rule-of-5</li> <li>Beyond Rule-of-5</li> <li>Rule-of-4</li> <li>Ghose Filter</li> <li>Zinc Rule</li> <li>Rule of GSK (4/400)</li> <li>Lead-Like Soft Rule</li> <li>Oprea\u2019s Rule</li> <li>Pfizer Rule (3/75)</li> <li>REOS Filter</li> <li>Rule-of-3</li> <li>Extended Rule-of-3</li> <li>Veber Filter</li> </ul> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/Descriptors.html#Descriptors","title":"Descriptors\u00b6","text":""},{"location":"tutorials/Descriptors.html#Molecular-Descriptors","title":"Molecular Descriptors\u00b6","text":"<p>Molecular descriptors\u00a0can be defined as mathematical representations of molecules\u2019 properties that are generated by algorithms. The numerical values of molecular descriptors are used to quantitatively describe the physical and chemical information of the molecules. An example of molecular descriptors is the LogP which is a quantitative representation of the\u00a0lipophilicity of the molecules, it is obtained by measuring the partitioning of the molecule between an aqueous phase and a lipophilic phase which consists usually of water/n-octanol. - source</p> <p>Molecular descriptors can generally be classified in four ways:</p> <p></p> <p>(source</p>"},{"location":"tutorials/Descriptors.html#Tutorial","title":"Tutorial\u00b6","text":"<p>In this tutorial, we\u2019ll show how descriptors can be useful as filters in the drug discovery process. This tutorial was inspired by the TeachOpenCADD talktorial, we highly encourage you to read through the theory, understand ADME and why we care about it in the drug discovery process from the talktorial before diving into this tutorial. It provides the necessary background information to fully understand the purpose of this tutorial.</p> <p>The set of descriptors that will be focused on today are:</p> <ul> <li>Molecular weight \u2264 500 Da</li> <li>Number of hydrogen bond acceptors (HBAs) \u2264 10</li> <li>Number of hydrogen bond donors (HBD) \u2264 5</li> <li>Calculated LogP (octanol-water coefficient) \u2264 5</li> </ul> <p>These descriptors and their limits are collectively known as Lipinski\u2019s rule of five (Ro5), this is a method used to estimate the bioavailability of a compound based solely on its chemical structure. If a molecule violates any of the rules listed above (i.e. a molecular weight of 700 Da), it\u2019s probable that the compound will exhibit poor absorption or permeation and subsequently be removed from your list.</p> <p>This tutorial will show you a real-world scenario of obtaining a dataset and subsequently filtering our compounds according to the Ro5.</p> <ul> <li>Part 1: Obtaining a virtual screening library from Enamine<ul> <li>The DNA library is designed to identify novel active compounds against proteins that are essential for DNA stability.  At 5530 compounds, this is one of Enamine\u2019s smaller libraries. The same functions could easily be applied to some of the larger libraries using Datamol\u2019s parallelize functions.</li> <li>Note: for this tutorial, we are loading a truncated VS Enamine library.</li> </ul> </li> <li>Part 2: Then calculate the relevant molecular properties for the Ro5 for the list</li> <li>Part 3: Investigate compliance with Ro5</li> <li>Part 4: And finally, revealing the statistics for the dataset of compounds using Ro5 as a filter. With this, we will be able to find the answer to our question; how many fulfill vs. violate Ro5?<ul> <li>Subsequently, we can show different ways of displaying the data to make it more visually appealing using Matplotlib</li> </ul> </li> </ul>"},{"location":"tutorials/Descriptors.html#References:","title":"References:\u00b6","text":"<ul> <li>TeachOpenCADD - https://projects.volkamerlab.org/teachopencadd/talktorials/T002_compound_adme.html?highlight=descriptors</li> <li>ADME criteria (Wikipedia\u00a0and\u00a0Mol Pharm. (2010), 7(5), 1388-1405)</li> <li>What are lead compounds? (Wikipedia)</li> <li>What is the LogP value? (Wikipedia)</li> <li>Lipinski et al.\u00a0\u201cExperimental and computational approaches to estimate solubility and permeability in drug discovery and development settings.\u201d (Adv. Drug Deliv. Rev. (1997), 23, 3-25)</li> </ul>"},{"location":"tutorials/Filesystem.html","title":"Datamol Filesystem Module","text":"<p>The filesystem module <code>datamol.fs</code> is not strictly related to molecule but it makes it very convenient to work with files both locally and remotely (AWS S3, GCS, HTTP, FTP, Git, etc) in a smooth and transparent manner. Under the hood the Datamol <code>fs</code> module is built on top of the library fsspec.</p> In\u00a0[1]: Copied! <pre>import tempfile\n\nimport datamol as dm\n</pre> import tempfile  import datamol as dm <p>First let's get temp directory</p> In\u00a0[2]: Copied! <pre>temp_dir = tempfile.mkdtemp()\ndm.fs.exists(temp_dir)\n</pre> temp_dir = tempfile.mkdtemp() dm.fs.exists(temp_dir) Out[2]: <pre>True</pre> <p>Create a directory and check if it has correctly been created.</p> In\u00a0[3]: Copied! <pre>subdir_path = dm.fs.join(temp_dir, \"subdir1\", \"subsubdir293\")\ndm.fs.mkdir(subdir_path, exist_ok=True)\n\ndm.fs.exists(subdir_path)\n</pre> subdir_path = dm.fs.join(temp_dir, \"subdir1\", \"subsubdir293\") dm.fs.mkdir(subdir_path, exist_ok=True)  dm.fs.exists(subdir_path) Out[3]: <pre>True</pre> <p>Copy a file from a source path to a destination path</p> In\u00a0[5]: Copied! <pre>destination_path = dm.fs.join(subdir_path, \"cdk2.sdf\")\ndm.fs.copy_file(\n    source=\"https://raw.githubusercontent.com/rdkit/rdkit/master/Docs/Book/data/cdk2.sdf\",\n    destination=destination_path,\n    progress=True,\n    force=True,\n)\n</pre> destination_path = dm.fs.join(subdir_path, \"cdk2.sdf\") dm.fs.copy_file(     source=\"https://raw.githubusercontent.com/rdkit/rdkit/master/Docs/Book/data/cdk2.sdf\",     destination=destination_path,     progress=True,     force=True, ) <pre>  0%|          | 0.00/156k [00:00&lt;?, ?B/s]</pre> <p>Now, we would like to copy an full directory tree to a given destination.</p> In\u00a0[6]: Copied! <pre>subdir2_path = dm.fs.join(temp_dir, \"subdir2\")\ndm.fs.copy_dir(\n    source=\"https://ftp.ncbi.nlm.nih.gov/pubchem/specifications/\",\n    destination=subdir2_path,\n    progress=True,\n)\n</pre> subdir2_path = dm.fs.join(temp_dir, \"subdir2\") dm.fs.copy_dir(     source=\"https://ftp.ncbi.nlm.nih.gov/pubchem/specifications/\",     destination=subdir2_path,     progress=True, ) <pre>  0%|          | 0/15 [00:00&lt;?, ?it/s]</pre> <p>Let's check the files have been copied correctly.</p> In\u00a0[7]: Copied! <pre>dm.fs.glob(dm.fs.join(subdir2_path, \"**\"))\n</pre> dm.fs.glob(dm.fs.join(subdir2_path, \"**\")) Out[7]: <pre>['file:///tmp/tmph5uqem6g/subdir2/README',\n 'file:///tmp/tmph5uqem6g/subdir2/pubchem.asn',\n 'file:///tmp/tmph5uqem6g/subdir2/pubchem.xjb',\n 'file:///tmp/tmph5uqem6g/subdir2/pubchem.xsd',\n 'file:///tmp/tmph5uqem6g/subdir2/pubchem_deposit.pdf',\n 'file:///tmp/tmph5uqem6g/subdir2/pubchem_deposit.txt',\n 'file:///tmp/tmph5uqem6g/subdir2/pubchem_fingerprints.pdf',\n 'file:///tmp/tmph5uqem6g/subdir2/pubchem_fingerprints.txt',\n 'file:///tmp/tmph5uqem6g/subdir2/pubchem_pug.pdf',\n 'file:///tmp/tmph5uqem6g/subdir2/pubchem_pug.txt',\n 'file:///tmp/tmph5uqem6g/subdir2/pubchem_sdtags.pdf',\n 'file:///tmp/tmph5uqem6g/subdir2/pubchem_sdtags.txt',\n 'file:///tmp/tmph5uqem6g/subdir2/pug.dtd',\n 'file:///tmp/tmph5uqem6g/subdir2/pug.xsd',\n 'file:///tmp/tmph5uqem6g/subdir2/pug_soap.readme.txt']</pre> <p>Retrieve the paths matching a path pattern</p> In\u00a0[9]: Copied! <pre>dm.fs.glob(\"https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/Daily/**\")[:5]\n</pre> dm.fs.glob(\"https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/Daily/**\")[:5] Out[9]: <pre>['https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/Daily/2022-11-18/',\n 'https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/Daily/2022-11-18/ASN/',\n 'https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/Daily/2022-11-18/ASN/Compound_083000001_083500000.asn.gz',\n 'https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/Daily/2022-11-18/ASN/Compound_083000001_083500000.asn.gz.md5',\n 'https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/Daily/2022-11-18/ASN/Compound_154500001_155000000.asn.gz']</pre> <p>Get the name of the file or directory for a given path</p> In\u00a0[10]: Copied! <pre>dm.fs.get_basename(\n    \"https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/Daily/2021-12-03/SDF/Compound_013500001_014000000.sdf.gz\"\n)\n</pre> dm.fs.get_basename(     \"https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/Daily/2021-12-03/SDF/Compound_013500001_014000000.sdf.gz\" ) Out[10]: <pre>'Compound_013500001_014000000.sdf.gz'</pre> In\u00a0[11]: Copied! <pre>dm.fs.get_basename(\"https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/Daily/2021-12-03\")\n</pre> dm.fs.get_basename(\"https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/Daily/2021-12-03\") Out[11]: <pre>'2021-12-03'</pre> <p>Get the extension of a given path</p> In\u00a0[12]: Copied! <pre>dm.fs.get_extension(\"s3://an-s3-bucket-random/subdir1/subdir2/hello.txt\")\n</pre> dm.fs.get_extension(\"s3://an-s3-bucket-random/subdir1/subdir2/hello.txt\") Out[12]: <pre>'txt'</pre> <p>Check whether a file or a directory exists</p> In\u00a0[13]: Copied! <pre>dm.fs.exists(\"https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/Daily/\")\n</pre> dm.fs.exists(\"https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/Daily/\") Out[13]: <pre>True</pre> <p>Check whether a file or a directory exists</p> In\u00a0[14]: Copied! <pre>dm.fs.exists(\"gs://a-gcs-bucket-random/subdir1/subdir2/hello.txt\")\n</pre> dm.fs.exists(\"gs://a-gcs-bucket-random/subdir1/subdir2/hello.txt\") Out[14]: <pre>False</pre> <p>Check whether a path is a file and exists</p> In\u00a0[15]: Copied! <pre>dm.fs.is_file(\n    \"https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/Daily/2021-12-03/SDF/Compound_013500001_014000000.sdf.gz\"\n)\n</pre> dm.fs.is_file(     \"https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/Daily/2021-12-03/SDF/Compound_013500001_014000000.sdf.gz\" ) Out[15]: <pre>False</pre> <p>Check whether a path is a directory and exists</p> In\u00a0[16]: Copied! <pre>dm.fs.is_dir(\"gs://a-gcs-bucket-random/subdir1/subdir2/\")\n</pre> dm.fs.is_dir(\"gs://a-gcs-bucket-random/subdir1/subdir2/\") Out[16]: <pre>False</pre> <p>Check whether a path is local or remote</p> In\u00a0[17]: Copied! <pre>dm.fs.is_local_path(\"/home/hello/a_subdir\")\n</pre> dm.fs.is_local_path(\"/home/hello/a_subdir\") Out[17]: <pre>True</pre> <p>Join paths together</p> In\u00a0[18]: Copied! <pre>data_dir = \"gs://awesome-data-bucket/data_dir\"\nfilename = \"molecules.sdf\"\ndm.fs.join(data_dir, filename)\n</pre> data_dir = \"gs://awesome-data-bucket/data_dir\" filename = \"molecules.sdf\" dm.fs.join(data_dir, filename) Out[18]: <pre>'gs://awesome-data-bucket/data_dir/molecules.sdf'</pre> <p>Get the size of a file (in byte)</p> In\u00a0[19]: Copied! <pre>dm.fs.get_size(\n    \"https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/CURRENT-Full/SDF/Compound_000000001_000500000.sdf.gz\"\n)\n</pre> dm.fs.get_size(     \"https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/CURRENT-Full/SDF/Compound_000000001_000500000.sdf.gz\" ) Out[19]: <pre>338352844</pre> <p>Get the MD5 checksum of a file</p> In\u00a0[20]: Copied! <pre>dm.fs.md5(\"https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/CURRENT-Full/README-Compound\")\n</pre> dm.fs.md5(\"https://ftp.ncbi.nlm.nih.gov/pubchem/Compound/CURRENT-Full/README-Compound\") Out[20]: <pre>'b2d7b30c1466ab9582df47b2664d04b5'</pre> In\u00a0[21]: Copied! <pre>dm.fs.get_cache_dir(app_name=\"datamol-demo\", suffix=\"subdir1\", create=False)\n</pre> dm.fs.get_cache_dir(app_name=\"datamol-demo\", suffix=\"subdir1\", create=False) Out[21]: <pre>PosixPath('/home/hadim/.cache/datamol-demo/subdir1')</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/Filesystem.html#Destructive-path-manipulation","title":"Destructive path manipulation\u00b6","text":"<p>The below examples are made locally for the purpose of the demo but all the function supports remote path (S3, GCS, etc).</p>"},{"location":"tutorials/Filesystem.html#Non-destructive-path-manipulation","title":"Non destructive path manipulation\u00b6","text":""},{"location":"tutorials/Filesystem.html#Cache-directory","title":"Cache directory\u00b6","text":"<p>It's often convenient to get the path of a persistent cache folder. Unfortunately this path will change depending on the OS you're working on. Datamol offers a function to easily retrieve the path of the \"official\" cache directory on which it's running.</p>"},{"location":"tutorials/Fragment.html","title":"Fragmenting Compounds","text":"In\u00a0[1]: Copied! <pre>from rdkit import Chem\nfrom rdkit.Chem.Draw import IPythonConsole, MolsToGridImage\nfrom rdkit.Chem import BRICS\nfrom rdkit.Chem import Recap\n\nfrom rdkit.Chem.Fraggle import FraggleSim\n\nsmiles = \"CCCOCc1cc(c2ncccc2)ccc1\"\nmol = Chem.MolFromSmiles(smiles)\n\nmol\n</pre> from rdkit import Chem from rdkit.Chem.Draw import IPythonConsole, MolsToGridImage from rdkit.Chem import BRICS from rdkit.Chem import Recap  from rdkit.Chem.Fraggle import FraggleSim  smiles = \"CCCOCc1cc(c2ncccc2)ccc1\" mol = Chem.MolFromSmiles(smiles)  mol Out[1]: In\u00a0[2]: Copied! <pre># Decompose compounds based on BRICS algorithm.\n# Calling dm.fragment.brics runs this algorithm, as well as fixes/sanitizes fragments in one line of code.\n\nbrics_frags = BRICS.BRICSDecompose(mol, returnMols=True, singlePass=True)\nbrics_frags = list(brics_frags)\nMolsToGridImage(brics_frags)\n\n# Recap, FraggleSim and rdMMPA can be run in a similar manner as the BRICS algorithm above.\n</pre> # Decompose compounds based on BRICS algorithm. # Calling dm.fragment.brics runs this algorithm, as well as fixes/sanitizes fragments in one line of code.  brics_frags = BRICS.BRICSDecompose(mol, returnMols=True, singlePass=True) brics_frags = list(brics_frags) MolsToGridImage(brics_frags)  # Recap, FraggleSim and rdMMPA can be run in a similar manner as the BRICS algorithm above. Out[2]: In\u00a0[3]: Copied! <pre>import datamol as dm\n\nsmiles = \"CCCOCc1cc(c2ncccc2)ccc1\"\nmol = dm.to_mol(smiles)\nmol\n</pre> import datamol as dm  smiles = \"CCCOCc1cc(c2ncccc2)ccc1\" mol = dm.to_mol(smiles) mol Out[3]: In\u00a0[4]: Copied! <pre># BRICS\nwith dm.without_rdkit_log():\n    frags = dm.fragment.brics(mol)\n\ndm.to_image(frags, mol_size=(250, 150), use_svg=False)\n</pre> # BRICS with dm.without_rdkit_log():     frags = dm.fragment.brics(mol)  dm.to_image(frags, mol_size=(250, 150), use_svg=False) Out[4]: In\u00a0[5]: Copied! <pre># FraggleSims\nwith dm.without_rdkit_log():\n    frags = dm.fragment.frag(mol)\n\ndm.to_image(frags, mol_size=(250, 150), use_svg=False)\n</pre> # FraggleSims with dm.without_rdkit_log():     frags = dm.fragment.frag(mol)  dm.to_image(frags, mol_size=(250, 150), use_svg=False) Out[5]: In\u00a0[6]: Copied! <pre># Recap\nwith dm.without_rdkit_log():\n    frags = dm.fragment.recap(mol)\n\ndm.to_image(frags, mol_size=(250, 150), use_svg=False)\n</pre> # Recap with dm.without_rdkit_log():     frags = dm.fragment.recap(mol)  dm.to_image(frags, mol_size=(250, 150), use_svg=False) Out[6]: <p>What you can also do is assemble some new molecules based on a list of fragments. This is how fragments are used as building blocks for larger, more optimized molecules. By having an understanding of the properties of the underlying fragments, you can essentially run a \u201cmix and match\u201d process to generate optimal molecules.</p> <p>Assembling molecules from fragments is computationally expensive. Make sure you use the parameters:</p> <ul> <li>*frags*</li> <li>max_n_mols</li> </ul> <p>To limit the number of fragments to work with and the number of molecules to be assembled.</p> In\u00a0[7]: Copied! <pre># Assembling new molecules based on a list of fragments\n# Get the fragment set of a molecule\nsmiles = \"CCCOCc1cc(c2ncccc2)ccc1\"\nmol = dm.to_mol(smiles)\n\nwith dm.without_rdkit_log():\n    frags = dm.fragment.brics(mol)\n\n# Limit the number of fragments to work with because assembling is computationally intensive.\nfrags = frags[:3]\n\n# Assemble 8 molecules from the list of fragments\nwith dm.without_rdkit_log():\n    mols = list(dm.fragment.assemble_fragment_order(frags, max_n_mols=8))\n\ndm.to_image(mols, mol_size=(250, 150), use_svg=False)\n</pre> # Assembling new molecules based on a list of fragments # Get the fragment set of a molecule smiles = \"CCCOCc1cc(c2ncccc2)ccc1\" mol = dm.to_mol(smiles)  with dm.without_rdkit_log():     frags = dm.fragment.brics(mol)  # Limit the number of fragments to work with because assembling is computationally intensive. frags = frags[:3]  # Assemble 8 molecules from the list of fragments with dm.without_rdkit_log():     mols = list(dm.fragment.assemble_fragment_order(frags, max_n_mols=8))  dm.to_image(mols, mol_size=(250, 150), use_svg=False) Out[7]: In\u00a0[8]: Copied! <pre># Decomposition\n# It's also possible to break a molecule based on a set of chemical transformation and gets the non-overlapping fragments and how they are linked\n\nwith dm.without_rdkit_log():\n    results = dm.fragment.break_mol(mol, randomize=False, mode=\"brics\", returnTree=True)\n\nresults\n</pre> # Decomposition # It's also possible to break a molecule based on a set of chemical transformation and gets the non-overlapping fragments and how they are linked  with dm.without_rdkit_log():     results = dm.fragment.break_mol(mol, randomize=False, mode=\"brics\", returnTree=True)  results Out[8]: <pre>(['CCC', 'O', 'C', 'c1ccncc1', 'c1ccccc1'],\n {'C',\n  'CCC',\n  'CCCOCc1cccc(-c2ccccn2)c1',\n  'Cc1cccc(-c2ccccn2)c1',\n  'O',\n  'OCc1cccc(-c2ccccn2)c1',\n  'c1ccc(-c2ccccn2)cc1',\n  'c1ccccc1',\n  'c1ccncc1'},\n &lt;networkx.classes.digraph.DiGraph at 0x7efe675c3850&gt;)</pre>"},{"location":"tutorials/Fragment.html#Fragmenting-Compounds","title":"Fragmenting Compounds\u00b6","text":""},{"location":"tutorials/Fragment.html#Background","title":"Background\u00b6","text":"<p>A fragment is essentially a small molecule that has a low molecular weight and small size, often representing a small part of a bigger, drug-like compound. These small compounds are of great importance in drug discovery, especially in the early stages. Fragments are used to identify small chemical and functional groups that bind, even if weakly, to the target of interest and thus serve as useful starting points in a medicinal chemistry campaign. Once identified, fragments act as building blocks and are subsequently chemically modified (addition/removal of specific chemical groups) to improve the overall interaction of the newly generated compounds with the target of interest.</p> <p>Generally speaking, fragments will follow the rule of three. However, this is not always the case. Different researchers will have their own definitions of what is deemed a fragment:</p> <ol> <li>Molecular weight of less than 300 Da</li> <li>ClogP value less than 3<ol> <li>ClogP is a well-established measure of a compound\u2019s hydrophilicity which is important for absorption, permeation, and other drug-related physical properties.</li> </ol> </li> <li>Less than 3 hydrogen donor and acceptor groups.</li> </ol> <p>Existing molecules can also be split into smaller fragments, a good visual is shown below of the fragmentation process:</p> <p></p> <p>*Source*</p>"},{"location":"tutorials/Fragment.html#Fragment-Based-Approaches-for-Compound-Optimization","title":"Fragment-Based Approaches for Compound Optimization\u00b6","text":"<p>Standard fragment-based approaches for compound optimization are:</p> <ol> <li>Fragment growing - adding chemical groups to the fragment to improve properties.</li> <li>Fragment merging/scaffold hopping - combining fragments that have an overlapped binding site.</li> <li>Fragment linking - linking two or more fragments together to drastically improve binding affinities.</li> </ol> <p>You can read more about these methods in detail here.</p>"},{"location":"tutorials/Fragment.html#Fragment-Generation","title":"Fragment Generation\u00b6","text":"<p>*Source*</p> <p>Fragments are essentially generated by breaking specified bonds in a larger molecule. There are multiple ways approaches that one can take to fragment a molecule. The methods covered below include; RECAP, BRICS, FraggleSim and AnyBreak.</p> <ol> <li>RECAP - Retrosynthetic Combinatorial Analysis Procedure<ol> <li>Alkyl groups smaller than five carbons and cyclic bonds are left intact while compounds are dissected based on 11 pre-specified bond types</li> </ol> </li> <li>BRICS - Breaking Retrosynthetically Interesting Chemical Substructures<ol> <li>In BRICS, compounds are dissected based on 16 bond types while considering the chemical environment and surrounding substructures.</li> <li>Both RECAP and BRICS are examples of systematic fragmentation</li> </ol> </li> <li>FraggleSim<ol> <li>RDKit uses the Fraggle similarity algorithm developed by Jameed Hussain and Gavin Harper of GSK. Read more about the details of the algorithm here and here.</li> </ol> </li> <li>AnyBreak<ol> <li>This method uses BRICS first and fallback to generating all possible fragmentation if it doesn't work.</li> </ol> </li> </ol> <p>Note: It\u2019s challenging to point to one method and refer to it as the status quo. The method you should use depends on what exactly you are trying to do with the fragments, the types of molecules you\u2019re working with, etc. Generally speaking, it is ideal to fragment a molecule in a way that is synthesizable in the lab, and each of the methods listed above has slight variations in their approach. There\u2019s no point fragmenting a molecule at certain bonds if these bonds have never been broken before in a lab setting, it\u2019s not realistic.</p> <p>Once molecules are fragmented, the next step is typically a matched molecular pair analysis (MMPA). This analysis compares the chemical structure of two molecules that only differ by a single chemical transformation (i.e. changing one functional group). MMPs are useful to analyze a large collection of compounds because the minimal structural differences make it much easier to interpret any observable changes in physical or biological properties. We will not cover MMPA\u2019s in this tutorial. See below for a visualization of a matched molecular pair:</p> <p></p> <p>Source</p> <p>Note: Sometimes the term fragment is used synonymously with scaffolds. However, scaffolds are better defined as key core structures of a compound, often critical and essential for binding, whereas a fragment may only partially match with a \u201ccore structure\u201d.</p>"},{"location":"tutorials/Fragment.html#Tutorial","title":"Tutorial\u00b6","text":"<p>Now let\u2019s walk through how you could do this in RDKit and then compare it with Datamol. Starting from a cluster of molecules, this tutorial will cover the following:</p> <ol> <li>Generate a list of all fragments in different ways as described above<ol> <li>RECAP, BRICS, FraggleSim</li> </ol> </li> <li>Show how to return the results as a hierarchy of nodes instead of just a visualized set of fragments allowing for more flexibility in the manipulation of the results</li> <li>Fragment molecules on specific bonds suitable for an MMP analysis</li> <li>Briefly exploring other manipulations<ol> <li>Assembling - assemble fragments to create new molecules. Limit the number of fragments you\u2019d work with because it\u2019s computationally intensive.</li> <li>Decomposition - break a molecule down to get non-overlapping fragments and how they are linked.</li> </ol> </li> </ol>"},{"location":"tutorials/Fragment.html#RDKit-Example","title":"RDKit Example\u00b6","text":""},{"location":"tutorials/Fragment.html#Datamol-Example","title":"Datamol Example\u00b6","text":""},{"location":"tutorials/Fragment.html#References","title":"References\u00b6","text":"<ul> <li>https://pubs.acs.org/doi/pdf/10.1021/acs.jcim.6b00596</li> <li>RDKit Cook Book - Creating fragments - https://www.rdkit.org/docs/Cookbook.html#create-fragments</li> </ul>"},{"location":"tutorials/Fuzzy_Scaffolds.html","title":"Fuzzy Scaffolds","text":"In\u00a0[1]: Copied! <pre>import datamol as dm\n\n# Get some mols\ndata = dm.data.cdk2()\n\ndata[\"mol\"] = data[\"smiles\"].apply(dm.to_mol)\n\ndm.to_image(data[\"mol\"].iloc[:12].tolist(), mol_size=(200, 150), use_svg=False)\n</pre> import datamol as dm  # Get some mols data = dm.data.cdk2()  data[\"mol\"] = data[\"smiles\"].apply(dm.to_mol)  dm.to_image(data[\"mol\"].iloc[:12].tolist(), mol_size=(200, 150), use_svg=False) Out[1]: In\u00a0[2]: Copied! <pre>with dm.without_rdkit_log():\n    scaffolds, scf2infos, scf2groups = dm.scaffold.fuzzy_scaffolding(data[\"mol\"].tolist())\n\nsfs = [dm.to_mol(s) for s in list(scaffolds)]\ndm.to_image(sfs, mol_size=(200, 150), max_mols=12, use_svg=False)\n</pre> with dm.without_rdkit_log():     scaffolds, scf2infos, scf2groups = dm.scaffold.fuzzy_scaffolding(data[\"mol\"].tolist())  sfs = [dm.to_mol(s) for s in list(scaffolds)] dm.to_image(sfs, mol_size=(200, 150), max_mols=12, use_svg=False) Out[2]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/Fuzzy_Scaffolds.html#Fuzzy-Scaffolds","title":"Fuzzy Scaffolds\u00b6","text":"<p>Fuzzy scaffolding is a concept useful for scaffold decoration and constrained scaffolding. If you want finer control over the generation of your scaffolds, you can use the fuzzy scaffold function to enforce specific groups that need to appear in the core as a sort of pharmacophore requirement.</p> <p>Note: A pharmacophore is essentially \u201ca part of a molecular structure that is responsible for a particular biological or pharmacological interaction that it undergoes\u201d.</p> <p>You can also force R groups to be included as well, allowing for flexibility to reconstruct specified positions (attachment points) in the scaffold. Overall, it allows you to build a highly specific molecular series to be used for MMPA.</p>"},{"location":"tutorials/Fuzzy_Scaffolds.html#Understanding-Key-Parameters","title":"Understanding Key Parameters\u00b6","text":"<ul> <li>enforce_subs - this lets you specify what substructure(s) you want to enforce on the scaffold</li> <li>n_atom_cuttoff - the minimum number of atoms a core should have. The smaller the number, the smaller the new scaffolds will be or the lesser number of new scaffolds will be generated, vice versa is true.</li> <li>ignore_non_ring - Some scaffolds might be a simple aliphatic chain, in other words, a molecule that only contains straight/branched chains with no rings. Most of the time, you want to *ignore these scaffolds* as they typically don\u2019t translate well in a drug-like context.</li> <li>mcs_params - This is quite a niche parameter. If two molecules in your dataset have a different Murcko scaffold but the same Minimum Common scaffold, toggling this argument will categorize these molecules into the same bucket using a maximum common substructure algorithm.</li> </ul>"},{"location":"tutorials/Fuzzy_Scaffolds.html#Datamol-Example","title":"Datamol Example\u00b6","text":""},{"location":"tutorials/Preprocessing.html","title":"Pre-Processing Molecules","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport datamol as dm\n\ndm.disable_rdkit_log()\n</pre> import pandas as pd import datamol as dm  dm.disable_rdkit_log() In\u00a0[4]: Copied! <pre># Load a dataset\ndata = dm.data.freesolv()\ndata = data.iloc[:100]\n\ndata\n</pre> # Load a dataset data = dm.data.freesolv() data = data.iloc[:100]  data Out[4]: iupac smiles expt calc 0 4-methoxy-N,N-dimethyl-benzamide CN(C)C(=O)c1ccc(cc1)OC -11.01 -9.625 1 methanesulfonyl chloride CS(=O)(=O)Cl -4.87 -6.219 2 3-methylbut-1-ene CC(C)C=C 1.83 2.452 3 2-ethylpyrazine CCc1cnccn1 -5.45 -5.809 4 heptan-1-ol CCCCCCCO -4.21 -2.917 ... ... ... ... ... 95 methoxyethane CCOC -2.10 -0.710 96 2-chloro-1,1,1-trimethoxy-ethane COC(CCl)(OC)OC -4.59 -3.638 97 isobutane CC(C)C 2.30 2.535 98 3-methylbutanoic acid CC(C)CC(=O)O -6.09 -8.844 99 2-chloro-1-(2,4-dichlorophenyl)ethenyl diethyl... CCOP(=O)(OCC)O/C(=C/Cl)/c1ccc(cc1Cl)Cl -7.07 -9.029 <p>100 rows \u00d7 4 columns</p> In\u00a0[5]: Copied! <pre>smiles_column = \"smiles\"\n\n\ndef _preprocess(row):\n    mol = dm.to_mol(row[smiles_column], ordered=True)\n    mol = dm.fix_mol(mol)\n    mol = dm.sanitize_mol(mol, sanifix=True, charge_neutral=False)\n    mol = dm.standardize_mol(\n        mol,\n        disconnect_metals=False,\n        normalize=True,\n        reionize=True,\n        uncharge=False,\n        stereo=True,\n    )\n\n    row[\"standard_smiles\"] = dm.standardize_smiles(dm.to_smiles(mol))\n    row[\"selfies\"] = dm.to_selfies(mol)\n    row[\"inchi\"] = dm.to_inchi(mol)\n    row[\"inchikey\"] = dm.to_inchikey(mol)\n    return row\n\n\ndata_clean = data.apply(_preprocess, axis=1)\ndata_clean\n</pre> smiles_column = \"smiles\"   def _preprocess(row):     mol = dm.to_mol(row[smiles_column], ordered=True)     mol = dm.fix_mol(mol)     mol = dm.sanitize_mol(mol, sanifix=True, charge_neutral=False)     mol = dm.standardize_mol(         mol,         disconnect_metals=False,         normalize=True,         reionize=True,         uncharge=False,         stereo=True,     )      row[\"standard_smiles\"] = dm.standardize_smiles(dm.to_smiles(mol))     row[\"selfies\"] = dm.to_selfies(mol)     row[\"inchi\"] = dm.to_inchi(mol)     row[\"inchikey\"] = dm.to_inchikey(mol)     return row   data_clean = data.apply(_preprocess, axis=1) data_clean Out[5]: iupac smiles expt calc standard_smiles selfies inchi inchikey 0 4-methoxy-N,N-dimethyl-benzamide CN(C)C(=O)c1ccc(cc1)OC -11.01 -9.625 COc1ccc(C(=O)N(C)C)cc1 [C][O][C][=C][C][=C][Branch1][#Branch2][C][=Br... InChI=1S/C10H13NO2/c1-11(2)10(12)8-4-6-9(13-3)... OCGXPFSUJVHRHA-UHFFFAOYSA-N 1 methanesulfonyl chloride CS(=O)(=O)Cl -4.87 -6.219 CS(=O)(=O)Cl [C][S][=Branch1][C][=O][=Branch1][C][=O][Cl] InChI=1S/CH3ClO2S/c1-5(2,3)4/h1H3 QARBMVPHQWIHKH-UHFFFAOYSA-N 2 3-methylbut-1-ene CC(C)C=C 1.83 2.452 C=CC(C)C [C][=C][C][Branch1][C][C][C] InChI=1S/C5H10/c1-4-5(2)3/h4-5H,1H2,2-3H3 YHQXBTXEYZIYOV-UHFFFAOYSA-N 3 2-ethylpyrazine CCc1cnccn1 -5.45 -5.809 CCc1cnccn1 [C][C][C][=C][N][=C][C][=N][Ring1][=Branch1] InChI=1S/C6H8N2/c1-2-6-5-7-3-4-8-6/h3-5H,2H2,1H3 KVFIJIWMDBAGDP-UHFFFAOYSA-N 4 heptan-1-ol CCCCCCCO -4.21 -2.917 CCCCCCCO [C][C][C][C][C][C][C][O] InChI=1S/C7H16O/c1-2-3-4-5-6-7-8/h8H,2-7H2,1H3 BBMCTIGTTCKYKF-UHFFFAOYSA-N ... ... ... ... ... ... ... ... ... 95 methoxyethane CCOC -2.10 -0.710 CCOC [C][C][O][C] InChI=1S/C3H8O/c1-3-4-2/h3H2,1-2H3 XOBKSJJDNFUZPF-UHFFFAOYSA-N 96 2-chloro-1,1,1-trimethoxy-ethane COC(CCl)(OC)OC -4.59 -3.638 COC(CCl)(OC)OC [C][O][C][Branch1][Ring1][C][Cl][Branch1][Ring... InChI=1S/C5H11ClO3/c1-7-5(4-6,8-2)9-3/h4H2,1-3H3 NPEIUNVTLXEOLT-UHFFFAOYSA-N 97 isobutane CC(C)C 2.30 2.535 CC(C)C [C][C][Branch1][C][C][C] InChI=1S/C4H10/c1-4(2)3/h4H,1-3H3 NNPPMTNAJDCUHE-UHFFFAOYSA-N 98 3-methylbutanoic acid CC(C)CC(=O)O -6.09 -8.844 CC(C)CC(=O)O [C][C][Branch1][C][C][C][C][=Branch1][C][=O][O] InChI=1S/C5H10O2/c1-4(2)3-5(6)7/h4H,3H2,1-2H3,... GWYFCOCPABKNJV-UHFFFAOYSA-N 99 2-chloro-1-(2,4-dichlorophenyl)ethenyl diethyl... CCOP(=O)(OCC)O/C(=C/Cl)/c1ccc(cc1Cl)Cl -7.07 -9.029 CCOP(=O)(OCC)O/C(=C/Cl)c1ccc(Cl)cc1Cl [C][C][O][P][=Branch1][C][=O][Branch1][Ring2][... InChI=1S/C12H14Cl3O4P/c1-3-17-20(16,18-4-2)19-... FSAVDKDHPDSCTO-XYOKQWHBSA-N <p>100 rows \u00d7 8 columns</p> In\u00a0[6]: Copied! <pre>smiles_column = \"smiles\"\n\n\ndef _preprocess(i, row):\n\n    dm.disable_rdkit_log()\n\n    mol = dm.to_mol(row[smiles_column], ordered=True)\n    mol = dm.fix_mol(mol)\n    mol = dm.sanitize_mol(mol, sanifix=True, charge_neutral=False)\n    mol = dm.standardize_mol(\n        mol, disconnect_metals=False, normalize=True, reionize=True, uncharge=False, stereo=True\n    )\n\n    row[\"standard_smiles\"] = dm.standardize_smiles(dm.to_smiles(mol))\n    row[\"selfies\"] = dm.to_selfies(mol)\n    row[\"inchi\"] = dm.to_inchi(mol)\n    row[\"inchikey\"] = dm.to_inchikey(mol)\n    return row\n\n\ndata_clean = dm.parallelized(_preprocess, data.iterrows(), arg_type=\"args\", progress=True, total=len(data))\ndata_clean = pd.DataFrame(data_clean)\ndata_clean\n</pre> smiles_column = \"smiles\"   def _preprocess(i, row):      dm.disable_rdkit_log()      mol = dm.to_mol(row[smiles_column], ordered=True)     mol = dm.fix_mol(mol)     mol = dm.sanitize_mol(mol, sanifix=True, charge_neutral=False)     mol = dm.standardize_mol(         mol, disconnect_metals=False, normalize=True, reionize=True, uncharge=False, stereo=True     )      row[\"standard_smiles\"] = dm.standardize_smiles(dm.to_smiles(mol))     row[\"selfies\"] = dm.to_selfies(mol)     row[\"inchi\"] = dm.to_inchi(mol)     row[\"inchikey\"] = dm.to_inchikey(mol)     return row   data_clean = dm.parallelized(_preprocess, data.iterrows(), arg_type=\"args\", progress=True, total=len(data)) data_clean = pd.DataFrame(data_clean) data_clean <pre>  0%|          | 0/100 [00:00&lt;?, ?it/s]</pre> Out[6]: iupac smiles expt calc standard_smiles selfies inchi inchikey 0 4-methoxy-N,N-dimethyl-benzamide CN(C)C(=O)c1ccc(cc1)OC -11.01 -9.625 COc1ccc(C(=O)N(C)C)cc1 [C][O][C][=C][C][=C][Branch1][#Branch2][C][=Br... InChI=1S/C10H13NO2/c1-11(2)10(12)8-4-6-9(13-3)... OCGXPFSUJVHRHA-UHFFFAOYSA-N 1 methanesulfonyl chloride CS(=O)(=O)Cl -4.87 -6.219 CS(=O)(=O)Cl [C][S][=Branch1][C][=O][=Branch1][C][=O][Cl] InChI=1S/CH3ClO2S/c1-5(2,3)4/h1H3 QARBMVPHQWIHKH-UHFFFAOYSA-N 2 3-methylbut-1-ene CC(C)C=C 1.83 2.452 C=CC(C)C [C][=C][C][Branch1][C][C][C] InChI=1S/C5H10/c1-4-5(2)3/h4-5H,1H2,2-3H3 YHQXBTXEYZIYOV-UHFFFAOYSA-N 3 2-ethylpyrazine CCc1cnccn1 -5.45 -5.809 CCc1cnccn1 [C][C][C][=C][N][=C][C][=N][Ring1][=Branch1] InChI=1S/C6H8N2/c1-2-6-5-7-3-4-8-6/h3-5H,2H2,1H3 KVFIJIWMDBAGDP-UHFFFAOYSA-N 4 heptan-1-ol CCCCCCCO -4.21 -2.917 CCCCCCCO [C][C][C][C][C][C][C][O] InChI=1S/C7H16O/c1-2-3-4-5-6-7-8/h8H,2-7H2,1H3 BBMCTIGTTCKYKF-UHFFFAOYSA-N ... ... ... ... ... ... ... ... ... 95 methoxyethane CCOC -2.10 -0.710 CCOC [C][C][O][C] InChI=1S/C3H8O/c1-3-4-2/h3H2,1-2H3 XOBKSJJDNFUZPF-UHFFFAOYSA-N 96 2-chloro-1,1,1-trimethoxy-ethane COC(CCl)(OC)OC -4.59 -3.638 COC(CCl)(OC)OC [C][O][C][Branch1][Ring1][C][Cl][Branch1][Ring... InChI=1S/C5H11ClO3/c1-7-5(4-6,8-2)9-3/h4H2,1-3H3 NPEIUNVTLXEOLT-UHFFFAOYSA-N 97 isobutane CC(C)C 2.30 2.535 CC(C)C [C][C][Branch1][C][C][C] InChI=1S/C4H10/c1-4(2)3/h4H,1-3H3 NNPPMTNAJDCUHE-UHFFFAOYSA-N 98 3-methylbutanoic acid CC(C)CC(=O)O -6.09 -8.844 CC(C)CC(=O)O [C][C][Branch1][C][C][C][C][=Branch1][C][=O][O] InChI=1S/C5H10O2/c1-4(2)3-5(6)7/h4H,3H2,1-2H3,... GWYFCOCPABKNJV-UHFFFAOYSA-N 99 2-chloro-1-(2,4-dichlorophenyl)ethenyl diethyl... CCOP(=O)(OCC)O/C(=C/Cl)/c1ccc(cc1Cl)Cl -7.07 -9.029 CCOP(=O)(OCC)O/C(=C/Cl)c1ccc(Cl)cc1Cl [C][C][O][P][=Branch1][C][=O][Branch1][Ring2][... InChI=1S/C12H14Cl3O4P/c1-3-17-20(16,18-4-2)19-... FSAVDKDHPDSCTO-XYOKQWHBSA-N <p>100 rows \u00d7 8 columns</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/Preprocessing.html#Pre-Processing-Molecules","title":"Pre-Processing Molecules\u00b6","text":"<p>You\u2019ve probably heard the adage \u201cgarbage in, garbage out\u201d before in reference to the importance of data quality when it comes to AI/ML. The same holds true in the field of drug discovery. Given the scarcity and often non-consistent quality of available data for drug discovery, an initial clean-up is almost always required to ensure the use of high-quality data in the generation of your models. If you don\u2019t do this, the use of lesser quality data would definitely impact the accuracy of your models in any downstream task. Pre-processing of data and molecules is extremely important - let\u2019s dive in!</p>"},{"location":"tutorials/Preprocessing.html#Representing-Molecules","title":"Representing Molecules\u00b6","text":"<p>There are many ways in which molecules can be represented. In other words, how can we effectively express the complexity of a molecule in a way that machines can understand? Here are some existing methods:</p> <ul> <li>Molfile - a table that holds information about the atoms, bonds, connectivity and coordinates of a molecule</li> <li>SMILES - stands for Simplified Molecular Input Line-Entry System and the name essentially describes it. It\u2019s a line notation for encoding molecular structures where atoms are represented by their standard abbreviation as a chemical element (i.e. C for carbon, N for nitrogen, etc.). Multiple symbols are then used to define elements with charges, bonds, rings, aromaticity, stereochemistry, and much more. For more detail, read here.<ul> <li>As an example, CCO, OCC and C(O)C all refer to ethanol. Having a number of equally valid SMILES strings for a given molecule can be an issue, therefore, canonicalization algorithms can be used to generate canonical SMILES to produce unique and consistent SMILES strings.</li> <li>Although SMILES are commonly used, they are not perfect. In a generative model using SMILES as inputs and outputs, there are often invalid SMILES strings that are produced (i.e. the SMILE string correspond to an invalid molecule that violates basic chemical rules).</li> </ul> </li> <li>SELFIES - stands for SELF-referencIng Embedded Strings, it is another string-based representation for molecules that is generally more suitable for ML models and exhibits more robustness (i.e. more SELFIE strings corresponds to a valid molecule). Read more here.</li> <li>InChi - another string-based method of representing chemical structures developed by IUPAC. Read more here. On the other hand, InChi key is a newer version of InChi that is only useful for identifying molecules, however, it is impossible to reconstruct a molecule from an InChi key.</li> </ul> <p>See below for a graphic that summarizes some of the methods discussed in the section above:</p> <p></p> <p>*Source*</p> <p>Note: it\u2019s important to understand that all forms of molecular representation have their pros and cons. It\u2019s less of a one-size-fits-all and more about picking and choosing specific methods to represent a molecule given your specific use case.</p>"},{"location":"tutorials/Preprocessing.html#Sanitize-and-Standardize","title":"Sanitize and Standardize\u00b6","text":"<p>*Molecular sanitization* is the process of ensuring that the molecules in your dataset *are realistic*. You can read more about the sanitization procedure as applied in the RDKit here. In Datamol, there are a few extra steps as well, sanitization is done under the following procedure:</p> <ol> <li>Adjusting for nitrogen aromaticity since faulty valence for nitrogen in aromatic rings is  currently an issue in RDKit through the Sanifix algorithm.</li> <li>An extra conversion is done from mol \u2192 smiles \u2192 mol to ensure that the molecules are valid SMILES.</li> <li>Charge neutralization - this is NOT charge removal, it attempts to correct valence issues arising from incorrect charges being placed on atoms.</li> </ol> <p>Users can control the application of the sanifix algorithm or charge neutralization, users can toggle the respective parameters *sanifix* and *charge_neutral* to be TRUE/FALSE.</p> <p>The process of standardization is used to generate *canonical SMILES.* It is currently done using the following procedure which can be controlled by the user through the described parameters below:</p> <ul> <li>*disconnect_metals -* metal disconnection<ul> <li>Depending on the source of the database, some compounds may be reported in salt form or associated to metallic ions (e.g. the sodium salt of a carboxylic compound). In most cases, these counter-ions are not relevant so the use of this function is required before further utilization of the dataset.)</li> <li>More details here</li> </ul> </li> <li>*normalize -* ion (charge) and functional groups normalization<ul> <li>It corrects drawing errors and standardizes functional groups in the molecule as well as ensuring the overall proper charge of the compound</li> <li>More details here</li> </ul> </li> <li>*reionize -* reionization of the molecule (protonation following the acidity order)<ul> <li>If one or more acidic functionalities are present in the molecule, this option ensures the correct neutral/ionized state for such functional groups. Molecules are uncharged by adding and/or removing hydrogens. For zwitterions, hydrogens are moved to eliminate charges where possible. However, in cases where there is a positive charge that is not neutralizable, an attempt is made to also preserve the corresponding negative charge</li> <li>Read more here</li> </ul> </li> <li>*uncharge* - charge removal<ul> <li>This option neutralizes the molecule by reversing the protonation state of protonated and deprotonated groups if present (e.g. a carboxylate is re-protonated to the corresponding carboxylic acid).</li> <li>In cases where there is a positive charge that is not neutralizable, an attempt is made to also preserve the corresponding negative charge to ensure a net zero charge.</li> </ul> </li> <li>*stereo -* stereochemistry proper reassignment if missing.<ul> <li>Stereochemical information is corrected and/or added if missing using built-in RDKit functionality to force a clean recalculation of stereochemistry</li> </ul> </li> </ul> <p>The actual processes for sanitization and standardization described can get a bit too detailed, with lots of chemistry terminology. We recommend just sticking with the defaults already set in Datamol. It\u2019s enough just to understand the importance of why we sanitize and standardize our datasets as a key step in the pre-processing, as you continue spending time in the AI/ML for drug discovery field, you will get more familiar with the details.</p>"},{"location":"tutorials/Preprocessing.html#Tutorial","title":"Tutorial\u00b6","text":"<p>In this tutorial, let\u2019s walk through how to load a dataset and then apply the described pre-processing pipeline which will take a list of molecules and:</p> <ul> <li>Convert to a mol.</li> <li>Fix common errors in the mol.</li> <li>Sanitize the mol.</li> <li>Standardize the mol.</li> <li>Generate a standardized SMILES.</li> <li>Generate SELFIES.</li> <li>Generate InChi and InChi key.</li> <li>Save the results as CSV or SDF file formats.</li> </ul> <p>From here, we will generate a table where it can be more easily visualized. The option of parallelization will also be shown:</p> <p>Note: parallelizing the preprocessing will only be faster if your dataset is very large.</p>"},{"location":"tutorials/Preprocessing.html#References","title":"References\u00b6","text":"<ul> <li>https://depth-first.com/articles/2020/07/27/a-guide-to-molecular-standardization/</li> <li>Wikipedia - https://en.wikipedia.org/wiki/Simplified_molecular-input_line-entry_system#Terminology</li> </ul>"},{"location":"tutorials/Reactions.html","title":"Chemical Reactions","text":"In\u00a0[1]: Copied! <pre>import datamol as dm\n</pre> import datamol as dm In\u00a0[2]: Copied! <pre># Define a reaction from rxn block finle\nrxn = dm.reactions.rxn_from_block_file(\"data/ReactionBlock.rxn\", sanitize=True)\nrxn\n</pre> # Define a reaction from rxn block finle rxn = dm.reactions.rxn_from_block_file(\"data/ReactionBlock.rxn\", sanitize=True) rxn Out[2]: In\u00a0[3]: Copied! <pre>dm.reactions.is_reaction_ok(rxn, enable_logs=True)\n</pre> dm.reactions.is_reaction_ok(rxn, enable_logs=True) <pre>2022-10-18 15:33:48.135 | INFO     | datamol.reactions._reactions:is_reaction_ok:152 - Number of warnings:0\n2022-10-18 15:33:48.136 | INFO     | datamol.reactions._reactions:is_reaction_ok:153 - Number of preprocessing errors: 0\n2022-10-18 15:33:48.137 | INFO     | datamol.reactions._reactions:is_reaction_ok:154 - Number of reactants in reaction: 2\n2022-10-18 15:33:48.138 | INFO     | datamol.reactions._reactions:is_reaction_ok:155 - Number of products in reaction: 1\n2022-10-18 15:33:48.138 | INFO     | datamol.reactions._reactions:is_reaction_ok:156 - Preprocess labels added:((), ())\n</pre> Out[3]: <pre>True</pre> In\u00a0[4]: Copied! <pre># Apply reaction and snitize the products\nprod_mols = dm.reactions.apply_reaction(\n    rxn=rxn,\n    reactants=(dm.to_mol(\"CC(=O)O\"), dm.to_mol(\"NC\")),\n    as_smiles=False,\n    sanitize=True,\n    single_product_group=False,\n    product_index=0\n)\ndm.to_image(prod_mols, use_svg=False)\n</pre> # Apply reaction and snitize the products prod_mols = dm.reactions.apply_reaction(     rxn=rxn,     reactants=(dm.to_mol(\"CC(=O)O\"), dm.to_mol(\"NC\")),     as_smiles=False,     sanitize=True,     single_product_group=False,     product_index=0 ) dm.to_image(prod_mols, use_svg=False) Out[4]: In\u00a0[5]: Copied! <pre># Return a single product in SMILES and keep the open attachment points\nprod_smi_att = dm.reactions.apply_reaction(\n    rxn=rxn,\n    reactants=(dm.to_mol(\"[2*]CC(=O)O\"), dm.to_mol(\"NC[1*]\")),\n    as_smiles=False,\n    sanitize=True,\n    single_product_group=True,\n    rm_attach=False,\n    product_index=0\n)\nprod_smi_att\n</pre> # Return a single product in SMILES and keep the open attachment points prod_smi_att = dm.reactions.apply_reaction(     rxn=rxn,     reactants=(dm.to_mol(\"[2*]CC(=O)O\"), dm.to_mol(\"NC[1*]\")),     as_smiles=False,     sanitize=True,     single_product_group=True,     rm_attach=False,     product_index=0 ) prod_smi_att Out[5]: In\u00a0[6]: Copied! <pre># Return a single product in SMILES without any open attachment points\nprod_mol = dm.reactions.apply_reaction(\n    rxn=rxn,\n    reactants=(dm.to_mol(\"[2*]CC(=O)O\"), dm.to_mol(\"NC[1*]\")),\n    as_smiles=False,\n    sanitize=True,\n    single_product_group=True,\n    rm_attach=True,\n    product_index=0\n)\nprod_mol\n</pre> # Return a single product in SMILES without any open attachment points prod_mol = dm.reactions.apply_reaction(     rxn=rxn,     reactants=(dm.to_mol(\"[2*]CC(=O)O\"), dm.to_mol(\"NC[1*]\")),     as_smiles=False,     sanitize=True,     single_product_group=True,     rm_attach=True,     product_index=0 ) prod_mol Out[6]: In\u00a0[7]: Copied! <pre>scaffold = dm.to_mol(\"O=C(NCc1ccnc([2*])c1)[1*]\")\nfrag1 = dm.to_mol(\"[1*]OC1CCC1\")\nfrag2 = dm.to_mol(\"[2*]N1CCCC1\")\ndm.to_image([scaffold, frag1, frag2], use_svg=False)\n</pre> scaffold = dm.to_mol(\"O=C(NCc1ccnc([2*])c1)[1*]\") frag1 = dm.to_mol(\"[1*]OC1CCC1\") frag2 = dm.to_mol(\"[2*]N1CCCC1\") dm.to_image([scaffold, frag1, frag2], use_svg=False) Out[7]: In\u00a0[8]: Copied! <pre># Define reaction with SMARTS and apply reaction on the specified attachment points\n\nrxn1 = dm.reactions.rxn_from_smarts(\"[1*][*:1].[1*][*:2]&gt;&gt;[*:1][*:2]\")\nres1 = dm.reactions.apply_reaction(rxn1, (dm.to_mol(frag1), dm.to_mol(scaffold)), rm_attach=True, product_index=0)\ndm.to_image(res1, use_svg=False)\n</pre> # Define reaction with SMARTS and apply reaction on the specified attachment points  rxn1 = dm.reactions.rxn_from_smarts(\"[1*][*:1].[1*][*:2]&gt;&gt;[*:1][*:2]\") res1 = dm.reactions.apply_reaction(rxn1, (dm.to_mol(frag1), dm.to_mol(scaffold)), rm_attach=True, product_index=0) dm.to_image(res1, use_svg=False) Out[8]: In\u00a0[9]: Copied! <pre># One reaction to attach multiple specified attchment points\nrxn2 = dm.reactions.rxn_from_smarts(\"[1*][*:1].[2*][*:4].([1*][*:2].[2*][*:3])&gt;&gt;([*:1][*:2].[*:3][*:4])\")\nres2 = dm.reactions.apply_reaction(rxn2, (frag1, frag2, scaffold), product_index=0)\ndm.to_image(res2, use_svg=False)\n</pre> # One reaction to attach multiple specified attchment points rxn2 = dm.reactions.rxn_from_smarts(\"[1*][*:1].[2*][*:4].([1*][*:2].[2*][*:3])&gt;&gt;([*:1][*:2].[*:3][*:4])\") res2 = dm.reactions.apply_reaction(rxn2, (frag1, frag2, scaffold), product_index=0) dm.to_image(res2, use_svg=False) Out[9]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/Reactions.html#Chemical-Reactions","title":"Chemical Reactions\u00b6","text":""},{"location":"tutorials/Reactions.html#Tutorial","title":"Tutorial\u00b6","text":"<p>This tutorial will show you how to:</p> <ol> <li>Define reactions from SMARTS or Blocks</li> <li>Basic reactions examples</li> <li>Fragment replacement examples</li> </ol>"},{"location":"tutorials/Reactions.html#References","title":"References\u00b6","text":"<ul> <li>RDKit Documentation</li> </ul>"},{"location":"tutorials/Scaffolds.html","title":"Generate Scaffold","text":"In\u00a0[1]: Copied! <pre>from rdkit import Chem\nfrom rdkit.Chem.Scaffolds import MurckoScaffold\nfrom rdkit.Chem.Draw import MolsToGridImage\n\n# Load a list of molecules\nsmiles_list = [\n    \"CCOC1=CC=CC=C1C(=O)OCC(=O)NC1=CC=CC=C1\",\n    \"NC(=O)C1=C(NC(=O)COC2=CC=CC=C2C(F)(F)F)SC=C1\",\n    \"CC(C)NC(=O)CSCC1=CC=CC=C1Br\",\n    \"CC1=CC=C(C(=O)NC(C)C)C=C1NC(=O)C1=CC=CO1\",\n    \"O=C(CN1CCCCCC1=O)NCC1=CC=C(N2C=CN=C2)C(F)=C1\",\n]\nmol_list = [Chem.MolFromSmiles(smi) for smi in smiles_list]\n\nMolsToGridImage(mol_list)\n</pre> from rdkit import Chem from rdkit.Chem.Scaffolds import MurckoScaffold from rdkit.Chem.Draw import MolsToGridImage  # Load a list of molecules smiles_list = [     \"CCOC1=CC=CC=C1C(=O)OCC(=O)NC1=CC=CC=C1\",     \"NC(=O)C1=C(NC(=O)COC2=CC=CC=C2C(F)(F)F)SC=C1\",     \"CC(C)NC(=O)CSCC1=CC=CC=C1Br\",     \"CC1=CC=C(C(=O)NC(C)C)C=C1NC(=O)C1=CC=CO1\",     \"O=C(CN1CCCCCC1=O)NCC1=CC=C(N2C=CN=C2)C(F)=C1\", ] mol_list = [Chem.MolFromSmiles(smi) for smi in smiles_list]  MolsToGridImage(mol_list) Out[1]: In\u00a0[2]: Copied! <pre>scaffolds = [MurckoScaffold.GetScaffoldForMol(mol) for mol in mol_list]\n\nMolsToGridImage(scaffolds)\n</pre> scaffolds = [MurckoScaffold.GetScaffoldForMol(mol) for mol in mol_list]  MolsToGridImage(scaffolds) Out[2]: In\u00a0[3]: Copied! <pre>import datamol as dm\n\n# Load a list of molecules\nsmiles_list = [\n    \"CCOC1=CC=CC=C1C(=O)OCC(=O)NC1=CC=CC=C1\",\n    \"NC(=O)C1=C(NC(=O)COC2=CC=CC=C2C(F)(F)F)SC=C1\",\n    \"CC(C)NC(=O)CSCC1=CC=CC=C1Br\",\n    \"CC1=CC=C(C(=O)NC(C)C)C=C1NC(=O)C1=CC=CO1\",\n    \"O=C(CN1CCCCCC1=O)NCC1=CC=C(N2C=CN=C2)C(F)=C1\",\n]\nmol_list = [dm.to_mol(smi) for smi in smiles_list]\ndm.to_image(mol_list, mol_size=(200, 150), use_svg=False)\n</pre> import datamol as dm  # Load a list of molecules smiles_list = [     \"CCOC1=CC=CC=C1C(=O)OCC(=O)NC1=CC=CC=C1\",     \"NC(=O)C1=C(NC(=O)COC2=CC=CC=C2C(F)(F)F)SC=C1\",     \"CC(C)NC(=O)CSCC1=CC=CC=C1Br\",     \"CC1=CC=C(C(=O)NC(C)C)C=C1NC(=O)C1=CC=CO1\",     \"O=C(CN1CCCCCC1=O)NCC1=CC=C(N2C=CN=C2)C(F)=C1\", ] mol_list = [dm.to_mol(smi) for smi in smiles_list] dm.to_image(mol_list, mol_size=(200, 150), use_svg=False) Out[3]: In\u00a0[4]: Copied! <pre># Extracting Murcko scaffolds from list of compounds\nscaffolds = [dm.to_scaffold_murcko(mol) for mol in mol_list]\n\ndm.to_image(scaffolds, mol_size=(200, 150), use_svg=False)\n</pre> # Extracting Murcko scaffolds from list of compounds scaffolds = [dm.to_scaffold_murcko(mol) for mol in mol_list]  dm.to_image(scaffolds, mol_size=(200, 150), use_svg=False) Out[4]:"},{"location":"tutorials/Scaffolds.html#Generate-Scaffold","title":"Generate Scaffold\u00b6","text":""},{"location":"tutorials/Scaffolds.html#Introduction-to-Scaffolds","title":"Introduction to Scaffolds\u00b6","text":"<p>A scaffold is best defined as a molecular core of a compound where R groups are attached via attachment points. Scaffolds are important in drug discovery as they help us uncover structure-activity relationships (SAR) and often are found to be essential for the bioactivity of a given class of compounds. The general idea behind this approach is to find relationships between the structure of a compound and its properties such as biological activity and/or physicochemical properties.</p> <p>There are multiple ways to define a scaffold and this can make it hard to compare the results of different, independent studies that involve scaffolds.  If you\u2019re interested, you can read more about scaffolding here and here. Most of the time, we rely on the Murcko scaffold which is also known as the Bemis-Murcko framework.</p> <p>From Chemaxon: \u201cBemis and Murcko outlined a popular method for deriving scaffolds from molecules by removing side chain atoms. A molecular framework can be interpreted as a graph containing nodes and edges representing atom and bond types, respectively. Removing atom and bond labels or agglomerating nodes by chemotype yields a hierarchy of reduced graphs, or molecular equivalence classes, that represent sets of related molecules. Likewise, a framework can be further decomposed into individual rings (or the core ring assembly) using chemically intuitive rules: the rings can individually or jointly be considered as scaffolds derived from the original compound.\u201d</p> <p>Scaffolds are generally useful in two main ways:</p> <ol> <li>Identifying core structures that have preferential activity against some specific target classes. This can then serve as a \u201cbuilding block\u201d to further optimize active compounds on certain properties through the modification of R groups that are attached to the scaffold (sometimes referred to as scaffold decorations).</li> <li>Scaffold hopping - finding structurally distinct compounds that have the same activity</li> </ol> <p>Scaffold hopping is particularly useful in ligand-based virtual screening methods where the information of known active compounds is used for hit identification and optimization rather than the available structural data for the target protein. In this approach, you start with a search template (i.e. the scaffold of the known active compound with all the decorations), keep the decorations the same and replace the scaffold itself with a similar molecular structure</p> <p>Below is an image showing a network of possible scaffolds for a given molecule A:</p> <p></p> <p>If you\u2019re interested in learning more about scaffolds and how we explore scaffolds computationally, read this paper.</p>"},{"location":"tutorials/Scaffolds.html#Tutorial","title":"Tutorial\u00b6","text":"<p>So, what does this look like in practice? This tutorial will show you some of the basics of using scaffolds in drug discovery.</p> <ol> <li>Load an example dataset/list of molecules</li> <li>Identify the scaffolds</li> <li>This will then enable you to create a chemical series that can be used in an MMPA (see the fragmentation tutorial)<ol> <li>A molecular series refers to a set of two or more molecules with the same scaffold but different R groups at the same position, read more here. Once a molecular series is generated, it enables scientists to focus on studying molecular properties and how changes in the structure are associated with the changes in these values (e.g. SAR studies).</li> </ol> </li> </ol>"},{"location":"tutorials/Scaffolds.html#RDKit-Example","title":"RDKit Example\u00b6","text":""},{"location":"tutorials/Scaffolds.html#Datamol-Example","title":"Datamol Example\u00b6","text":""},{"location":"tutorials/Scaffolds.html#References","title":"References\u00b6","text":"<ul> <li>What is SAR? https://info.collaborativedrug.com/tofu-content-what-is-sar</li> <li>https://datagrok.ai/help/domains/chem/functions/murcko-scaffolds</li> <li>http://practicalcheminformatics.blogspot.com/2021/10/exploratory-data-analysis-with.html</li> </ul>"},{"location":"tutorials/The_Basics.html","title":"The Basics","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\n\nimport datamol as dm\n</pre> import matplotlib.pyplot as plt  import datamol as dm In\u00a0[2]: Copied! <pre># Mol from a smiles\nmol = dm.to_mol(\"O=C(C)Oc1ccccc1C(=O)O\", sanitize=True)\nmol\n</pre> # Mol from a smiles mol = dm.to_mol(\"O=C(C)Oc1ccccc1C(=O)O\", sanitize=True) mol Out[2]: In\u00a0[3]: Copied! <pre># Morgan fingerprint\nfp = dm.to_fp(mol)\nfp\n</pre> # Morgan fingerprint fp = dm.to_fp(mol) fp Out[3]: <pre>array([0, 0, 0, ..., 0, 0, 0], dtype=uint8)</pre> In\u00a0[4]: Copied! <pre># Generate a selfies\nselfies = dm.to_selfies(mol)\nselfies\n</pre> # Generate a selfies selfies = dm.to_selfies(mol) selfies Out[4]: <pre>'[C][C][=Branch1][C][=O][O][C][=C][C][=C][C][=C][Ring1][=Branch1][C][=Branch1][C][=O][O]'</pre> In\u00a0[5]: Copied! <pre># Get InChi\ninchi = dm.to_inchi(mol)\ninchi\n</pre> # Get InChi inchi = dm.to_inchi(mol) inchi Out[5]: <pre>'InChI=1S/C9H8O4/c1-6(10)13-8-5-3-2-4-7(8)9(11)12/h2-5H,1H3,(H,11,12)'</pre> In\u00a0[6]: Copied! <pre># Load a built-in dataset (only for demonstration purposes)\ndata = dm.data.freesolv()\n\n# Make a molecule column from the smiles column\ndata[\"mol\"] = data[\"smiles\"].apply(lambda x: dm.to_mol(x))\n\ndata.head()\n</pre> # Load a built-in dataset (only for demonstration purposes) data = dm.data.freesolv()  # Make a molecule column from the smiles column data[\"mol\"] = data[\"smiles\"].apply(lambda x: dm.to_mol(x))  data.head() Out[6]: iupac smiles expt calc mol 0 4-methoxy-N,N-dimethyl-benzamide CN(C)C(=O)c1ccc(cc1)OC -11.01 -9.625 &lt;img data-content=\"rdkit/molecule\" src=\"data:i... 1 methanesulfonyl chloride CS(=O)(=O)Cl -4.87 -6.219 &lt;img data-content=\"rdkit/molecule\" src=\"data:i... 2 3-methylbut-1-ene CC(C)C=C 1.83 2.452 &lt;img data-content=\"rdkit/molecule\" src=\"data:i... 3 2-ethylpyrazine CCc1cnccn1 -5.45 -5.809 &lt;img data-content=\"rdkit/molecule\" src=\"data:i... 4 heptan-1-ol CCCCCCCO -4.21 -2.917 &lt;img data-content=\"rdkit/molecule\" src=\"data:i... In\u00a0[7]: Copied! <pre># Convert a dataframe to a list of mols\ndata = dm.data.freesolv()\nmols = dm.from_df(data, smiles_column=\"smiles\")\nmols[:5]\n</pre> # Convert a dataframe to a list of mols data = dm.data.freesolv() mols = dm.from_df(data, smiles_column=\"smiles\") mols[:5] Out[7]: <pre>[&lt;rdkit.Chem.rdchem.Mol at 0x7f1f54b41720&gt;,\n &lt;rdkit.Chem.rdchem.Mol at 0x7f1f54b426e0&gt;,\n &lt;rdkit.Chem.rdchem.Mol at 0x7f1f54b408e0&gt;,\n &lt;rdkit.Chem.rdchem.Mol at 0x7f1f54b427a0&gt;,\n &lt;rdkit.Chem.rdchem.Mol at 0x7f1f54b42c80&gt;]</pre> In\u00a0[8]: Copied! <pre># Convert a list of mols to a dataframe\ndf = dm.to_df(mols)\ndf.head()\n</pre> # Convert a list of mols to a dataframe df = dm.to_df(mols) df.head() Out[8]: smiles iupac expt calc 0 COc1ccc(C(=O)N(C)C)cc1 4-methoxy-N,N-dimethyl-benzamide -11.01 -9.625 1 CS(=O)(=O)Cl methanesulfonyl chloride -4.87 -6.219 2 C=CC(C)C 3-methylbut-1-ene 1.83 2.452 3 CCc1cnccn1 2-ethylpyrazine -5.45 -5.809 4 CCCCCCCO heptan-1-ol -4.21 -2.917 In\u00a0[10]: Copied! <pre># Get a list of molecules\ndata = dm.data.freesolv()\nmols = dm.from_df(data)\nmols = mols[:8]\n\n# Make an image from the molecules list with their SMILES as legend.\nlegends = [dm.to_smiles(mol) for mol in mols]\ndm.viz.to_image(mols, legends=legends, n_cols=4, mol_size=(200, 200), use_svg=False)\n</pre> # Get a list of molecules data = dm.data.freesolv() mols = dm.from_df(data) mols = mols[:8]  # Make an image from the molecules list with their SMILES as legend. legends = [dm.to_smiles(mol) for mol in mols] dm.viz.to_image(mols, legends=legends, n_cols=4, mol_size=(200, 200), use_svg=False) Out[10]: In\u00a0[11]: Copied! <pre>smiles = \"O=C(C)Oc1ccccc1C(=O)O\"\nmol = dm.to_mol(smiles)\n\n# Generate conformers\n# If `n_confs` is None, an appropriate number of conformers will be picked\n# according to the size of the molecules.\nmol = dm.conformers.generate(mol, n_confs=None, rms_cutoff=None, minimize_energy=False)\nmol.GetNumConformers()\n</pre> smiles = \"O=C(C)Oc1ccccc1C(=O)O\" mol = dm.to_mol(smiles)  # Generate conformers # If `n_confs` is None, an appropriate number of conformers will be picked # according to the size of the molecules. mol = dm.conformers.generate(mol, n_confs=None, rms_cutoff=None, minimize_energy=False) mol.GetNumConformers() Out[11]: <pre>50</pre> In\u00a0[12]: Copied! <pre># Compute SASA from conformers (not on windows)\nsasa = dm.conformers.sasa(mol)\nsasa[:10]\n</pre> # Compute SASA from conformers (not on windows) sasa = dm.conformers.sasa(mol) sasa[:10] Out[12]: <pre>array([335.54161916, 328.89583715, 331.70118493, 335.84175163,\n       333.35663075, 335.69047204, 333.240087  , 337.22086805,\n       336.34704967, 332.86752587])</pre> In\u00a0[13]: Copied! <pre># Compute RMSD between conformers\nrmsd = dm.conformers.rmsd(mol)\nrmsd[:4, :4]\n</pre> # Compute RMSD between conformers rmsd = dm.conformers.rmsd(mol) rmsd[:4, :4] Out[13]: <pre>array([[6.61254163e-08, 1.01515980e+00, 1.01196417e+00, 3.80744856e-02],\n       [1.01515980e+00, 4.67577303e-08, 3.61762165e-02, 1.02185385e+00],\n       [1.01196417e+00, 3.61762165e-02, 4.67577303e-08, 1.01825112e+00],\n       [3.80744856e-02, 1.02185385e+00, 1.01825112e+00, 0.00000000e+00]])</pre> In\u00a0[14]: Copied! <pre># Visualize the conformers in 3D\ndm.viz.conformers(mol, n_confs=3, width=\"auto\")\n</pre> # Visualize the conformers in 3D dm.viz.conformers(mol, n_confs=3, width=\"auto\") In\u00a0[15]: Copied! <pre># Compute the pairwise Tanimoto similarity distance using Morgan fingerprints.\ndata = dm.data.freesolv()\ndata[\"mol\"] = data[\"smiles\"].apply(lambda x: dm.to_mol(x))\n\nmols = data[\"mol\"].to_list()\ndist_mat = dm.pdist(mols, n_jobs=None)\nplt.imshow(dist_mat)\nplt.colorbar()\n</pre> # Compute the pairwise Tanimoto similarity distance using Morgan fingerprints. data = dm.data.freesolv() data[\"mol\"] = data[\"smiles\"].apply(lambda x: dm.to_mol(x))  mols = data[\"mol\"].to_list() dist_mat = dm.pdist(mols, n_jobs=None) plt.imshow(dist_mat) plt.colorbar() Out[15]: <pre>&lt;matplotlib.colorbar.Colorbar at 0x7f1fe83d0bb0&gt;</pre> In\u00a0[16]: Copied! <pre># Easy parallelization\ndef compute_something(mol):\n    # just a fake computation\n    result = mol.GetNumAtoms() ** 0.5\n    return mol, result\n\n\ndata = dm.data.freesolv()\ndata[\"mol\"] = data[\"smiles\"].apply(lambda x: dm.to_mol(x))\n\nresults = dm.parallelized(compute_something, data[\"mol\"].tolist(), n_jobs=None)\nresults[:5]\n</pre> # Easy parallelization def compute_something(mol):     # just a fake computation     result = mol.GetNumAtoms() ** 0.5     return mol, result   data = dm.data.freesolv() data[\"mol\"] = data[\"smiles\"].apply(lambda x: dm.to_mol(x))  results = dm.parallelized(compute_something, data[\"mol\"].tolist(), n_jobs=None) results[:5] Out[16]: <pre>[(&lt;rdkit.Chem.rdchem.Mol at 0x7f1f4ff2a140&gt;, 3.605551275463989),\n (&lt;rdkit.Chem.rdchem.Mol at 0x7f1f4ff29e40&gt;, 2.23606797749979),\n (&lt;rdkit.Chem.rdchem.Mol at 0x7f1f4ff2a620&gt;, 2.23606797749979),\n (&lt;rdkit.Chem.rdchem.Mol at 0x7f1f4ff2a6e0&gt;, 2.8284271247461903),\n (&lt;rdkit.Chem.rdchem.Mol at 0x7f1f4ff2a800&gt;, 2.8284271247461903)]</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/The_Basics.html#Common-functions","title":"Common functions\u00b6","text":""},{"location":"tutorials/The_Basics.html#Dataframe-and-list-of-molecules","title":"Dataframe and list of molecules\u00b6","text":""},{"location":"tutorials/The_Basics.html#Visualization","title":"Visualization\u00b6","text":""},{"location":"tutorials/The_Basics.html#Conformers","title":"Conformers\u00b6","text":""},{"location":"tutorials/The_Basics.html#More-advanced-computation","title":"More advanced computation\u00b6","text":""},{"location":"tutorials/The_Basics.html#Parallelize-anything","title":"Parallelize anything\u00b6","text":""},{"location":"tutorials/Visualization.html","title":"Visualization","text":"<p>This tutorial will highligh the major viz related features of Datamol.</p> In\u00a0[1]: Copied! <pre>import datamol as dm\n</pre> import datamol as dm <p>First let's get a dataset.</p> In\u00a0[2]: Copied! <pre>data = dm.read_csv(\n    \"https://raw.githubusercontent.com/rdkit/rdkit/master/Data/NCI/first_200.tpsa.csv\",\n    comment=\"#\",\n    header=None,\n)\ndata.columns = [\"smiles\", \"tpsa\"]\n\n# Create a mol column\nwith dm.without_rdkit_log():\n    data[\"mol\"] = data[\"smiles\"].apply(dm.to_mol)\n\n# Patch the dataframe to render the molecules in it\ndm.render_mol_df(data)\n\ndata.iloc[0][\"mol\"]\n</pre> data = dm.read_csv(     \"https://raw.githubusercontent.com/rdkit/rdkit/master/Data/NCI/first_200.tpsa.csv\",     comment=\"#\",     header=None, ) data.columns = [\"smiles\", \"tpsa\"]  # Create a mol column with dm.without_rdkit_log():     data[\"mol\"] = data[\"smiles\"].apply(dm.to_mol)  # Patch the dataframe to render the molecules in it dm.render_mol_df(data)  data.iloc[0][\"mol\"] Out[2]: <p>Now let's cluster the molecules and only keep the first cluster.</p> In\u00a0[3]: Copied! <pre>cluster_indices, cluster_mols = dm.cluster_mols(data[\"mol\"].dropna().tolist(), cutoff=0.7)\nmols = cluster_mols[1]\n</pre> cluster_indices, cluster_mols = dm.cluster_mols(data[\"mol\"].dropna().tolist(), cutoff=0.7) mols = cluster_mols[1] <p>Display the molecules of the cluster while aligning then using MCS. This can be done using a simple boolean flag in <code>dm.to_image()</code>.</p> In\u00a0[4]: Copied! <pre>dm.to_image(mols, mol_size=(300, 200), align=True, use_svg=False)\n</pre> dm.to_image(mols, mol_size=(300, 200), align=True, use_svg=False) Out[4]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"}]}